<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Git Study | StarSea</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- gallery that comes before the header--><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></nav><div class="container post-meta"><div class="post-time">2017-02-24</div></div></div><div class="container post-header"><h1>Git Study</h1></div><div class="container post-content"><h1 id="Git-Study"><a href="#Git-Study" class="headerlink" title="Git Study"></a>Git Study</h1><h3 id="Git-Introduction"><a href="#Git-Introduction" class="headerlink" title="Git Introduction"></a>Git Introduction</h3><p>Git是一种开源的分布式版本管理系统。</p>
<p>每台安装了Git的机器上都会维持一个Git的本地仓库。</p>
<h3 id="本地版本库的创建与管理"><a href="#本地版本库的创建与管理" class="headerlink" title="本地版本库的创建与管理"></a>本地版本库的创建与管理</h3><h4 id="创建与文件提交"><a href="#创建与文件提交" class="headerlink" title="创建与文件提交"></a>创建与文件提交</h4><ul>
<li>初始化一个Git仓库：<code>git init</code>；</li>
<li>添加文件到Git仓库（<a href="#gitadd-principle">背后的原理</a>）:<ol>
<li><code>git add &lt;file&gt;</code> ，可以使用多次，添加多个文件；</li>
<li><code>git commit -m &quot;提交说明文字&quot;</code> ，完成一次提交。</li>
</ol>
</li>
</ul>
<h4 id="查看仓库状态"><a href="#查看仓库状态" class="headerlink" title="查看仓库状态"></a>查看仓库状态</h4><ul>
<li><code>git status</code> ，查看本地仓库的<a href="#workplace">工作区</a>状态，命令会告诉我们，当前有哪些文件被修改了，现在的状态是”没有添加任何文件“OR”已添加待提交“，此外还会对后续操作提示相应的命令；</li>
<li><code>git diff</code> ， 如果有文件被修改了，可以用该命令查看具体的修改内容（有”-“号的一行说明有删减，有“+”的一行说明有增加）。</li>
</ul>
<h4 id="版本回退与回退的撤销"><a href="#版本回退与回退的撤销" class="headerlink" title="版本回退与回退的撤销"></a>版本回退与回退的撤销</h4><ul>
<li><p><code>git log</code> ，查看提交的历史记录，以便确定回退到哪一个版本，精简输出可以使用<code>git log --pretty=oneline</code>；<span id="versionback"></span></p>
</li>
<li><p><code>git reflog</code> ，查看命令的历史记录，可以用于确定版本回退之前的最新版本号<code>commit_id</code> ；</p>
</li>
<li><p><code>git reset --hard &lt;commit_id&gt;</code> ，<code>commit_id</code> 是版本号，是SHA1计算得出的十六进制数字，每提交一次就会新生成一个<code>commit_id</code> ，版本号没有必要每次都输入完整，保证前几位不同就可以。此外，<code>HEAD</code> 表示当前版本号，<code>HEAD^</code> 表示上一个版本号，以此类推，<code>HEAD~100</code> 表示上100个版本号。</p>
<p><strong>注意</strong> ：对于只有一个版本的版本库是无法再回退到上一个状态（即最初初始化的状态）</p>
</li>
</ul>
<h4 id="工作区与暂存区"><a href="#工作区与暂存区" class="headerlink" title="工作区与暂存区"></a>工作区与暂存区</h4><ul>
<li><p><span id="workplace">工作区（Working Directory）</span></p>
<p>也就是当时使用<code>git init</code> 初始化的本地仓库的目录/文件夹。</p>
</li>
<li><p>版本库（Repository）</p>
<p>工作区内的隐藏目录<code>.git</code> ，这个目录不算工作区，而是属于版本库。版本库中最重要的部分是暂存区（stage/index）这也是Git与SVN不同之处，同时还有Git自动创建的第一个<a href="#branch">分支</a><code>master</code> 和指向<code>master</code> 的<a href="#pointer-HEAD">指针<code>HEAD</code></a> 。</p>
</li>
<li><p>工作区与暂存区的关系</p>
<p>这里通过<code>git add &lt;file&gt;</code> 的<span id="gitadd-principle">工作原理</span>来解释一下工作区与暂存区之间的关系。</p>
<ol>
<li><p><code>git add</code> 添加的时候，实际上是将文件或者文件的修改添加到暂存区中；</p>
</li>
<li><p><code>git commit</code> 提交文件或文件修改，实际上是将暂存区的所有内容提交到当前分支中。</p>
<p><strong>注意</strong>：</p>
<ul>
<li><p>提交之后，工作区就没有任何新的修改，暂存区也没有任何内容，同时产生了新的版本。</p>
</li>
<li><p>提交的时候，Git只负责将已经加入暂存区的修改内容提交到分支中，即若<code>git add</code> 之后再对文件进行修改，那么此时修改的内容是不会提交到分支中的。</p>
<p><code>git diff HEAD -- &lt;file&gt;</code> ，可以用于查看工作区与版本库中最新版本之间的区别。</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="管理与修改、删除"><a href="#管理与修改、删除" class="headerlink" title="管理与修改、删除"></a>管理与修改、删除</h4><p>Git跟踪并管理的是<strong>文件的修改部分</strong> ,而非整个文件。</p>
<p>所以，如果修改没有从工作区添加到暂存区，那么这些修改就无法被提交到版本库的最新版本中。</p>
<ul>
<li><p><code>git checkout -- &lt;file&gt;</code> ，直接放弃对工作区的所有修改，这比一行一行的恢复更省力气，有时候对于不知道修改了哪部分内容的情况也很有用。</p>
</li>
<li><p><code>git rm --cached &lt;file&gt;</code> ，将添加到暂存区的修改撤销（unstage），并将修改重新放回工作区，如果此时仍想撤销所有的修改，则执行命令<code>git checkout -- &lt;file&gt;</code> ；</p>
</li>
<li><p>如果已经向本地版本库提交了不合适的修改并想要撤销时，需要<a href="#versionback">版本回退</a>操作，前提是还没有推送到远程仓库。</p>
</li>
<li><p>若要删除<span id="local-delete"></span>一个文件，需要在工作区和版本库中同时删除该文件 <code>git rm &lt;file&gt;</code> ，并在删除完成后重新提交<code>git commit -m &lt;file&gt;</code> 一次：</p>
</li>
<li><p>若在工作区错删了文件，则可以借助版本库，将该文件恢复到最新一次提交的状态：<code>git checkout -- &lt;file&gt;</code> <em>（当然，如果回收站还没清空的话，也可以去回收站看看）</em>；</p>
</li>
<li><p><strong>注</strong> ：<code>git checkout</code> 的原理是，利用版本库中的最新版本替换工作区的版本。</p>
</li>
</ul>
<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>可以自己搭建Git服务器作为远程仓库，也可以使用Github的免费仓库（但是是公开的所有人可见的）。</p>
<p>一台电脑上也可以建立多个版本库，只要不在同一目录中即可。</p>
<p>Git支持SSH协议。</p>
<h4 id="添加远程库与推送Push"><a href="#添加远程库与推送Push" class="headerlink" title="添加远程库与推送Push"></a>添加远程库与推送Push</h4><p>在完成Github注册和SSH Key添加之后，就可以在Github上创建一个新的Git仓库，然后根据相应的提示，将本地仓库的文件推送（Push）到远程仓库中。</p>
<ul>
<li><code>git remote add origin &lt;仓库地址&gt;</code> ，在本地仓库目录下执行，将本地仓库与远程仓库进行关联，同时为远程仓库定义了新的名字<code>origin</code> ，当然也可以使用别的名字；</li>
<li><code>git push -u origin master</code> ，将本地仓库的内容推送到远成仓库，实际上是将当前分支<code>master</code> 的内容推送到远程仓库的<code>master</code> 分支，由于刚开始远程仓库是空的，所以第一次推送的时候，需要参数<code>-u</code> ，这样在推送的同时，还会建立起本地分支<code>master</code> 和远程仓库中<code>master</code> 分支的联系，以后推送和拉取内容就可以简化命令，即<code>git push origin master</code> 和<code>git pull</code> 。</li>
</ul>
<h4 id="从远程库克隆Clone"><a href="#从远程库克隆Clone" class="headerlink" title="从远程库克隆Clone"></a>从远程库克隆Clone</h4><ul>
<li><p><code>git clone https://github.com/zouguijin/docSync.git</code> </p>
</li>
<li><p><code>git clone git@github.com:zouguijin/docSync.git</code> </p>
<p>Git支持多种协议，默认的git（所使用的是ssh协议），此外还可以使用https协议（但是https协议有时候比较慢，而且每次推送都需要输入口令，使用ssh就不需要输入口令，<code>get clone</code> 的时候都要口令…）。</p>
</li>
</ul>
<h4 id="远程仓库文件的删除"><a href="#远程仓库文件的删除" class="headerlink" title="远程仓库文件的删除"></a>远程仓库文件的删除</h4><p>在<a href="#local-delete">管理与修改、删除</a> 部分，讲述了本地工作区和本地仓库文件的删除方法。若希望删除远程库中的文件，需要：</p>
<ol>
<li><p>进入与远程库相对应的本地仓库，切换到相应的分支，或者建立本地分支与远程分支的连接，然后通过<code>git pull</code> 将远程库的内容抓取到本地库中；</p>
</li>
<li><p>将不需要的内容在本地仓库中删除，然后再次添加<code>git add .</code> ，提交<code>git commit -m &quot;...&quot;</code> ，并最后推送到远程仓库覆盖原内容即可<code>git push origin branch</code> 。</p>
<p><strong>注</strong> ：如果上一个提交者不是当前机器，则不能直接在本地修改然后推送，会出现冲突，否则可以直接修改并推送。</p>
</li>
</ol>
<h3 id="分支（Branch）"><a href="#分支（Branch）" class="headerlink" title="分支（Branch）"></a>分支（Branch）</h3><p>创建属于自己的分支，其他人是看不到的，一个未完成的项目可以在分支上不断更新，直到完成之后再一次提交到<code>master</code> 主分支上。</p>
<h4 id="创建与合并"><a href="#创建与合并" class="headerlink" title="创建与合并"></a>创建与合并</h4><ul>
<li><p>原理：</p>
<p>一个分支就是一条时间线，随着不断地提交逐渐变长。最初只有主分支即<code>master</code> 分支，同时有一个<code>master</code> 指针指向主分支的最新提交，之前说的指针<code>HEAD</code> 指向的是指针<code>master</code> ，而不是指向最新提交。即：</p>
<blockquote>
<p><code>HEAD</code> -&gt; <code>master</code> -&gt; <code>最新提交</code> </p>
</blockquote>
<p>每次提交之后，<code>master</code> 分支都会向前延长，同时指针<code>master</code> 都会指向最新的提交，指针<code>HEAD</code> 的指向不变。</p>
<p>创建新的分支，例如<code>branch</code> 时，即创建新的指针<code>branch</code> ，指向与<code>master</code> 相同的提交，此时若将指针<code>HEAD</code> 指向<code>branch</code> ，则表示切换当前分支，由主分支切换到<code>branch</code> 分支。</p>
<blockquote>
<p><code>master</code> -&gt;<code>最新提交</code> &lt;- <code>branch</code> &lt;- <code>HEAD</code>  </p>
</blockquote>
<p>如果在<code>branch</code> 分支下提交新的修改，那么<code>branch</code> 分支就会向前延长，指针<code>branch</code> 指向最新提交，但此时指针<code>master</code> 保持切换前的指向位置不变。</p>
<p>合并分支，也就是将主分支的<code>master</code> 指针指向<code>branch</code> 指针所指向的最新提交即可，合并分支后，一般都会将工作时使用的新分支<code>branch</code> 删除，即删除<code>branch</code> 指针。</p>
<p><strong>注</strong> ：可见，所谓创建分支，只是创建了一个指针，切换、合并分支，只是改变了指针的指向，删除分支，只是将对应的指针删除，所有的操作都不涉及内容的改变。</p>
</li>
<li><p>命令操作</p>
<ul>
<li><code>git branch</code> ，查看分支情况，当前分支前会用<code>*</code> 标记；</li>
<li><code>git branch &lt;name&gt;</code> ，创建分支；</li>
<li><code>git checkout &lt;name&gt;</code> ，切换分支，由当前分支切换到指定命名分支；</li>
<li><code>git checkout -b &lt;name&gt;</code> ，创建&amp;切换分支；</li>
<li><code>git merge &lt;name&gt;</code> ，合并分支，将指定命名分支合并到当前分支上；（默认使用<code>Fast Forward</code> 模式，该模式下删除分支后，分支信息也随之删除，即看不到历史合并信息；若希望能看到历史合并信息，就需要禁用FF模式，并最好添加注释信息，即<code>git merge --no-ff -m &quot;注释信息&quot; &lt;name&gt;</code>）</li>
<li><code>git branch -d &lt;name&gt;</code> ，删除指定命名分支。</li>
</ul>
</li>
<li><p>合并冲突<span id="conflict-solve"></span></p>
<p>如果两个需要合并的分支各自都有新的提交，而且两者的提交在同一位置有不同的表述，在合并的时候就会出现冲突，即不能简单地删除、添加或者替换。</p>
<p>冲突出现的时候，在显示分支的括号中会多出<code>|MERGING</code> 字样，表示此时必须解决合并冲突，分支切换操作被禁止，这时需要利用<code>git diff</code> 查看文件内容，并手动修改冲突的内容，然后重新添加和提交即可。（Git会用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容）</p>
<p><code>git log --graph</code> 可以看到分支的合并情况，或者简化版<code>git log --graph --pretty=oneline --abbrev-commit</code> 。</p>
</li>
<li><p>分支管理策略</p>
<ul>
<li>保证主分支<code>master</code> 是稳定的，仅仅用于发布公开的、可以使用的新版本；</li>
<li>如果团队合作的话，需要新建一个团队开发提交的分支，例如<code>dev</code> 分支，平时的提交与合并都在该分支上完成，一个完整的版本完成之后再将<code>dev</code> 分支合并到主分支上。</li>
</ul>
</li>
</ul>
<h4 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h4><p>当遇到Bug的时候，可以切换到需要修复Bug的分支上，在该分支上创建临时的Bug分支，在临时分支上修复Bug，然后合并原分支上，最后删除临时分支即可。</p>
<p>此时，如果手头上的工作没有做完（工作区有正在修改的内容，如果将Bug修复完成之后就添加、提交，那么之前正在处理但未处理完成的工作就会和修复的Bug一起添加并提交上去，这是我们不想看见的），那么这时候就需要将未完成的工作<strong>先拿出工作区并暂存</strong>起来：</p>
<blockquote>
<p><code>git stash</code> </p>
</blockquote>
<p>此时，利用<code>git status</code> 查看工作区，会看见工作区是干净的。</p>
<p>完成Bug修复之后，可以再将之前的工作取出来放进工作区继续完成：</p>
<ul>
<li><code>git stash list</code> ，若有多个工作，可以先查看列表，再决定需要恢复哪个工作；</li>
<li><code>git stash apply</code> ，恢复工作之后，暂存的内容并不会自动删除，需要使用<code>git stash drop</code> 将相应的内容删除；</li>
<li><code>git stash pop</code> ，推荐使用，恢复工作的同时，可以将暂存的内容也删除；</li>
<li>若要指定恢复或者删除哪一条<code>stash</code> ，可以添加后续命令<code>stash@{x}</code> ，<code>x</code> 可以从<code>stash</code> 列表中选取。</li>
</ul>
<h4 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h4><p>为项目开发一个新的功能时，最好在项目分支上新建一个分支，功能完成之后再将新功能的代码合并到项目分支中。</p>
<p>如果在合并之前，需要放弃该功能分支，则需要通过强行删除的操作完成：</p>
<blockquote>
<p><code>git branch -D &lt;name&gt;</code></p>
</blockquote>
<h4 id="推送与抓取"><a href="#推送与抓取" class="headerlink" title="推送与抓取"></a>推送与抓取</h4><ul>
<li><p><code>git remote -v</code> ，查看远程库的信息，会给出本地可以抓取和推送的远程库的地址以及远程库的命名（默认是<code>origin</code>）；</p>
</li>
<li><p><code>git push origin &lt;name&gt;</code> ，推送分支，即将指定分支上的所有本地内容推送到远程仓库中的<strong>相对应</strong>的分支上，可以推送本地<code>master</code> 分支内容，也可以推送其他分支的内容；</p>
</li>
<li><p><code>git clone &lt;git/https&gt;</code> ，其他用户从远程库克隆的时候，默认情况下只能看到<code>master</code> 分支（当然其他分支也随之克隆下来了，只是不稍微调整是看不到的），前面说了，一般不会直接向<code>master</code> 分支推送修改，所以需要在本地创建远程仓库<code>origin</code> 的分支<code>branch</code> （这里的<code>branch</code> 需要与远程仓库的<code>branch</code> 同名）：</p>
<blockquote>
<p><code>git checkout -b branch origin/branch</code> </p>
</blockquote>
<p>只有这样，才能建立本地与远成仓库的联系，之后的抓取<code>git pull</code> 和推送<code>git push origin branch</code> 才可以进行。</p>
</li>
<li><p><code>git pull</code> ，抓取分支，首先需要建立本地分支与远程仓库相应分支之间的链接：</p>
<blockquote>
<p><code>git branch --set-upstream branch origin/branch</code> </p>
</blockquote>
<p>在之前建立本地分支与远程库分支的基础上，可以将最新的提交从远程库相应的分支上抓取下来：</p>
<blockquote>
<p><code>git pull</code> </p>
</blockquote>
<p>如果<code>git pull</code> 的时候出现冲突，则需要<a href="#conflict-solve">解决冲突</a> 。</p>
</li>
<li><p>本地分支，若不推送到远程，只有本地可见。</p>
</li>
</ul>
<h3 id="标签（Tag）"><a href="#标签（Tag）" class="headerlink" title="标签（Tag）"></a>标签（Tag）</h3><p>版本发布的时候，为了今后方便查找，一般会使用标签的方式，采用有意义的文字标记当前版本，即可以将标签当作版本库的一个快照，本质上标签就是一个指向某一次<code>commit</code> 的指针，类似于分支指针（但是分支指针可以移动，标签指针不可以移动）。</p>
<ul>
<li><code>git tag</code> ，查看所有标签；</li>
<li><code>git tag &lt;name&gt;</code> ，为当前分支生成一个标签，标签默认标记在最新的提交上；</li>
<li><code>git tag &lt;name&gt; &lt;commit_id&gt;</code> ，若想为历史的某一次提交生成标签，则找到该提交的<code>commit_id</code> 即可；</li>
<li><code>git tag -a &lt;tagname&gt; -m &quot;注释信息&quot; &lt;commit_id&gt;</code> ，创建标签并生成注释；</li>
<li><code>git show &lt;tagname&gt;</code> ，查看相应的标签信息；</li>
</ul>
<p><strong>注</strong> ：标签是按照字母顺序排序的，而不是按照时间排序。</p>
<ul>
<li><p><code>git tag -d &lt;tagname&gt;</code> ，删除本地标签；</p>
</li>
<li><p><code>git push origin &lt;tagname&gt;</code> ，将标签推送到远程仓库中；</p>
</li>
<li><p><code>git push origin --tags</code> ，一次性地将本地标签全部推送到远程库中；</p>
</li>
<li><p>若想要删除的标签已经被推送到了远程库中，那么需要两步才能删除标签：</p>
<blockquote>
<p><code>git tag -d &lt;tagname&gt;</code> #首先，本地删除</p>
<p><code>git push origin :refs/tags/&lt;tagname&gt;</code> #然后，远程删除库中的标签</p>
</blockquote>
</li>
</ul>
<h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><p>如果要参与开源项目，首先将开源项目<code>Fork</code> 到自己的仓库中，然后<strong>从自己的仓库中<code>Clone</code> </strong>，只有这样才能在本地修改之后，再次推送到Github上，若希望开源项目的官方接受自己的修改，则需要在Github上发起<code>Pull Request</code> 。</p>
<h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><p>.gitignore文件中的文件名将会在提交的时候被忽略，.gitignore文件需要放在版本库中。</p>
<p>.gitignore文件不需要从头开始编写，可以参照<a href="https://github.com/github/gitignore" title=".gitignore-doc" target="_blank" rel="external">官方文档</a>并进行相应的组合即可。</p>
<ul>
<li><code>git add -f &lt;file&gt;</code> ，有时候.gitignore文件中禁止提交的文件类型中，有你希望提交的一份文件，则可以通过上述命令强行添加并提交；</li>
<li><code>git check-ignore -v &lt;file&gt;</code> ，当发现一个文件无法添加和提交时，需要检查.gitignore文件中哪一条规则写错了，可以使用上述命令进行检查。</li>
</ul>
<h3 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h3><ul>
<li>当前仓库的配置文档存放在<code>.git/config</code> 文件中；</li>
<li>当前用户的配置文档存放在用户主目录下的隐藏文件<code>.gitignore</code> 中；</li>
<li><code>git config --global alias. &lt;short-command&gt; &lt;origin-command&gt;</code> ，配置别名，简化使用。</li>
</ul>
<h3 id="Git服务器搭建"><a href="#Git服务器搭建" class="headerlink" title="Git服务器搭建"></a>Git服务器搭建</h3><p>服务器系统采用Linux，推荐Ubuntu或者Debian，以下操作需要sudo权限。</p>
<ol>
<li><p>安装Git:</p>
<p><code>sudo apt-get install git</code> </p>
</li>
<li><p>创建Git用户，用于运行Git服务：</p>
<p><code>sudo adduser git</code> </p>
</li>
<li><p>添加公钥，保证用户的登录：</p>
<p>收集所有需要登录服务器的用户的公钥，即<code>id_rsa.pub</code> 文件的内容，将公钥添加进服务器的<code>/home/git/.ssh/authorized_keys</code> 文件中，一行一个。</p>
</li>
<li><p>初始化Git仓库：</p>
<p>选定一个目录作为Git仓库，例如<code>/git/git-server.git</code> ，在目录<code>/git</code> 下执行命令：</p>
<p><code>sudo git init --bare git-server.git</code> </p>
<p>创建的是裸仓库，即没有工作区，服务器的目的是为了共享，而不允许用户登录到服务器上去修改，然后将Git仓库的所有者更改为之前添加的用户git：</p>
<p><code>sudo chown -R git:git git-server.git</code> </p>
</li>
<li><p>禁用shell登录：</p>
<p>即禁止之前创建的用户git登录shell，可以通过编辑<code>/etc/passwd</code> 文件完成，将以下一行</p>
<p><code>git:x:1001:1001:,,,:/home/git:/bin/bash</code> </p>
<p>改为</p>
<p><code>git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</code> </p>
<p>意思就是，用户<code>git</code> 每次一登录shell就会自动退出，即无法登录shell进行其他操作，这么做的目的是，让<code>git</code> 用户可以正常通过ssh使用git，但禁止其登录shell。</p>
</li>
<li><p>远程Git仓库已经建立好了，其他客户端用户可以使用<code>git clone</code> 将服务器上的内容克隆到本地进行修改：</p>
<p><code>git clone git@server:/git/git-server.git</code> </p>
<p>修改完成之后，就是推送与共享了。</p>
</li>
</ol>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>