<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>leetcode189 Rotate Array | StarSea</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- gallery that comes before the header--><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/array/">array</a><a class="post-tag-link" href="/tags/leetcode/">leetcode</a></div><div class="post-time">2017-05-11</div></div></div><div class="container post-header"><h1>leetcode189 Rotate Array</h1></div><div class="container post-content"><h2 id="leetcode-189-Rotate-Array"><a href="#leetcode-189-Rotate-Array" class="headerlink" title="leetcode#189 Rotate Array"></a>leetcode#189 Rotate Array</h2><blockquote>
<p>Rotate an array of <em>n</em> elements to the right by <em>k</em> steps.</p>
<p>For example, with <em>n</em> = 7 and <em>k</em> = 3, the array <code>[1,2,3,4,5,6,7]</code> is rotated to <code>[5,6,7,1,2,3,4]</code>.</p>
<p><strong>Note:</strong><br>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</p>
</blockquote>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>将数组中的元素向右<strong>循环移动</strong>K位。</p>
<p>例如，给定数组<code>[1,2,3,4,5,6,7]</code>&amp;&amp;<code>k=3</code>，最后的结果是：<code>[5,6,7,1,2,3,4]</code></p>
<p>注意：本题至少有3种解法</p>
<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>我是由<strong>leetcode#61</strong>做到该题的，所以首先考虑的是“能不能成环，然后循环移动”，显然是不能的，毕竟这是数组，不是链表。</p>
<p>但是可以根据<code>k % nums.length</code>的值，将原数组分成两个部分，将原数组的后半部分移动到新创建的数组的前半部分，原数组的前半部分移动到新数组的后半部分，即可。（但是本题不返回，即它只会检测原数组的状态，必须对原数组<code>nums</code>进行修改，那么只能在最后将新数组的值一个一个地赋值给原数组了…）</p>
<p>后来的想法：</p>
<p>不妨先考虑<strong>数组的特点</strong>：每个元素都有下标指示，可以迅速确定数组的长度，并根据下标找到某一个位置的数组元素。</p>
<p>那么就可以考虑<strong>根据下标将两个元素的值进行交换</strong>的操作，结合在《编程之法》上看过的“将一个字符串以单词为单位进行逆序操作”，即可以得到类似于大神的解法一。</p>
<h4 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h4><p>理解起来很直观，但是步骤很繁琐是真的，关键是还创建了一个新的数组并进行数组赋值，时间复杂度和空间复杂度妥妥的<code>O(n)</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public void rotate(int[] nums, int k) &#123;</div><div class="line">        if(k == 0 || nums.length &lt; 2) &#123; return; &#125;</div><div class="line">        else &#123;</div><div class="line">            int[] newArr = new int[nums.length];</div><div class="line">            int steps = k % nums.length;</div><div class="line">            int index = 0;</div><div class="line">            for(int i = nums.length - steps ; i &lt;= nums.length - 1 ; i++) &#123;</div><div class="line">                newArr[index++] = nums[i]; </div><div class="line">            &#125;</div><div class="line">            for(int j = index; j &lt;= nums.length - 1; j++) &#123;</div><div class="line">                newArr[j] = nums[j - index];</div><div class="line">            &#125;</div><div class="line">            for(int m = 0 ; m &lt;= nums.length - 1 ; m++) &#123;</div><div class="line">                nums[m] = newArr[m];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="大神解法"><a href="#大神解法" class="headerlink" title="大神解法"></a>大神解法</h4><p>解法一：<strong>分块反转算法</strong>（即字符串以单词为单位逆序的算法）</p>
<p>取余，将数组分为两块：经过移动后，移到数组前半部分的一块和移到数组后半部分的一块，然后先对数组整体进行逆序，然后分别对两块部分进行逆序，即可。</p>
<p>当然，也可以先分别对两块部分逆序，最后对数组整体进行逆序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void rotate(int[] nums, int k) &#123;</div><div class="line">    k %= nums.length;</div><div class="line">    reverse(nums, 0, nums.length - 1);</div><div class="line">    reverse(nums, 0, k - 1);</div><div class="line">    reverse(nums, k, nums.length - 1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void reverse(int[] nums, int start, int end) &#123;</div><div class="line">    while (start &lt; end) &#123;</div><div class="line">        int temp = nums[start];</div><div class="line">        nums[start] = nums[end];</div><div class="line">        nums[end] = temp;</div><div class="line">        start++;</div><div class="line">        end--;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解法二：有关最大公约数的算法</p>
<p>没看懂里面的数学关系是怎么来的…但是大概意思了解：</p>
<p>方法<code>findGcd()</code>用于查找<code>k % nums.length</code>和<code>nums.length</code>之间的最大公约数——在该算法里代表了遍历的次数；<code>count = nums.length / gcd - 1</code>即每一次遍历中需要交换的次数。</p>
<p>该算法大致就是在多次遍历中包含多次交换，从而得出最后的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public void rotate(int[] nums, int k) &#123;</div><div class="line">        if(nums.length &lt;= 1)&#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        //step each time to move</div><div class="line">        int step = k % nums.length;</div><div class="line">        //find GCD between nums length and step</div><div class="line">        int gcd = findGcd(nums.length, step);</div><div class="line">        int position, count;</div><div class="line">        </div><div class="line">        //gcd path to finish movie</div><div class="line">        for(int i = 0; i &lt; gcd; i++)&#123;</div><div class="line">            //beginning position of each path</div><div class="line">            position = i;</div><div class="line">            //count is the number we need swap each path</div><div class="line">            count = nums.length / gcd - 1;</div><div class="line">            for(int j = 0; j &lt; count; j++)&#123;</div><div class="line">                position = (position + step) % nums.length;</div><div class="line">                //swap index value in index i and position</div><div class="line">                nums[i] ^= nums[position];</div><div class="line">                nums[position] ^= nums[i];</div><div class="line">                nums[i] ^= nums[position];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">    public int findGcd(int a, int b)&#123;</div><div class="line">        return (a == 0 || b == 0) ? a + b : findGcd(b, a % b);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>本题很简单，一眼就可以看出解法，不过越简单的题包含的解法往往更多，而且一眼看出来的解法往往属于暴力解法；</li>
<li>链表的算法题，套路一般都比较浅，基本的方法也就是那几种，数组的题就不一样了，结合不同的数据结构，其解法往往变化多端，一句话：<strong>好好学习数据结构，数据结构是实现复杂算法的基石</strong>！</li>
</ul>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>