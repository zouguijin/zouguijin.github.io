<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Java---String | StarSea</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- gallery that comes before the header--><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Java-Basis/">Java Basis</a></div><div class="post-time">2017-05-23</div></div></div><div class="container post-header"><h1>Java---String</h1></div><div class="container post-content"><h2 id="Java-String——字符串"><a href="#Java-String——字符串" class="headerlink" title="Java String——字符串"></a>Java String——字符串</h2><h3 id="1-String对象是不可变的（常量）"><a href="#1-String对象是不可变的（常量）" class="headerlink" title="1 String对象是不可变的（常量）"></a>1 String对象是不可变的（常量）</h3><p>String对象具有只读特性，可以给一个String对象添加任意多的别名（也即引用），引用不能改变String对象本身的值。</p>
<p>不可变性，在字符串连接的操作过程中，会涉及到效率的问题。</p>
<p>如果单纯地使用Java重载的运算符“+”和“+=”，对字符串进行连接的操作，那么每一次连接之后都会新生成一个String对象，再获得最终连接结果之前会一直占据着内存空间，直到获得最终的字符串连接结果之后，中间生成的String对象都需要回收，影响回收的效率和资源。</p>
<p>所以，涉及到字符串连接的问题时，一般会采用<strong>StringBuilder</strong>的方式，生成一个StringBuilder对象，通过<strong>StringBuilder.append()</strong>方法，将需要连接的字符串全部连接到该StringBuilder对象上，最后输出的时候利用<strong>StringBuilder.toString()</strong>将StringBuilder对象转换成String对象即可。</p>
<p>使用StringBuilder创建一个StringBuilder对象，默认初始容量是16个字节，当然也可以<strong>自定义容量</strong>。只要加入的字符串长度没有超过StringBuilder的容量，就无需分配新的的内部缓冲区，否则StringBuilder的容量就会自动增大，即分配新的内部缓冲区。</p>
<h3 id="2-String类的常用操作"><a href="#2-String类的常用操作" class="headerlink" title="2 String类的常用操作"></a>2 String类的常用操作</h3><p>对于String对象的操作，如果没有改变String对象的内容，那么只是生成了一个新的引用指向原字符串对象；若改变了String对象的内容，则会创建一个新的String对象。</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">length()</td>
<td style="text-align:center">获取字符串长度</td>
</tr>
<tr>
<td style="text-align:center">charAt(int i)</td>
<td style="text-align:center">获取字符串相应位置的字符，范围是0~length()-1</td>
</tr>
<tr>
<td style="text-align:center">equals(String s)</td>
<td style="text-align:center">两个字符串比较是否相同，考虑大小写</td>
</tr>
<tr>
<td style="text-align:center">equalsIgnoreCase(String s)</td>
<td style="text-align:center">两个字符串比较是否相同，不考虑大小写</td>
</tr>
<tr>
<td style="text-align:center">compareTo(String s)</td>
<td style="text-align:center">两个字符串按照字典顺序比较大小，考虑大小写，实际上就是<strong>依次比较</strong>两个字符串对应位置商字符的ASCII码：调用对象字符的ASCII码 - 参数字符的ASCII码，最后返回一个数值（正数 负数 零）</td>
</tr>
<tr>
<td style="text-align:center">subString(int s)/subString(int s,int e)</td>
<td style="text-align:center">获取字符串的子串，范围是0~length()-1：（1）截取从s到字符串末尾的子串；（2）截取从s到(e-1)的子串</td>
</tr>
<tr>
<td style="text-align:center">toUpperCase()</td>
<td style="text-align:center">将字符串里的所有字符变成大写</td>
</tr>
<tr>
<td style="text-align:center">toLowerCase()</td>
<td style="text-align:center">将字符串里的所有字符变成小写</td>
</tr>
<tr>
<td style="text-align:center">String.valueOf(xxx)/Number.valueOf(String s)</td>
<td style="text-align:center">（1）将xxx转换成String对象；（2）将String对象转换成特定的基本数据包装类的对象，比如Integer/Double/Byte等</td>
</tr>
</tbody>
</table>
<h3 id="3-格式化的输出方式"><a href="#3-格式化的输出方式" class="headerlink" title="3 格式化的输出方式"></a>3 格式化的输出方式</h3><p>格式化风格的输出方式，便于在输出的时候控制字符之间的间距，将内容打印出表格形式的样子。</p>
<h4 id="（1）C语言风格的printf-方法"><a href="#（1）C语言风格的printf-方法" class="headerlink" title="（1）C语言风格的printf()方法"></a>（1）C语言风格的printf()方法</h4><p>由于C语言没有对字符串重载连接符“+”和“+=”，所以需要使用特殊的占位符——<strong>格式化说明符</strong>来表示将来需要填入数据的位置。</p>
<p>例如：<code>printf(&quot;The match is between %s and %s, and the result is: %d : %d.\n&quot;, team1, team2, team1Score, team2Score)</code></p>
<p>其中，<code>%x</code>表示特定的类型数据，之后的变量将会按照顺序填入之前确定好的位置之中。</p>
<h4 id="（2）System-out-format-方法"><a href="#（2）System-out-format-方法" class="headerlink" title="（2）System.out.format()方法"></a>（2）System.out.format()方法</h4><p>该方法可以用于PrintStream或者PrintWriter对象，与<strong>System.out.printf()</strong>的用法是一样的。</p>
<h4 id="（3）Formatter类"><a href="#（3）Formatter类" class="headerlink" title="（3）Formatter类"></a>（3）Formatter类</h4><p>即<code>java.util.Formatter</code>类，当创建一个Formatter对象的时候，需要向Formatter的构造器传递参数，告诉最终的结果将会<strong>输出</strong>到哪里：<code>new Formatter(System.out)</code>,这样在该类里，<code>Formatter.format()</code>方法的输出，将会自然而然地输出到<code>System.out</code>，就跟普通的打印到控制台一样。</p>
<p>经过重载的Formatter类的构造器可以接受多种输出目的地，常用的是System.out  PrintStream  OutputStream  File 。</p>
<h4 id="（4）格式化说明符"><a href="#（4）格式化说明符" class="headerlink" title="（4）格式化说明符"></a>（4）格式化说明符</h4><p><code>%[-] &lt;距离&gt; &lt;类型转换字符&gt; [%&lt;距离&gt; &lt;类型转换字符&gt;] ......\n</code></p>
<p>默认情况下，数据的输出是右对齐的，若要实现左对齐，需要在格式化说明符的最前面加上<code>-</code>标志。</p>
<p><strong>类型转换字符</strong></p>
<p><code>格式化说明符 = %&lt;距离&gt; &lt;类型转换字符&gt;</code></p>
<p>类型转换字符，可以将输入的参数转换成相应的类型数据，并输出。<strong>转换需要符合类型转换的规则</strong>。</p>
<p><code>Formatter.format(&quot;%s\n&quot;,&#39;d&#39;);</code>，意思就是将字符d转换成字符串。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>d</strong></th>
<th style="text-align:center"><strong>整数（十进制）</strong></th>
<th style="text-align:center"><strong>c</strong></th>
<th style="text-align:center"><strong>Unicode字符（其实就是char类型）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>s</strong></td>
<td style="text-align:center"><strong>String</strong></td>
<td style="text-align:center"><strong>x</strong></td>
<td style="text-align:center"><strong>整数（十六进制）</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>b</strong></td>
<td style="text-align:center"><strong>Boolean值</strong></td>
<td style="text-align:center"><strong>h</strong></td>
<td style="text-align:center"><strong>散列码（十六进制）</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>f</strong></td>
<td style="text-align:center"><strong>浮点数（十进制）</strong></td>
<td style="text-align:center"><strong>%</strong></td>
<td style="text-align:center"><strong>字符 %</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>e</strong></td>
<td style="text-align:center"><strong>浮点数（科学计数）</strong></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p><code>String.format()</code>是一个静态方法，使用方法和<code>Formatter.format()</code>一样，只不过输出的是String对象。</p>
<h3 id="4-正则表达式与String类"><a href="#4-正则表达式与String类" class="headerlink" title="4 正则表达式与String类"></a>4 正则表达式与String类</h3><p>正则表达式可以用于解决各种<strong>字符串处理</strong>相关的问题，包括匹配、选择、编辑以及验证等等。</p>
<p>关于正则表达式，将会有另一篇文章介绍。<a href="">正则表达式</a></p>
<h4 id="（1）String-split"><a href="#（1）String-split" class="headerlink" title="（1）String.split()"></a>（1）String.split()</h4><p>该方法将字符串从<strong>正则表达式匹配</strong>的地方，<strong>切分</strong>成前后字符串，切分后的结果一般会用数组Array来存储：<code>Arrays.toString(str.split(&quot; &quot;));</code></p>
<h4 id="（2）String-replaceFirst-String-replaceAll"><a href="#（2）String-replaceFirst-String-replaceAll" class="headerlink" title="（2）String.replaceFirst()/String.replaceAll()"></a>（2）String.replaceFirst()/String.replaceAll()</h4><p><code>String.replaceFirst(&quot;regex&quot;,&quot;replaceWords&quot;)</code>，只替换正则表达式匹配到的<strong>第一个</strong>子串。</p>
<p><code>String.replaceAll(&quot;regex&quot;,&quot;replaceWords&quot;)</code>，会将正则表达式匹配到的<strong>所有</strong>子串都替换。</p>
<h3 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h3><h4 id="1-关于运算符重载"><a href="#1-关于运算符重载" class="headerlink" title="1 关于运算符重载"></a>1 关于运算符重载</h4><p>用于字符串连接的“+”和“+=”是Java中仅有的两个重载过的操作符。</p>
<h4 id="2-StringBuilder与StringBuffer"><a href="#2-StringBuilder与StringBuffer" class="headerlink" title="2 StringBuilder与StringBuffer"></a>2 StringBuilder与StringBuffer</h4><p>StringBuilder是线程不安全的，即一般在单线程使用字符缓冲区的时候使用，多线程的时候保证线程安全一般使用StringBuffer。但是，StringBuffer由于考虑到了线程安全，所以较StringBuilder要慢一点。</p>
<h4 id="3-toString-方法"><a href="#3-toString-方法" class="headerlink" title="3 toString()方法"></a>3 toString()方法</h4><p>所有的容器类都覆写了toString()方法。</p>
<p>若想打印<strong>对象的内存地址</strong>，准确的应该是调用<strong>Object.toString()</strong>，即<strong>super.toString()</strong>，而不是当前类的this.toString()。（Object类是所有类的父类，包括容器类）</p>
<h4 id="4-Java-Doc"><a href="#4-Java-Doc" class="headerlink" title="4 Java Doc"></a>4 Java Doc</h4><p><a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html" target="_blank" rel="external">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html</a></p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>