<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>leetcode220 Contains Duplicate III | StarSea</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- gallery that comes before the header--><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/BinaySearchTree/">BinaySearchTree</a><a class="post-tag-link" href="/tags/Bucket/">Bucket</a><a class="post-tag-link" href="/tags/array/">array</a><a class="post-tag-link" href="/tags/leetcode/">leetcode</a></div><div class="post-time">2017-09-06</div></div></div><div class="container post-header"><h1>leetcode220 Contains Duplicate III</h1></div><div class="container post-content"><h2 id="leetcode-220-Contains-Duplicate-III"><a href="#leetcode-220-Contains-Duplicate-III" class="headerlink" title="leetcode#220 Contains Duplicate III"></a>leetcode#220 Contains Duplicate III</h2><blockquote>
<p>Given an array of integers, find out whether there are two distinct indices <em>i</em> and <em>j</em> in the array such that the <strong>absolute</strong> difference between <strong>nums[i]</strong> and <strong>nums[j]</strong> is at most <em>t</em> and the <strong>absolute</strong> difference between <em>i</em> and <em>j</em> is at most <em>k</em>.</p>
</blockquote>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>给定一个整数数组，以及两个整数k和t，要求判断是否存在两个不同索引对应的数组元素，索引值相差<strong>不超过</strong>k，且对应的值相差<strong>不超过</strong>t。</p>
<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>本题应该还是会使用HashSet或者HashMap这两种数据结构辅助求解。</p>
<p>此外，本题还有一点需要注意，即题目强调的两个“<strong>不超过</strong>”，数组值“不超过”可以很好判断，但是索引值的“不超过”，就需要添加一层额外的循环——如果以索引值作为HashMap的Key值的话。</p>
<h4 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h4><p>上述理解构造的解法会存在两个主要问题：</p>
<ul>
<li>整型数的溢出问题，由于所给出的整型数组没有限制必须是正数，所以会出现负数减去一个大正数，导致结果溢出整数范围：-2147483648~2147483647——可以使用<code>HashMap&lt;Integer,Long&gt;</code> 的泛型解决；</li>
<li>TLE限制，本解法的时间复杂度为O(kn)，还是遇到了TLE限制……</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123;</div><div class="line">        if(k == 0) return false;</div><div class="line">        long w = (long)t;</div><div class="line">        Map&lt;Integer,Long&gt; map = new HashMap&lt;Integer,Long&gt;();</div><div class="line">        for(int i = 0; i &lt; nums.length; i++) &#123;</div><div class="line">            map.put(i, (long)nums[i]);</div><div class="line">        &#125;</div><div class="line">        for(int i = 0; i &lt; nums.length; i++) &#123;</div><div class="line">            for(int j = 1; j &lt;= k; j++) &#123;</div><div class="line">                if(j + i &lt; nums.length) &#123;</div><div class="line">                    if(Math.abs(map.get(i) - map.get(j+i)) &lt;= w) return true;</div><div class="line">                &#125;</div><div class="line">                else</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="大神解法"><a href="#大神解法" class="headerlink" title="大神解法"></a>大神解法</h4><p>解法一：使用<strong>HashMap</strong>数据结构，结合重新映射操作，构建了一个<strong>Bucket</strong>数据结构。</p>
<p>本解法首先对数组元素进行了重新映射：对整型数的最小值进行作差，这样所有的数组元素值肯定是正数了；其次，将映射的新值对<code>(t+1)</code> 取商值，一是防了一手<code>t=0</code> ，二是为了将值进行缩放，从而放进<strong>数量有限的Bucket</strong>内；然后，由于对<code>t+1</code> 取商值毕竟会有误差，所以需要判断当前映射新值与(bucket-1)、bucket、(bucket+1)这三个桶内的值的差值是否不超过t，若确实不超过则返回<code>true</code> ；最后，需要<strong>保证桶的数量不超过k</strong>：如果map的大小（通过<code>map.entrySet().size()</code> 获取）已经不小于k，则需要定位并移除往前数第k个Bucket。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"> public class Solution &#123;</div><div class="line">    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123;</div><div class="line">        if (k &lt; 1 || t &lt; 0) return false;</div><div class="line">        // Long 防止整型数溢出</div><div class="line">        Map&lt;Long, Long&gt; map = new HashMap&lt;&gt;();</div><div class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</div><div class="line">        	// 将数组元素进行重新映射操作</div><div class="line">            long remappedNum = (long) nums[i] - Integer.MIN_VALUE;</div><div class="line">            // 对(t+1)取商值，是为了防止t=0</div><div class="line">            long bucket = remappedNum / ((long) t + 1);</div><div class="line">            // 对(t+1)取商值，肯定会有些许误差，相对于对t取商，可能会让结果落在(bucket-1)、bucket、(bucket+1)这三个值内，所以需要对这三个桶内的值进行比较</div><div class="line">            if (map.containsKey(bucket)</div><div class="line">                    || (map.containsKey(bucket - 1) &amp;&amp; remappedNum - map.get(bucket - 1) &lt;= t)</div><div class="line">                        || (map.containsKey(bucket + 1) &amp;&amp; map.get(bucket + 1) - remappedNum &lt;= t))</div><div class="line">                            return true;</div><div class="line">            // 保证map的大小在k的范围内，满足“索引值不超过k”的条件</div><div class="line">            if (map.entrySet().size() &gt;= k) &#123;</div><div class="line">                long lastBucket = ((long) nums[i - k] - Integer.MIN_VALUE) / ((long) t + 1);</div><div class="line">                map.remove(lastBucket);</div><div class="line">            &#125;</div><div class="line">            map.put(bucket, remappedNum);</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解法二：使用<strong>TreeSet</strong>数据结构，构建<strong>二叉查找树（Binay Search Tree）</strong>。</p>
<p>该解法将问题抽象为：维持一个<strong>连续的大小为k</strong>的二叉树（时间复杂度为O(NlogK)），然后在这个范围之内对值进行比较，判断是否存在差值不超过t的数组元素（时间复杂度为O(logK)）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123;</div><div class="line">        if (nums == null || nums.length == 0 || k &lt;= 0) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        // TreeSet 将对添加的元素自动排序</div><div class="line">        final TreeSet&lt;Integer&gt; values = new TreeSet&lt;&gt;();</div><div class="line">        for (int ind = 0; ind &lt; nums.length; ind++) &#123;</div><div class="line">        	// 返回二叉树中小于等于(nums[ind] + t)的最大值</div><div class="line">            final Integer floor = values.floor(nums[ind] + t);</div><div class="line">            // 返回二叉树中大于等于(nums[ind] - t)的最小值</div><div class="line">            final Integer ceil = values.ceiling(nums[ind] - t);</div><div class="line">            // 如果两个边界值floor&amp;ceil，都在[nums[ind] - t, nums[ind] + t]范围中，则返回true</div><div class="line">            if ((floor != null &amp;&amp; floor &gt;= nums[ind])</div><div class="line">                    || (ceil != null &amp;&amp; ceil &lt;= nums[ind])) &#123;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">			// 同样，需要维持二叉树的大小不超过k</div><div class="line">            values.add(nums[ind]);</div><div class="line">            if (ind &gt;= k) &#123;</div><div class="line">                values.remove(nums[ind - k]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>随着问题复杂度的提高，简单的HashMap数据结构本身已经不能直接解决问题，需要<strong>利用HashMap等基本数据结构进一步地构造</strong>出新的或精巧或复杂的数据结构。</p>
<p>例如本题的Bucket（通过特征缩放减少了桶的数量，从而能够维持不超过k的桶数量，而不需要额外的k循环，最终降低了时间复杂度），以及基于TreeSet构建的二叉查找树（TreeSet自动排序且无重复元素，从而减少了很多工作量，通过自带的方法可以简单地确认出边界，从而完成值的比较，索引值也可以通过添加元素的同时删去超过k的元素，保证二叉树的元素数量不超过k）。</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>