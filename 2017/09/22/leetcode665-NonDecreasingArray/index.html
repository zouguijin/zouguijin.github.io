<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>leetcode665 Non-decreasing Array | StarSea</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- gallery that comes before the header--><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/array/">array</a><a class="post-tag-link" href="/tags/leetcode/">leetcode</a></div><div class="post-time">2017-09-22</div></div></div><div class="container post-header"><h1>leetcode665 Non-decreasing Array</h1></div><div class="container post-content"><h2 id="leetcode-665-Non-decreasing-Array"><a href="#leetcode-665-Non-decreasing-Array" class="headerlink" title="leetcode#665 Non-decreasing Array"></a>leetcode#665 Non-decreasing Array</h2><blockquote>
<p>Given an array with <code>n</code> integers, your task is to check if it could become non-decreasing by modifying <strong>at most</strong> <code>1</code>element.</p>
<p>We define an array is non-decreasing if <code>array[i] &lt;= array[i + 1]</code> holds for every <code>i</code> (1 &lt;= i &lt; n).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;Input: [4,2,3]</div><div class="line">&gt;Output: True</div><div class="line">&gt;Explanation: You could modify the first 4 to 1 to get a non-decreasing array.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;Input: [4,2,1]</div><div class="line">&gt;Output: False</div><div class="line">&gt;Explanation: You can&apos;t get a non-decreasing array by modify at most one element.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Note:</strong> The <code>n</code> belongs to [1, 10,000].</p>
</blockquote>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>给定一个具有n个整数的数组，判断数组是否是<strong>不减</strong>的数组或者<strong>改变一个元素</strong>之后是否是不减的数组。</p>
<p>所谓“不减”，就是后一个元素大于或者等于前一个元素。</p>
<p>n的范围为：[1,10000]。</p>
<h4 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h4><p>最简单的方法就是，依次遍历数组元素，比较相邻元素的大小关系，如果最多只出现一次前一个元素大于后一个元素的情况，那么可以说数组是一个”不减“的数组，否则返回<code>false</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    public boolean checkPossibility(int[] nums) &#123;</div><div class="line">        int chance = 1;</div><div class="line">        int length = nums.length - 1;</div><div class="line">        while(chance &gt;= 0 &amp;&amp; length &gt;= 1) &#123;</div><div class="line">            if(nums[length] &gt;= nums[length-1]) &#123;</div><div class="line">                length--;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                length--;</div><div class="line">                chance--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return chance &gt;= 0 ? true : false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是上书解法会出现一个<strong>错误</strong>：就是相邻元素的关系满足“不减”，但是相距一定距离的两个元素不满足“不减”，所以不能单纯地比较相邻元素。</p>
<p>于是，需要全局考虑，那就先将数组元素的一个拷贝进行排序，然后将排序后数组与原数组的<strong>每一位依次进行比较</strong>，如果排序后的数组的每一位都大于等于原数组的相应位置元素，那么满足“不减”，或至多有一位小于原数组的对应位置元素，也可以是“不减”的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    public boolean checkPossibility(int[] nums) &#123;</div><div class="line">        PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;Integer&gt;();</div><div class="line">        for(int num : nums) &#123;</div><div class="line">            queue.offer(num);</div><div class="line">        &#125;</div><div class="line">        int chance = 1;</div><div class="line">        int index = 0;</div><div class="line">        while(chance &gt;=0 &amp;&amp; index &lt; nums.length) &#123;</div><div class="line">            if(queue.poll() &lt; nums[index]) &#123;</div><div class="line">                chance--;</div><div class="line">                index++;</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                index++;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return chance &gt;=0 ? true : false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述解法也存在一个问题：连续的、对称的大小反转情况，将判断不出来，比如<code>[1 2 4] -&gt; [4 2 1]</code> 。 </p>
<p>那么，还可以使用一个标记值<code>mark</code> ，用于<strong>标记已遍历过的数组元素中的最大值</strong>，如果后续元素有大于该标记值的元素，则替换该标记值，如果后续元素中有元素小于该标记值，且出现这种情况的次数大于1次，则该数组不满足“不减”的条件。</p>
<p>该解法仍旧存在<strong>问题</strong>：也许后续的元素都比某一个元素小，该解法会判断出<code>false</code> ，但是实际上将该元素改成比后续元素小即可，也满足“只修改一次”的条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    public boolean checkPossibility(int[] nums) &#123;</div><div class="line">        int mark = nums[0];</div><div class="line">        int chance = 1;</div><div class="line">        int index = 0;</div><div class="line">        while(chance &gt;= 0 &amp;&amp; index &lt; nums.length) &#123;</div><div class="line">            if(mark &gt; nums[index]) &#123;</div><div class="line">                chance--;</div><div class="line">                index++;</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                mark = nums[index];</div><div class="line">                index++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return chance &gt;= 0 ? true : false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="大神解法"><a href="#大神解法" class="headerlink" title="大神解法"></a>大神解法</h4><p>Greedy</p>
<p>考虑到如果出现不满足“不减”的情况，<strong>肯定首先出现一个相邻两个元素下降的位置</strong> ，从这个相邻位置出发，每遇到一个下降的位置就修改一次——即<strong>不断局部的检测和修改</strong>，就可以将该位置的元素大小信息<strong>扩散</strong>到后续位置上，从而可以避免上述前两种不完全的错误解法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public boolean checkPossibility(int[] nums) &#123;</div><div class="line">       int cnt = 0; //the number of changes</div><div class="line">       for(int i = 1; i &lt; nums.length &amp;&amp; cnt&lt;=1 ; i++)&#123;</div><div class="line">           if(nums[i-1] &gt; nums[i])&#123;</div><div class="line">               cnt++;</div><div class="line">               //modify nums[i-1] of a priority</div><div class="line">               // 比较相邻的三个数，选取其中最大的数，赋值给 i-1 或者 i 位置</div><div class="line">               // 从而将“当前最大的数”这个信息，逐渐往后续的元素位置上扩散</div><div class="line">               if(i-2&lt;0 || nums[i-2] &lt;= nums[i])nums[i-1] = nums[i];  </div><div class="line">               else nums[i] = nums[i-1]; //have to modify nums[i]</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       return cnt&lt;=1; </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>看似简单的问题……换了三种方式都没有做出来，真是惭愧，不过示例解法确实…想不到，GREEDY算法，还需要多多看看啊。</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>