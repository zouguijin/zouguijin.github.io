<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>leetcode217 Contains Duplicate | StarSea</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- gallery that comes before the header--><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/array/">array</a><a class="post-tag-link" href="/tags/leetcode/">leetcode</a></div><div class="post-time">2017-09-05</div></div></div><div class="container post-header"><h1>leetcode217 Contains Duplicate</h1></div><div class="container post-content"><h2 id="leetcode-217-Contains-Duplicate"><a href="#leetcode-217-Contains-Duplicate" class="headerlink" title="leetcode#217 Contains Duplicate"></a>leetcode#217 Contains Duplicate</h2><blockquote>
<p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
</blockquote>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>给定一个元素为整数的数组，要求判断该数组有没有重复的元素，如果有重复元素，则返回<code>true</code> ，否则返回<code>false</code> 。</p>
<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>简单的判断问题。以下是我最初想到的方法：</p>
<ul>
<li>暴力解法：选取数组中的一个元素值，然后与后续元素进行比较，判断有没有相同的元素；没有则选择下一个元素，重复上述过程，时间复杂度为O(n2)，空间复杂度O(1)；</li>
<li>在<code>for</code> 循环中，使用一个HashMap数据结构依次保存数组元素，在保存键值对之前，判断HashMap中是否已经有该元素值，有则返回<code>true</code> 否则就一直保存数组元素直到遍历完数组元素，时间复杂度O(n)，空间复杂度约等于O(n)。</li>
</ul>
<h4 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h4><p>使用了HashMap的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    public boolean containsDuplicate(int[] nums) &#123;</div><div class="line">        Map&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;();</div><div class="line">        for(int i = 0; i &lt; nums.length; i++) &#123;</div><div class="line">            if(map.containsKey(nums[i])) return true;</div><div class="line">            else</div><div class="line">                map.put(nums[i], 1);</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="大神解法"><a href="#大神解法" class="headerlink" title="大神解法"></a>大神解法</h4><p>解法一：使用<strong>HashSet</strong>——由于Set本身定义是不包含重复元素的，所以在添加元素的时候，Set会<strong>自动判断</strong>是否已经有该元素。复杂度与HashMap是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public  boolean containsDuplicate(int[] nums) &#123;</div><div class="line">	 Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();</div><div class="line">	 for(int i : nums)</div><div class="line">		 if(!set.add(i))// if there is same</div><div class="line">			 return true; </div><div class="line">	 return false;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>解法二：先对数组进行排序，然后相邻元素进行比较即可。使用数组自带的排序算法可以得到时间复杂度O(nlogn)，空间复杂度接近O(1)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public boolean containsDuplicate(int[] nums) &#123;</div><div class="line">      Arrays.sort(nums);</div><div class="line">      for(int ind = 1; ind &lt; nums.length; ind++) &#123;</div><div class="line">          if(nums[ind] == nums[ind - 1]) return true;</div><div class="line">      &#125;</div><div class="line">      return false;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>解法三：采用位运算Bit Manipulation的方法——本解法的<strong>限制条件</strong>是数组元素值的范围必须小于150000*8 = 1200000。时间复杂度为O(n)，空间复杂度是一个确定值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public boolean containsDuplicate(int[] nums) &#123;</div><div class="line">        byte[] mark = new byte[150000];</div><div class="line">        for (int i : nums) &#123;</div><div class="line">            int j = i/8;</div><div class="line">            int k = i%8;</div><div class="line">            int check = 1&lt;&lt;k;</div><div class="line">            if ((mark[j] &amp; check) != 0) &#123;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">            mark[j]|=check;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本题是一个很简单的题，也可以很容易地想到至少两种解法。本题的意义在于，充分地体现出了时间复杂度与空间复杂度之间的<strong>权衡</strong>问题。</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>