<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>leetcode121 Best Time to Buy and Sell Stock | StarSea</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- gallery that comes before the header--><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/DynamicProgramming/">DynamicProgramming</a><a class="post-tag-link" href="/tags/array/">array</a><a class="post-tag-link" href="/tags/leetcode/">leetcode</a></div><div class="post-time">2017-09-04</div></div></div><div class="container post-header"><h1>leetcode121 Best Time to Buy and Sell Stock</h1></div><div class="container post-content"><h2 id="leetcode-121-Best-Time-to-Buy-and-Sell-Stock"><a href="#leetcode-121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="leetcode#121 Best Time to Buy and Sell Stock"></a>leetcode#121 Best Time to Buy and Sell Stock</h2><blockquote>
<p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;Input: [7, 1, 5, 3, 6, 4]</div><div class="line">&gt;Output: 5</div><div class="line">&gt;</div><div class="line">&gt;max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;Input: [7, 6, 4, 3, 1]</div><div class="line">&gt;Output: 0</div><div class="line">&gt;</div><div class="line">&gt;In this case, no transaction is done, i.e. max profit = 0.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>这是一个应用问题，关于股票买卖。</p>
<p>给定一个数组，数组元素第i位表示的是：第i天的股票价格。现在允许进行的股票买卖操作是：</p>
<ul>
<li>只能进行一次买和一次卖——获得利润为卖出价格减去买进价格；</li>
<li>不买不卖——利润为0。</li>
</ul>
<p>现在需要找到最大的利润（如果不买不卖，返回利润为0）.</p>
<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>这是一道可能可以使用暴力解法解决的问题（看限制条件，有可能暴力解法会遇到TLE的限制），所以更优的解法应该倾向于动态规划算法——将原问题划分成多个子问题，然后各个击破，最终汇总结果。</p>
<h4 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h4><p>解法一：暴力解法（遇到TLE限制）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    public int maxProfit(int[] prices) &#123;</div><div class="line">        int maxPro = 0;</div><div class="line">        for(int i = 0; i &lt; prices.length; i++) &#123;</div><div class="line">            int maxTmp = 0;</div><div class="line">            for(int j = i + 1; j &lt; prices.length; j++) &#123;</div><div class="line">                maxTmp = prices[j] - prices[i];</div><div class="line">                if(maxPro &lt; maxTmp) maxPro = maxTmp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return maxPro;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解法二：动态规划</p>
<p>动态规划算法，需要先定义子问题的表达式——定义得好，有利于后续构建整体的DP算法。思路如下：</p>
<p>利用<code>maxProfit(int[] A, int i)</code> 表示<code>A[0:i]</code> 前i个元素中，所有<code>A[j] - A[i],(j &gt; i)</code> 结果的最大值——即子问题的定义，所以可以得到递归表达式：<code>maxProfit(A, i) = maxProfit(A, i-1) &gt; (A[i] - minVal) ? maxProfit(A, i -1) : (A[i] - minVal)</code> 。之后，就可以对递归表达式进行细化（根据问题的大小）：是用全局变量存储，还是实实在在地使用递归方式求解。</p>
<p>其中，变量的含义是：</p>
<ul>
<li><code>maxPro</code> ，全局最优值，即全局的最大利润值；</li>
<li><code>minVal</code> 存储遍历过程中的最小值，因为是“先买后卖”，所以只需要将后续获取第i个数组元素减去<code>minVal</code> ，就可以得到第i天卖出股票所获得的利润，再与<code>maxPro</code> 相比较即可得到全局最优值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    public int maxProfit(int[] prices) &#123;</div><div class="line">        if(prices.length == 0) return 0;</div><div class="line">        </div><div class="line">        int minVal = prices[0];</div><div class="line">        int maxPro = 0;</div><div class="line">        for(int i = 0; i &lt; prices.length; i++) &#123;</div><div class="line">            if(minVal &gt; prices[i]) minVal = prices[i];</div><div class="line">            maxPro = maxPro &gt;= (prices[i] - minVal) ? maxPro : (prices[i] - minVal);</div><div class="line">        &#125;</div><div class="line">        return maxPro;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解法二改进版：</p>
<p>之前一个版本中，不论<code>minVal</code>与<code>prices[i]</code> 的大小关系如何，都会进行一长串的三元操作符比较过程，相当消耗资源。于是，改进版中将三元操作符装进了条件语句中，RunTimeBeat从9%提升到了44%。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    public int maxProfit(int[] prices) &#123;</div><div class="line">        if(prices.length == 0) return 0;</div><div class="line">        </div><div class="line">        int minVal = prices[0];</div><div class="line">        int maxPro = 0;</div><div class="line">        for(int i = 0; i &lt; prices.length; i++) &#123;</div><div class="line">            if(minVal &gt; prices[i]) minVal = prices[i];</div><div class="line">            else &#123;</div><div class="line">                maxPro = maxPro &gt;= (prices[i] - minVal) ? maxPro : (prices[i] - minVal);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return maxPro;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="大神解法"><a href="#大神解法" class="headerlink" title="大神解法"></a>大神解法</h4><p>解法一：思路基本相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"> public int maxProfit(int[] prices) &#123;</div><div class="line">		 if (prices.length == 0) &#123;</div><div class="line">			 return 0 ;</div><div class="line">		 &#125;		</div><div class="line">		 int max = 0 ;</div><div class="line">		 int sofarMin = prices[0] ;</div><div class="line">	     for (int i = 0 ; i &lt; prices.length ; ++i) &#123;</div><div class="line">	    	 if (prices[i] &gt; sofarMin) &#123;</div><div class="line">	    		 max = Math.max(max, prices[i] - sofarMin) ;</div><div class="line">	    	 &#125; else&#123;</div><div class="line">	    		sofarMin = prices[i];  </div><div class="line">	    	 &#125;</div><div class="line">	     &#125;	     </div><div class="line">	    return  max ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解法二：</p>
<p>该解法中提到了一个算法——<strong>Kadane’s Algorithm</strong>。</p>
<p>上述解法都是针对数组值大于等于0的情况（因为股价不可能为负数），如果对于任意场景，特别是数组元素为负数时，上述解法将会出现问题。</p>
<p>而Kadane’s Algorithm提供了一种针对Max Subarray问题的普适性解决方法：</p>
<ul>
<li><code>maxCur</code> ，将<strong>当前的<code>maxCur</code> 值与数组相邻两个元素之间的差值</strong> 进行相加，注意，这里的<strong>加和值需要大于0</strong>才能作为新的<code>maxCur</code> 值保存，否则归零——<strong>原因</strong>为：假设<code>[...,x,y,z,...]</code> 有三个相邻元素，如果<code>(y-x)+(z-y)&lt;0</code> 即<code>y-x &lt;y-z</code> ，说明<code>z&lt;x</code> ，所以<code>z</code> 是当前遍历到的最小值，如果后续有较大的数<code>W</code> ，那么也会满足<code>W-z&gt;W-x</code> ；</li>
<li><code>maxSoFar</code> ，保存全局最优值。</li>
</ul>
<p>如此一来，即使数组元素有负数，也可以完成Max Subarray问题的求解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public int maxProfit(int[] prices) &#123;</div><div class="line">        int maxCur = 0, maxSoFar = 0;</div><div class="line">        for(int i = 1; i &lt; prices.length; i++) &#123;</div><div class="line">            maxCur = Math.max(0, maxCur += prices[i] - prices[i-1]);</div><div class="line">            maxSoFar = Math.max(maxCur, maxSoFar);</div><div class="line">        &#125;</div><div class="line">        return maxSoFar;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>关于动态规划的问题，暴力解法一般也都可以使用，所以这种题型一般都会对暴力解法设置限制条件，比如TLE；</li>
<li>了解动态规划的思想是很有必要的，除了解决算法问题，动态规划可以为解决其他复杂问题提供一种简化和切入的思路，尝试定义子问题的表达式，不断简化子问题的表达式，也许就可以从中发现一些规律，从而推广到整体问题；</li>
<li>关于<strong>Max Subarray问题</strong>，<strong>Kadane’s Algorithm</strong>（也属于动态规划算法）已经将其完美解决。</li>
</ul>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>