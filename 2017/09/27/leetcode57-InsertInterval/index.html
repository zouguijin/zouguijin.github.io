<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>leetcode57 Insert Interval | StarSea</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- gallery that comes before the header--><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/array/">array</a><a class="post-tag-link" href="/tags/leetcode/">leetcode</a></div><div class="post-time">2017-09-27</div></div></div><div class="container post-header"><h1>leetcode57 Insert Interval</h1></div><div class="container post-content"><h2 id="leetcode-57-Insert-Interval"><a href="#leetcode-57-Insert-Interval" class="headerlink" title="leetcode#57 Insert Interval"></a>leetcode#57 Insert Interval</h2><blockquote>
<p>Given a set of <em>non-overlapping</em> intervals, insert a new interval into the intervals (merge if necessary).</p>
<p>You may assume that the intervals were initially sorted according to their start times.</p>
<p><strong>Example 1:</strong><br>Given intervals <code>[1,3],[6,9]</code>, insert and merge <code>[2,5]</code> in as <code>[1,5],[6,9]</code>.</p>
<p><strong>Example 2:</strong><br>Given <code>[1,2],[3,5],[6,7],[8,10],[12,16]</code>, insert and merge <code>[4,9]</code> in as <code>[1,2],[3,10],[12,16]</code>.</p>
<p>This is because the new interval <code>[4,9]</code> overlaps with <code>[3,5],[6,7],[8,10]</code>.</p>
</blockquote>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>给定一个<strong>不重叠</strong> 、<strong>按照间隔起始时间先后排序</strong>的时间间隔的集合，现在插入一个新的时间间隔，要求进行适当的合并，并返回最终新的时间间隔。</p>
<p>所谓“合并”，就是因为新插入的时间间隔可能会跨越之前的好几个间隔，对于“跨越”的情况，就可以合并成一个时间间隔。</p>
<h4 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h4><p>最初的想法：这不就是一个简单的边界比较问题么？因为给定的时间间隔集合已经是有序的了，只需要拿着待插入间隔的<code>newStart</code>从头开始与每一个间隔的<code>end</code>比较——若<code>newStart &gt; end</code> ，则与后一个间隔比较；若<code>newStart &lt; end</code> 则与当前间隔的<code>start</code> 比较，若<code>newStart &gt; start</code> 则当前间隔的起始时间不变，若<code>newStart &lt; start</code> 则将当前间隔的起始时间改为<code>newStart</code> ；接着，拿着待插入间隔的<code>newEnd</code> 从尾部开始，与每一个间隔的<code>start</code> 比较——同理，不再赘述。最后，将遍历过程记下的<code>newStart</code> 位置到<code>newEnd</code> 位置之间的所有间隔从链表中删去（包括<code>newEnd</code> 所在间隔），然后将<code>newStart</code> 所在间隔的<code>end</code> 改为<code>newEnd</code> 。</p>
<p>实现的结果还是有点bug，虽然可以输出，但是边界的判断还是会时不时有点误差…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for an interval.</div><div class="line"> * public class Interval &#123;</div><div class="line"> *     int start;</div><div class="line"> *     int end;</div><div class="line"> *     Interval() &#123; start = 0; end = 0; &#125;</div><div class="line"> *     Interval(int s, int e) &#123; start = s; end = e; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">    public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123;</div><div class="line">        if(intervals.isEmpty()) return null;</div><div class="line">        </div><div class="line">        int newStart = newInterval.start;</div><div class="line">        int newEnd = newInterval.end;</div><div class="line">        int startPos = 0;</div><div class="line">        int endPos = intervals.size()-1;</div><div class="line">        </div><div class="line">        for(int i = 0; i &lt; intervals.size(); i++) &#123;</div><div class="line">            Interval curInter = intervals.get(i);</div><div class="line">            if(newStart &gt; curInter.end) continue;</div><div class="line">            else if(newStart &lt; curInter.start) &#123;</div><div class="line">                curInter.start = newStart;</div><div class="line">                startPos = i;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                startPos = i;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        for(int k = intervals.size() - 1; k &gt;= startPos; k--) &#123;</div><div class="line">            Interval curInter = intervals.get(k);</div><div class="line">            if(newEnd &lt; curInter.start) continue;</div><div class="line">            else if(newEnd &gt; curInter.end) &#123;</div><div class="line">                curInter.end = newEnd;</div><div class="line">                endPos = k;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                endPos = k;</div><div class="line">                newEnd = curInter.end;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        for(int i = startPos; i &lt;= endPos-1; i++) &#123;</div><div class="line">            intervals.remove(i);</div><div class="line">        &#125;</div><div class="line">        intervals.get(startPos).end = newEnd;</div><div class="line">        return intervals;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="大神解法"><a href="#大神解法" class="headerlink" title="大神解法"></a>大神解法</h4><p>直接求解，思路类似，更加简洁：</p>
<ul>
<li>创建新链表；</li>
<li>将集合中所有<code>end &lt; newStart</code> 的时间间隔先放入新链表——这些是肯定保留不动的；</li>
<li>将<code>start &lt;= newEnd</code> 的部分进行合并，具体的合并方式是：将该范围内间隔的首尾两端与<code>newInterval</code> 的首尾进行比较，不断返回新的<code>newInterval</code> ，然后继续比较；</li>
<li>最后是<code>newEnd &lt; start</code> 的时间间隔肯定也是不动的，全部放入链表；</li>
<li>将链表返回。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123;</div><div class="line">    List&lt;Interval&gt; result = new LinkedList&lt;&gt;();</div><div class="line">    int i = 0;</div><div class="line">    // add all the intervals ending before newInterval starts</div><div class="line">    while (i &lt; intervals.size() &amp;&amp; intervals.get(i).end &lt; newInterval.start)</div><div class="line">        result.add(intervals.get(i++));</div><div class="line">    // merge all overlapping intervals to one considering newInterval</div><div class="line">    while (i &lt; intervals.size() &amp;&amp; intervals.get(i).start &lt;= newInterval.end) &#123;</div><div class="line">        newInterval = new Interval( // we could mutate newInterval here also</div><div class="line">                Math.min(newInterval.start, intervals.get(i).start),</div><div class="line">                Math.max(newInterval.end, intervals.get(i).end));</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line">    result.add(newInterval); // add the union of intervals we got</div><div class="line">    // add all the rest</div><div class="line">    while (i &lt; intervals.size()) result.add(intervals.get(i++)); </div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>虽然已经想到了，与范例思路是一样的，但是实现的方式还是不给力——还是边界的把握不够好……</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>