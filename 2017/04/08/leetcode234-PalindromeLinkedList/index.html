<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>leetcode234 Palindrome Linked List | StarSea</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- gallery that comes before the header--><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Palindrome/">Palindrome</a><a class="post-tag-link" href="/tags/leetcode/">leetcode</a><a class="post-tag-link" href="/tags/linkedlist/">linkedlist</a></div><div class="post-time">2017-04-08</div></div></div><div class="container post-header"><h1>leetcode234 Palindrome Linked List</h1></div><div class="container post-content"><h2 id="leetcode-234-Palindrome-Linked-List"><a href="#leetcode-234-Palindrome-Linked-List" class="headerlink" title="leetcode#234 Palindrome Linked List"></a>leetcode#234 Palindrome Linked List</h2><blockquote>
<p>Given a singly linked list, determine if it is a palindrome.</p>
<p>Could you do it in O(n) time and O(1) space?</p>
</blockquote>
<h5 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h5><p>给定一条单链表，判断是否有回文。</p>
<p>是否能在<code>O(n)</code>时间复杂度和<code>O(1)</code>空间复杂度的限制下解决该问题？</p>
<h5 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h5><p>先解释一下“回文”的意思：不论正反来看，都是一样的。</p>
<p>对于单链表，也即不论正序读还是逆序读，都是一样的。</p>
<p>直观上的解法，就是分别从两头开始向中间遍历链表节点，判断节点的值是否相等，但是对于单链表来说，逆序获得下一个节点比较困难。同样，想从中间往两头分别遍历的思路也会遇到上述困难。</p>
<p>所以，可以考虑先<strong>将后半部分的链表反转</strong>，这样就可以构造出一个从两头开始，分别指向中间的链表结构，然后分别从两头开始向中间遍历链表节点，并判断即可。</p>
<h5 id="我的解法："><a href="#我的解法：" class="headerlink" title="我的解法："></a>我的解法：</h5><p>需要注意的一点是，<strong>链表为空&amp;&amp;链表中只有一个节点</strong>也符合回文。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * public class ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode next;</div><div class="line"> *     ListNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">public class Solution &#123;</div><div class="line">    public boolean isPalindrome(ListNode head) &#123;</div><div class="line">    	/* Boundary judgement */</div><div class="line">        if(head == null || head.next == null) &#123; return true; &#125;</div><div class="line">        /* Count the nodes in the list */</div><div class="line">        ListNode tmp = head;</div><div class="line">        int count = 1;</div><div class="line">        while(tmp.next != null) &#123;</div><div class="line">            tmp = tmp.next;</div><div class="line">            count++;</div><div class="line">        &#125;</div><div class="line">        int mid = count/2;</div><div class="line">        tmp = head;</div><div class="line">        for(int i = 0 ; i &lt; mid ; i++) &#123;</div><div class="line">            tmp = tmp.next;</div><div class="line">        &#125;</div><div class="line">        /* Reverse the list from the mid to the end of the list */</div><div class="line">        ListNode newHead = null;</div><div class="line">        while(tmp != null) &#123;</div><div class="line">            ListNode next = tmp.next;</div><div class="line">            tmp.next = newHead;</div><div class="line">            newHead = tmp;</div><div class="line">            tmp = next;</div><div class="line">        &#125;</div><div class="line">        /* Judge one by one */</div><div class="line">        while(newHead != null) &#123;</div><div class="line">            if(head.val != newHead.val) &#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                head = head.next;</div><div class="line">                newHead = newHead.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="大神解法："><a href="#大神解法：" class="headerlink" title="大神解法："></a>大神解法：</h5><p>本解法是投票数最多的一个。</p>
<p>本质的思路是一样的，只不过它在确定链表中点的时候，采用的是一快一慢两个指针，快指针一次移动两个节点位置，慢指针一次移动一个节点位置，当快指针到达链表末尾的时候，慢指针到达<code>list.length/2</code>的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public boolean isPalindrome(ListNode head) &#123;</div><div class="line">    ListNode fast = head, slow = head;</div><div class="line">    while (fast != null &amp;&amp; fast.next != null) &#123;</div><div class="line">        fast = fast.next.next;</div><div class="line">        slow = slow.next;</div><div class="line">    &#125;</div><div class="line">    if (fast != null) &#123; // odd nodes: let right half smaller</div><div class="line">        slow = slow.next;</div><div class="line">    &#125;</div><div class="line">    slow = reverse(slow);</div><div class="line">    fast = head;</div><div class="line">    </div><div class="line">    while (slow != null) &#123;</div><div class="line">        if (fast.val != slow.val) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        fast = fast.next;</div><div class="line">        slow = slow.next;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public ListNode reverse(ListNode head) &#123;</div><div class="line">    ListNode prev = null;</div><div class="line">    while (head != null) &#123;</div><div class="line">        ListNode next = head.next;</div><div class="line">        head.next = prev;</div><div class="line">        prev = head;</div><div class="line">        head = next;</div><div class="line">    &#125;</div><div class="line">    return prev;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>本题实际上是建立在<strong>链表反转</strong>的基础上（即leetcode#206），只要确定链表的中间节点并从中间节点开始反转后续的节点，之后的遍历比较就比较简单了。</p>
<h3 id="来自最高票数的声音："><a href="#来自最高票数的声音：" class="headerlink" title="来自最高票数的声音："></a>来自最高票数的声音：</h3><blockquote>
<p>It is a common misunderstanding that the space complexity of a program is just how much the size of additional memory space being used besides input. An important prerequisite is neglected the above definition: <a href="https://en.wikipedia.org/wiki/DSPACE#Machine_models" target="_blank" rel="external">the input has to be read-only</a>. By definition, changing the input and change it back is not allowed (or the input size should be counted when doing so). Another way of determining the space complexity of a program is to simply look at how much space it has written to. Reversing a singly linked list requires writing to O(n) memory space, thus the space complexities for all “reverse-the-list”-based approaches are O(n), not O(1).</p>
<p>Solving this problem in O(1) space is theoretically impossible due to two simple facts: (1) a program using O(1) space is computationally equivalent to a finite automata, or a regular expression checker; (2) <a href="https://en.wikipedia.org/wiki/Pumping_lemma_for_regular_languages" target="_blank" rel="external">the pumping lemma</a> states that the set of palindrome strings does not form a regular set.</p>
</blockquote>
<p>简单来说就是，我们常常误解了一个程序的空间复杂度只是除了输入之外的额外占用空间，上述说法成立的前提是忽略了以下定义：输入只能是只读的。这个定义的意思是，任何对输入进行修改的操作都是不被允许的。</p>
<p>而另一种对空间复杂度的理解则是，简单看有多少空间被占用。</p>
<p>将一个单链表反转是需要对链表本身进行修改的（违反了第一条定义），同时需要占用<code>O(n)</code>的空间（违反了第二条定义）。</p>
<p>（后面的自动机和@#￥%就看不懂了）</p>
<p>总之，本条评论认为，在<code>O(1)</code>的空间复杂度的限制条件下，本题是不可能通过反转链表的方式来解决的（尽管该方法也通过了，速度也很快）。</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>