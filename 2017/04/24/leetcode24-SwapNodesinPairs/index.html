<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>leetcode24 Swap Nodes in Pairs | StarSea</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- gallery that comes before the header--><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/leetcode/">leetcode</a><a class="post-tag-link" href="/tags/linkedlist/">linkedlist</a><a class="post-tag-link" href="/tags/reverse/">reverse</a></div><div class="post-time">2017-04-24</div></div></div><div class="container post-header"><h1>leetcode24 Swap Nodes in Pairs</h1></div><div class="container post-content"><h2 id="leetcode-24-Swap-Nodes-in-Pairs"><a href="#leetcode-24-Swap-Nodes-in-Pairs" class="headerlink" title="leetcode#24 Swap Nodes in Pairs"></a>leetcode#24 Swap Nodes in Pairs</h2><blockquote>
<p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given <code>1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code>2-&gt;1-&gt;4-&gt;3</code>.</p>
<p>Your algorithm should use only constant space. You may <strong>not</strong> modify the values in the list, only nodes itself can be changed.</p>
</blockquote>
<h5 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h5><p>给定一个单链表，每两个节点之间相互交换位置，最后返回处理之后的单链表。</p>
<p>例如：输入 <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code>，输出应该为 <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>
<p>注意，所编写的算法只能当前所给的空间（即不能创建新的一条链表），同时不能改变链表节点的值，只能改变节点本身的位置。</p>
<h5 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h5><p>本题直观上是简单的，如果没有任何的限制条件，可以每隔两个元素交换一下节点的值即可，但是在限定的条件下，只能通过实际地移动节点完成本题。</p>
<p>由于是每两个节点之间进行位置的交换，可以将每两个节点视为一组，一组一组地进行考虑和移动，这样可以在解决本题的基础上，<strong>最大程度地进行扩展</strong>，以适应每k个节点之间的位置交换问题的解决。</p>
<h5 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h5><p>先确定链表的<strong>尾节点</strong>，然后每两个节点为一组，在确定<strong>后续还有节点</strong>的基础上，将该组两个节点为一个单位<strong>整个插入</strong>到尾节点之后，以此类推，最后再将所得的链表进行一次<strong>链表反转</strong>操作即可。</p>
<ul>
<li>解法一（使用递归的链表反转）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * public class ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode next;</div><div class="line"> *     ListNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">public class Solution &#123;</div><div class="line">    public ListNode swapPairs(ListNode head) &#123;</div><div class="line">        if(head == null || head.next == null) &#123; return head; &#125;</div><div class="line">        ListNode one = head;</div><div class="line">        ListNode two = one.next;</div><div class="line">        while(head.next != null) &#123;</div><div class="line">            head = head.next;</div><div class="line">        &#125;</div><div class="line">        while(one != head &amp;&amp; two != head) &#123;</div><div class="line">            ListNode nextNode = two.next;</div><div class="line">            two.next = head.next;</div><div class="line">            head.next = one;</div><div class="line">            one = nextNode;</div><div class="line">            two = one.next;</div><div class="line">        &#125;</div><div class="line">        return reverseList(one,null);</div><div class="line">    &#125;</div><div class="line">    public ListNode reverseList(ListNode head,ListNode newHead) &#123;</div><div class="line">        if(head == null) &#123; return newHead; &#125;</div><div class="line">        ListNode next = head.next;</div><div class="line">        head.next = newHead;</div><div class="line">        return reverseList(next,head);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>解法二（使用非递归的链表反转，即constant space）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * public class ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode next;</div><div class="line"> *     ListNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">public class Solution &#123;</div><div class="line">    public ListNode swapPairs(ListNode head) &#123;</div><div class="line">        if(head == null || head.next == null) &#123; return head; &#125;</div><div class="line">        ListNode one = head;</div><div class="line">        ListNode two = one.next;</div><div class="line">        while(head.next != null) &#123;</div><div class="line">            head = head.next;</div><div class="line">        &#125;</div><div class="line">        while(one != head &amp;&amp; two != head) &#123;</div><div class="line">            ListNode nextNode = two.next;</div><div class="line">            two.next = head.next;</div><div class="line">            head.next = one;</div><div class="line">            one = nextNode;</div><div class="line">            two = one.next;</div><div class="line">        &#125;</div><div class="line">        return reverseList(one);</div><div class="line">    &#125;</div><div class="line">    public ListNode reverseList(ListNode head) &#123;</div><div class="line">        ListNode newHead = null;</div><div class="line">        while(head != null) &#123;</div><div class="line">            ListNode next = head.next;</div><div class="line">            head.next = newHead;</div><div class="line">            newHead = head;</div><div class="line">            head = next;</div><div class="line">        &#125;</div><div class="line">        return newHead;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="大神解法"><a href="#大神解法" class="headerlink" title="大神解法"></a>大神解法</h5><p>解法一：</p>
<p>非常的简洁和巧妙，虽然使用了<strong>递归（意味着空间复杂度不是constant space）</strong>。</p>
<p>每一步的递归所做的事：在保证有两个节点的基础上，将递归的入口移动到下一组两个节点的第一个节点位置，同时将当前组的第一个节点的<code>next</code>指针对准下一步的返回节点，在递归返回的时候，当前组第二个节点的<code>next</code>指针指向第一个节点，然后将第二个节点作为返回值，返回给上一层的递归。</p>
<p>虽然有点绕，但是实现的效果确实异常地巧妙，令人惊叹。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public ListNode swapPairs(ListNode head) &#123;</div><div class="line">        if ((head == null)||(head.next == null))</div><div class="line">            return head;</div><div class="line">        ListNode n = head.next;</div><div class="line">        head.next = swapPairs(head.next.next);</div><div class="line">        n.next = head;</div><div class="line">        return n;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解法二：</p>
<blockquote>
<p>在涉及到链表头结点变动的情况下，创建一个链表外的节点，指向链表的头结点</p>
</blockquote>
<p>本解法很好的使用了上述的一个<strong>准则</strong>，之后每三个节点为一组进行考虑，<code>current</code>每次都指向两个即将交换位置的节点的上一个节点，<code>first</code>节点和<code>second</code>节点分别指向即将交换位置的两个节点。</p>
<p>可以说，本解法算是<strong>最直观、最容易想到</strong>的方法，但是其扩展性不是很好，特别是当一组节点的数量k增大的时候，<code>current.next.next</code>这种写法显然是不现实的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public ListNode swapPairs(ListNode head) &#123;</div><div class="line">    ListNode dummy = new ListNode(0);</div><div class="line">    dummy.next = head;</div><div class="line">    ListNode current = dummy;</div><div class="line">    while (current.next != null &amp;&amp; current.next.next != null) &#123;</div><div class="line">        ListNode first = current.next;</div><div class="line">        ListNode second = current.next.next;</div><div class="line">        first.next = second.next;</div><div class="line">        current.next = second;</div><div class="line">        current.next.next = first;</div><div class="line">        current = current.next.next;</div><div class="line">    &#125;</div><div class="line">    return dummy.next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我的解法中，由于除了链表反转的部分，前面的处理代码都是相同的，因此我顺便<strong>比较</strong>了两种链表反转方法的性能：</p>
<ul>
<li>递归方法：不仅不是constant space，而且在程序运行时间上为9ms，only beat 3%；</li>
<li>非递归方法：既是constant space，而且在程序运行时间上为5ms，beat 37%。</li>
</ul>
<p>可见，在简单问题的解决上，非递归的解法性能要优于递归的方法，即在追求性能的前提下，递归不到万不得已最好不要使用，因为它既耗时又消耗空间——因为每一步的递归都需要存储上一步相应的值，等待下一步的递归返回。</p>
<p>此外，由于额外考虑到了<strong>每k个节点的顺序调换的问题</strong>，即leetcode#25 Reverse Nodes in k-Group，所以我的解法没有使用最直观的方法，而是考虑采取<strong>扩展性</strong>较高的“<strong>先按组移动节点，最后链表反转</strong>”的处理方法。</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>