<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Java---Concurrency | StarSea</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- gallery that comes before the header--><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/JavaBasis/">JavaBasis</a></div><div class="post-time">2017-07-19</div></div></div><div class="container post-header"><h1>Java---Concurrency</h1></div><div class="container post-content"><h2 id="Java-Concurrency——并发"><a href="#Java-Concurrency——并发" class="headerlink" title="Java Concurrency——并发"></a>Java Concurrency——并发</h2><blockquote>
<p>如果视而不见，就会遭其反噬。</p>
</blockquote>
<p>利用并发解决的问题可以分为两类：速度和设计可管理性。</p>
<ul>
<li><p>速度</p>
<p>并发通常是提高运行在<strong>单处理器</strong>上的程序的性能。</p>
<p>表面上看，在单处理器上，程序的所有部分当作单个任务运行似乎会更快一点，因为这将会节省<strong>上下文切换</strong>（从一个任务切换到另一个任务）的代价。</p>
<p>但是，程序会存在“<strong>阻塞</strong>”的情况，阻塞将会使程序中的某个任务因为程序外的条件限制（经常是IO）而不能继续执行。</p>
<p>并发的存在，可以让被阻塞的任务暂时挂起，转而执行其他的任务，在条件满足之后，再考虑继续执行之前挂起的任务，从而充分利用程序执行的时间。当然，如果程序中根本没有任务会发生阻塞，那么在单处理器上使用并发将没有任何意义。</p>
<p>此外，并发还可以通过<strong>事件驱动编程</strong>方式提高单处理器的处理性能，最常用的例子是用于产生具有可响应的用户界面，赋予程序一定程度的可响应性。</p>
</li>
<li><p>设计可管理性</p>
<p>并发中的<strong>协作多线程</strong>机制。</p>
<p><strong>Java的线程机制是抢占式</strong>的，即调度机制会<strong>周期性地中断线程</strong>，将上下文切换到另一个线程，从而为每个线程都提供时间片，使得每个线程都会分配到数量合理的时间去驱动它的任务。</p>
<p>协作式系统中，每个任务都会<strong>自动地放弃对于时间片的控制</strong>，这要求程序员有意识地在每个人物中插入某种类型的让步语句。<strong>协作式系统的优势</strong>：上下文切换的开销通常比抢占式系统低廉得多；对于同时执行的线程数量理论上没有任何限制。</p>
<p>通过并发，可以了解和掌握<strong>基于消息机制的架构</strong>——这是<strong>分布式系统</strong>创建的主要方式，因为分布式系统涉及到多台独立的计算机，并发将会是多进程级别的，如何在<strong>进程间同步信息</strong>将会是整个分布式系统协同工作的重点。 </p>
<p>线程可以提供更为<strong>松耦合</strong>的设计。</p>
</li>
</ul>
<h3 id="1-线程机制"><a href="#1-线程机制" class="headerlink" title="1 线程机制"></a>1 线程机制</h3><p>线程机制，允许我们<strong>将程序划分成多个分离、独立运行的任务</strong>，然后每一个任务都可以交由多个不同的执行线程进行驱动。一个线程就是当前执行进程中的一个单一顺序控制流，即进程可以包含多个线程（多个并发执行的任务），底层机制是切分CPU时间片，在线程看起来似乎自己拥有了自己的CPU一样。由于底层切分CPU时间片对于线程机制来说是透明、可扩展的，所以如果发现当前线程机制运行较慢，添加CPU即可。</p>
<h4 id="1-1-“任务”的定义一（Runnable）"><a href="#1-1-“任务”的定义一（Runnable）" class="headerlink" title="1.1 “任务”的定义一（Runnable）"></a>1.1 “任务”的定义一（Runnable）</h4><p>“任务”的定义可以由<strong>Runnable接口</strong>提供：实现Runnable接口并编写其中的<code>run()</code>方法——方法中的内容即为任务运行时将会执行的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public class Task implements Runnable &#123;</div><div class="line">  // ...</div><div class="line">  public void run() &#123; // task commands ...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="1-2-Thread类（线程类）"><a href="#1-2-Thread类（线程类）" class="headerlink" title="1.2 Thread类（线程类）"></a>1.2 Thread类（线程类）</h4><p>仅仅实现Runnable接口中的<code>run()</code>方法并不存在任何线程机制，要实现线程行为，必须<strong>显式</strong>地将一个任务附着到线程上。</p>
<p>最基本的方式，是将实现Runnable接口的对象，传递给一个Thread类构造器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Thread t = new Thread(new Task());</div><div class="line">t.start();</div></pre></td></tr></table></figure>
<p><code>start()</code>方法将会开启一个线程，并<strong>自动调用</strong><code>run()</code>方法，执行相应的任务命令。</p>
<p>注意：<code>main()</code> 方法本身就是一个线程——主线程（<strong>这意味着可以在任何一个线程中，启动另一个线程</strong>）。</p>
<p><strong>线程调度机制存在不确定性</strong>，即不确定线程将会分配给哪一个处理器运行（如果有多个处理器的话）、哪一个线程会优先执行，即使在程序上以先后顺序排列，如果希望让线程调度有优先级或者顺序，需要使用相应的数据结构或者自定义一套调度机制。</p>
<h4 id="1-3-Executors（执行器类）"><a href="#1-3-Executors（执行器类）" class="headerlink" title="1.3 Executors（执行器类）"></a>1.3 Executors（执行器类）</h4><p>虽然可以使用Thread类创建线程，然后将任务附着到线程上，由此实现线程的行为，但是每次都需要创建一个线程的操作着实很繁琐。</p>
<p><code>java.util.concurrent</code> 中的执行器（Executors）类将提供管理Thread对象的方法，从而简化并发编程。Executors在客户端和任务之间提供了一个<strong>间接层</strong>，间接层创建的中介对象将会代替客户端执行任务，同时给予异步任务执行的管理方法，从而避免了显式管理线程的生命周期。</p>
<p><strong>推荐使用执行器类启动任务，而不是单独创建一个Thread对象。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class ExecutorTasks &#123;</div><div class="line">  public static void main(String[] args) &#123;</div><div class="line">    ExecutorService exec = Executors.newCacheThreadPool(); // 不限制线程数</div><div class="line">    // ExecutorService exec = Executors.newFixedThreadPool(SIZE); // 限制线程数为SIZE</div><div class="line">    // ExecutorService exec = Executors.newSingleThreadExecutor(); // SIZE=1的FixedThreadPool</div><div class="line">    for(int i = 0; i &lt; 8; i++) &#123;</div><div class="line">      exec.execute(new Task()); // 将新任务提交给执行器exec，每一个任务都会附着到一个新的线程上，然后将自动调用run()执行相应的任务（多线程）</div><div class="line">    &#125;</div><div class="line">    exec.shutdown(); // 将会中止所有提交给exec的任务</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行器将会通过创建<strong>线程池</strong>的方式，为提交的任务分配线程：</p>
<ul>
<li><code>Executors.newCacheThreadPool()</code> ，创建的线程池将不限制分配的线程数量，不过当线程回收的数量大于新提交的任务数量，线程池将停止创建新线程，<strong>Executors的首选</strong>；</li>
<li><code>Executors.newFixedThreadPool(SIZE)</code> ，创建线程数量为SIZE的线程池，一次性完成线程池的创建，之后不再创建新的线程，如果提交的任务数量大于线程池中的线程数，那么将会在等待队列中（阻塞）等待回收的线程；</li>
<li><code>Executors.newSingleThreadExecutor()</code> ，线程数为1的线程池，适用于希望在另一个线程中<strong>连续运行</strong>的任务，比如监听进入的套接字连接的任务，也适用于线程中运行的<strong>短任务</strong>。同样，如果提交多个任务，SingleThreadExecutor将会序列化所有提交给它的任务，并回维护其（隐藏）的悬挂任务队列。</li>
</ul>
<h4 id="1-4-“任务”的定义二（Callable）与Future对象"><a href="#1-4-“任务”的定义二（Callable）与Future对象" class="headerlink" title="1.4 “任务”的定义二（Callable）与Future对象"></a>1.4 “任务”的定义二（Callable）与Future对象</h4><p>实现Runnable接口的任务只是执行任务的独立任务，没有返回值。</p>
<p>如果希望任务执行完毕后<strong>有返回值</strong>，那么需要实现<strong>Callable接口</strong> ，并将任务内容放置在<code>call()</code> 方法中，而且必须使用<code>ExecutorService.submit()</code> 方法提交任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class TaskCall implements Callable&lt;String&gt; &#123;</div><div class="line">  public String call()&#123; // Task Commands... &#125;</div><div class="line">&#125;</div><div class="line">public class TaskCallTest &#123;</div><div class="line">  public static void main(String[] args) &#123;</div><div class="line">  		ExecutorService exec = Executors.newCacheThreadPool();</div><div class="line">  		ArrayList&lt;Future&lt;String&gt;&gt; res = new ArrayList&lt;Future&lt;String&gt;&gt;();</div><div class="line">  		for(int i = 0; i &lt; 8; i++) &#123;</div><div class="line">    		res.add(exec.submit(new TaskCall()));</div><div class="line">  		&#125;</div><div class="line">  		// Do Something to res...</div><div class="line">  		exec.shutdown();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，方法<code>submit()</code> 的调用将会产生<strong>Future对象</strong>，Future对象将会以<code>call()</code> 方法的返回值作为类型参数，即上述代码段的<code>Future&lt;String&gt;</code> ，一般利用泛型容器保存。</p>
<h4 id="1-5-优先级"><a href="#1-5-优先级" class="headerlink" title="1.5 优先级"></a>1.5 优先级</h4><p>设置线程的优先级，可以将线程的重要性信息传递给线程调度器，以便线程调度器以<strong>较高的频率</strong>执行高优先级的线程。</p>
<p>有两点需要注意：</p>
<ul>
<li>“较高的频率”，也不能说明执行的顺序和时间；</li>
<li><strong>优先级不会导致死锁</strong>，只是低优先级的执行频率稍微少了一些。</li>
</ul>
<p>不同操作系统中的优先级级别有些许差异，所以如果要使用优先级（没事尽量不要操作优先级，按照默认即可），尽可能使用三级优先级，即：<code>MAX_PRIORITY</code>、<code>NORM_PRIORITY</code>、<code>MIN_PRIORITY</code> 。</p>
<h4 id="1-6-让步"><a href="#1-6-让步" class="headerlink" title="1.6 让步"></a>1.6 让步</h4><p>让步——<code>Thread.yield()</code>，即在完成任务之后，告诉线程调度器：我的工作已经完成，可以将资源分配给其他线程使用。但这只是“建议”，并不一定成功，所以对于重要性高的控制，不建议使用。</p>
<h4 id="1-7-后台线程（Daemon）"><a href="#1-7-后台线程（Daemon）" class="headerlink" title="1.7 后台线程（Daemon）"></a>1.7 后台线程（Daemon）</h4><p>后台线程，即在程序运行的时候在后台提供的一种通用服务的线程，并<strong>不属于程序不可或缺的一部分</strong> 。所以，当所有非后台程序完成之后，程序也就终止了，同时将杀死所有的后台线程。</p>
<p>后台线程也是线程，<strong>实现上唯一的区别</strong>在于：需要在启动线程之前，调用<code>Thread.setDaemon(true)</code> 方法，将线程设置为后台线程。</p>
<h4 id="1-8-实现线程的几种常见方式"><a href="#1-8-实现线程的几种常见方式" class="headerlink" title="1.8 实现线程的几种常见方式"></a>1.8 实现线程的几种常见方式</h4><p>大体上分为<strong>实现Runnable接口</strong>和<strong>继承Thread类</strong>两种方式。实现Runnable的好处在于：可以同时继承其他类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">// 自管理的Runnable</div><div class="line">class SelfManaged implements Runnable &#123;</div><div class="line">  Thread t = new Thread(this);</div><div class="line">  public SelfManaged()&#123; t.start(); &#125; // 构造方法中直接启动线程</div><div class="line">  public void run() &#123; // Do Somthing... &#125; // 使用Thread类继承的方式，也需要提供run()方法</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 如果内部类中具有在其他方法中需要访问的特殊能力或特殊方法，那么使用内部类实现线程具有意义</div><div class="line"></div><div class="line">// 命名内部类方式</div><div class="line">class NamedInner &#123;</div><div class="line">  private class Inner extends Thread &#123;</div><div class="line">    Inner(String name)&#123;</div><div class="line">      super(name);</div><div class="line">      start(); // 在命名内部类的构造方法中直接启动线程</div><div class="line">    &#125;</div><div class="line">    public void run() &#123; // Do Something... &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 匿名内部类方式</div><div class="line">class AnonymousInner &#123;</div><div class="line">  public AnonymousInner(String name) &#123;</div><div class="line">    Thread t = new Thread(name)&#123;</div><div class="line">      public void run()&#123; Do Something... &#125;</div><div class="line">    &#125;;</div><div class="line">    t.start();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 命名Runnable接口方式</div><div class="line">class NamedRunnable &#123;</div><div class="line">  private class Inner implenments Runnable &#123; // 这里可以继承其他类</div><div class="line">    Thread t;</div><div class="line">    public Inner(String name)&#123;</div><div class="line">      t = new Thread();</div><div class="line">      t.start();</div><div class="line">    &#125;</div><div class="line">    public void run() &#123; Do Something... &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 匿名Runnable接口方式</div><div class="line">class AnonymousRunnable &#123;</div><div class="line">  public AnonymousRunnable(String name) &#123;</div><div class="line">    Thread t = new Thread(new Runnable()&#123;</div><div class="line">      public void run() &#123; Do Something... &#125;</div><div class="line">    &#125;,name); </div><div class="line">    t.start();</div><div class="line">    // 即 new Thread(Runnable r, String s);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 在自定义的方法中创建线程（仅作为类的一个方法，当该方法被调用的时候才会创建线程）</div><div class="line">class SelfDefined &#123;</div><div class="line">  private String name;</div><div class="line">  public SelfDefined(String name) &#123; this.name = name; &#125;</div><div class="line">  public void runTask() &#123;</div><div class="line">    Thread t = new Thread(name)&#123;</div><div class="line">      public void run() &#123; Do Something... &#125;</div><div class="line">    &#125;;</div><div class="line">    t.start();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="1-9-ThreadFactory接口"><a href="#1-9-ThreadFactory接口" class="headerlink" title="1.9 ThreadFactory接口"></a>1.9 ThreadFactory接口</h4><p>即线程工厂，利用工厂设计模式，与线程池配合使用，用于创建线程和设置所创建线程的行为。ThreadFactory接口只有一个方法<code>newThread()</code>，其用法经常如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class SimpleThreadFactory implements ThreadFactory &#123;</div><div class="line">   public Thread newThread(Runnable r) &#123;</div><div class="line">     return new Thread(r);</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h4 id="1-10-线程的异常捕获"><a href="#1-10-线程的异常捕获" class="headerlink" title="1.10 线程的异常捕获"></a>1.10 线程的异常捕获</h4><p>JVM的设计理念来源于：<strong>线程是独立执行的代码片段，线程的问题应该由线程自身解决</strong>。</p>
<p>所以，Java中所有线程都不能捕获从线程中逃逸的异常，必须由线程自己处理，否则就会直接将异常打印在控制台上。</p>
<p>可以使用<strong>Thread.UncaughtExceptionHandler接口</strong> ，该接口允许在每个Thread对象上附着一个异常处理器，相应的方法<code>Thread.UncaughtExceptionHandler.uncaughtException()</code> ，将会在线程因未捕获的异常而临近死亡的时候调用，从而捕获线程中出现的异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// 实现 UncaughtExceptionHandler接口，并提供uncaughtException()方法的内容</div><div class="line">class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler &#123;</div><div class="line">	public void uncaughtException(Thread t, Throwable e) &#123;</div><div class="line">      	System.out.println(&quot;Caught&quot; + e);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">// 利用 ThreadFactory接口，创建线程</div><div class="line">class HandlerThreadFactory implements ThreadFactory &#123;</div><div class="line">  	public Thread newThread(Runnable r) &#123;</div><div class="line">      	Thread t = new Thread(r);</div><div class="line">      	t.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler()); // 将上述实现的异常处理器，绑定到当前线程对象上</div><div class="line">      	// t.getUncaughtExceptionHandler(); //返回实现UncaughtExceptionHandler接口的对象信息</div><div class="line">      	return t; // 该方法返回一个线程对象</div><div class="line">  	&#125;</div><div class="line">&#125;</div><div class="line">public class UncaughtExceptionTest &#123;</div><div class="line">  	public static void main(String[] args) &#123;</div><div class="line">      	ExecutorService exec = Executors.newCacheThreadPool(new HandlerThreadFactory()); // 将线程对象作为参数传给线程池，也即让线程池创建并提供该类线程，之后提交的任务都将由这类线程驱动处理，由此便可捕获任务执行过程中出现的异常</div><div class="line">      	exec.excute(new Task());</div><div class="line">      	TimeUnit.MILLISECONDS.sleep(1000);</div><div class="line">      	exec.shutdown();</div><div class="line">  	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你希望在代码的所有位置使用相同的异常处理器，那么可以简单一点——在Thread类中设置一个静态域，并将某个异常处理器设置为<strong>默认的未捕获异常处理器</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHandler());</div></pre></td></tr></table></figure>
<h4 id="1-11-线程状态"><a href="#1-11-线程状态" class="headerlink" title="1.11 线程状态"></a>1.11 线程状态</h4><p>一个线程可以处于以下四种状态之一：</p>
<ul>
<li>新建（New），线程被创建，分配资源，执行初始化，有机会获取CPU时间片，接下来转入就绪或者阻塞状态；</li>
<li>就绪（Runnable），该状态下，只要调度器将CPU时间片分配给线程，线程就能运行；</li>
<li>阻塞（Blocked），线程由于某种条件，即使获得了时间片也不能运行，所以调度器不会给这种状态下的线程分配时间片，接下来可能保持阻塞状态，或者转入就绪或死亡状态；</li>
<li>死亡（Dead），由于任务完成或者中断，线程将会死亡，再也不可调度。</li>
</ul>
<p>线程进入阻塞状态的原因：</p>
<ul>
<li>调用<code>sleep()</code>方法，线程休眠；</li>
<li>调用<code>wait()</code>方法，线程挂起，需要等待<code>notify()</code>或<code>notifyAll()</code>的消息通知；</li>
<li>等待I/O；</li>
<li>试图访问具有同步控制的内容，但是暂时没有获得相应的对象锁。</li>
</ul>
<h4 id="1-12-中断"><a href="#1-12-中断" class="headerlink" title="1.12 中断"></a>1.12 中断</h4><p>如果希望停止一个任务或杀死一个线程，可以中断它。</p>
<p>最好的方式是，使用执行器类Executors创建线程，然后在最后使用<code>Executors.shotdown()</code> ，一次性地发送<code>intertupt()</code>给执行器对象创建的所有线程，由此关闭由其创建的所有线程。</p>
<p>如果希望<strong>关闭单一线程</strong>，那么在线程启动的时候，不使用<code>Executors.execute()</code> ，而是选择<code>Executors.submit()</code> ，该方法将会返回一个泛型Future&lt;?&gt;，然后在需要关闭的时候，使用之前获得的泛型对象<code>Future&lt;?&gt;.cancel()</code> ，中断任务。</p>
<p>其中，<strong>I/O和synchronized同步控制块的阻塞是不可中断</strong>的（所以这两者都不需要任何的InterruptedException处理器），但是可以利用<strong>关闭其底层资源</strong>的方式，强行中断任务。</p>
<p>可以通过<code>Thread.interrupted()</code> 检测当前线程是否被中断，即<code>interrupt()</code> 是否被调用了，同时将中断状态清除。</p>
<h3 id="2-共享有限资源"><a href="#2-共享有限资源" class="headerlink" title="2 共享有限资源"></a>2 共享有限资源</h3><blockquote>
<p>你永远不知道一个线程何时在运行，也不知道一个资源是不是正在被占有。</p>
</blockquote>
<p>基本上所有的并发模式在解决线程访问共享资源的冲突问题时，都是采用<strong>序列化共享资源的</strong>方案——意味着在给定时刻只允许一个任务访问共享资源。一般使用<strong>锁语句</strong>产生一种互相排斥的效果——即<strong>互斥量</strong>的机制。</p>
<h4 id="2-1-synchronized"><a href="#2-1-synchronized" class="headerlink" title="2.1 synchronized"></a>2.1 synchronized</h4><p>关键字synchronized将会提供<strong>最基本但也是最通用</strong>的线程同步机制，防止访问共享资源时的线程冲突。</p>
<p>当任务要执行被synchronized修饰的代码片段的时候，将首先检查该片段的锁是否可用，然后获取锁，执行代码，最后将该片段的锁释放，以供其他任务使用。</p>
<p><strong>共享资源的访问控制</strong>：</p>
<ul>
<li>首先，需要将其包装进一个对象，并将其声明为<strong>private</strong> （使其只能通过类方法访问）；</li>
<li>其次，将<strong>所有可能访问</strong>该资源的方法用synchronized修饰（<strong>Brains同步规则</strong>）。</li>
</ul>
<p><strong>所有对象都自动含有单一的锁（也成为监视器）。</strong></p>
<p>当在对象上调用<strong>其</strong>任意synchronized修饰的方法的时候，此对象都会被加锁，<strong>对象所有的synchronized方法共享同一个锁</strong>，只有当该对象的锁被释放之后，其他的synchronized方法才能调用该对象。</p>
<p><strong>每一个类也有一个锁</strong>——使用<strong>synchronized static</strong>修饰的方法可以在类的范围防止对<strong>static数据</strong>的并发访问。</p>
<h4 id="2-2-显式Lock对象"><a href="#2-2-显式Lock对象" class="headerlink" title="2.2 显式Lock对象"></a>2.2 显式Lock对象</h4><p><code>java.util.concurrent.locks</code> 提供了显式的互斥机制——Lock对象必须显式地创建、锁定和释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private Lock lock = new ReentrantLock();</div><div class="line">...</div><div class="line">lock.lock(); // 尝试获取锁，会一直阻塞直到拿到</div><div class="line">// lock.tryLock(); //尝试获取锁，一段时间还拿不到就放弃</div><div class="line">// 需要同步的部分</div><div class="line">lock.unlock();</div></pre></td></tr></table></figure>
<p>通常只有在解决特殊问题的时候，才会使用显式的Lock对象，一般都使用synchronized关键字，比如，追求更细粒度的控制，显式Lock对象在加锁和释放锁方面，粒度更细，这在实现专用同步结构上很有用，可用于锁耦合等功能。</p>
<h4 id="2-3-临界区"><a href="#2-3-临界区" class="headerlink" title="2.3 临界区"></a>2.3 临界区</h4><p>很多情况下，只是希望防止多个线程同时访问方法内部的<strong>部分</strong>代码，而不是防止访问整个方法。因此，将<strong>需要设置同步机制的代码段分离出来，称为临界区</strong>。</p>
<p>临界区可以使用synchronized修饰——<strong>同步控制块</strong>，同步控制块的synchronized用于指定某个对象，此<strong>对象的锁用来对花括号内的代码进行同步控制</strong> （要进入临界区，必须获取同步控制块对象的锁）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">synchronized(syncObj) &#123;</div><div class="line">  	// 同步控制块中的代码内容，只有拥有syncObj对象的锁的任务才能访问和调用</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同步控制块，可以使多个任务访问对象的时间性能得到明显提高。</p>
<p>同步控制块必须给定一个在其上进行同步的对象，其中最合理的方式是使用正在调用该方法的对象，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">synchronized(this) &#123; // ... &#125;</div></pre></td></tr></table></figure>
<p>如果在this上进行同步，临界区将会直接缩小在同步的范围内，即<strong>修改的临界区只是正在同步的对象的临界区</strong> ，也就是意味着，可以将this换成其他的对象，那么当使用同步控制块的时候，修改的临界区将会是其他对象的临界区（？）。</p>
<p>两个任务可以同时进入同一个对象，只要这个<strong>对象上的方法是在不同的锁上同步</strong>即可。</p>
<h4 id="2-4-线程本地存储"><a href="#2-4-线程本地存储" class="headerlink" title="2.4 线程本地存储"></a>2.4 线程本地存储</h4><p>除了加锁之外，避免在共享资源上产生冲突的方式还有<strong>根除对变量的共享</strong>——线程本地存储。</p>
<p>线程本地存储是一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储，该机制可以将状态和线程关联起来。</p>
<p><code>java.lang.ThreadLocal</code>类负责创建和管理线程本地存储。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private static ThreadLocal&lt;Integer&gt; value = new ThreadLocal&lt;Integer&gt;() &#123;&#125;</div></pre></td></tr></table></figure>
<p>利用ThreadLocal对象当作静态域存储。<strong>ThreadLocal保证不会出现竞争条件</strong>。</p>
<p>每个线程都会分配自己的存储，维护和跟踪ThreadLocal对象。</p>
<h4 id="2-5-死锁"><a href="#2-5-死锁" class="headerlink" title="2.5 死锁"></a>2.5 死锁</h4><p>死锁，即任务之间相互等待的连续循环，谁都得不到锁，谁都处于阻塞状态。</p>
<p>防止死锁，在于程序设计的仔细。</p>
<p><strong>死锁的四个条件</strong>（只有同时满足，才会死锁，也就意味着，破坏任意一个条件，就可以避免死锁）：</p>
<ul>
<li>互斥条件，任务使用的资源中至少有一个是不能共享的，才会在同时访问时出现冲突；</li>
<li>至少有一个任务必须先持有一个资源，然后正在等待获取另一个资源，而这个资源当前正被其他任务所持有；</li>
<li>资源不能被任务抢占，即任务都会按照顺序，“礼貌”地释放和获取资源；</li>
<li>必须有循环等待。</li>
</ul>
<h4 id="2-6-内置同步的类库"><a href="#2-6-内置同步的类库" class="headerlink" title="2.6 内置同步的类库"></a>2.6 内置同步的类库</h4><h5 id="2-6-1-CountDownLatch"><a href="#2-6-1-CountDownLatch" class="headerlink" title="2.6.1 CountDownLatch"></a>2.6.1 CountDownLatch</h5><p>同步一个或者多个任务，强制先完成的任务等待其他任务的完成。</p>
<p>最初，需要给CountDownLatch对象设置一个计数值，任何在CountDownLatch对象上调用<code>await()</code> 方法都会阻塞，直至计数值减至0，任何任务都可以在完成任务后通过CountDownLatch对象调用方法<code>countDown()</code> 减少计数值。</p>
<p>需要同步的任务，需要使用同一个CountDownLatch对象，同一个CountDownLatch对象的计数值只能被<strong>初始化一次</strong> （希望重置计数器的，可以使用CylicBarrier）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CountDownLatch latch = new CountDownLatch(SIZE);</div><div class="line">...</div><div class="line">latch.countDown();</div><div class="line">...</div><div class="line">latch.await();</div></pre></td></tr></table></figure>
<h5 id="2-6-2-CylicBarrier"><a href="#2-6-2-CylicBarrier" class="headerlink" title="2.6.2 CylicBarrier"></a>2.6.2 CylicBarrier</h5><p>与CountDownLatch的功能相同——一组任务并行工作，先完成的任务需要等待其他任务完成之后，才能继续一起前进。</p>
<p>只不过CountDownLatch只能触发一次事件（同一个CountDownLatch对象的计数值只能初始化一次），而CylicBarrier可以多次重用（可以重置计数值）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">class Task implements Runnable &#123;</div><div class="line">  	//...</div><div class="line">  	private static CylicBarrier barrier;</div><div class="line">  	public void run() &#123; </div><div class="line">  		// 每个任务需要完成的工作</div><div class="line">  		barrier.await(); // 在所有其他任务完成之前，挂起当前任务</div><div class="line">  	&#125;</div><div class="line">&#125;</div><div class="line">public class TaskBarrier &#123;</div><div class="line">	private CylicBarrier barrier;</div><div class="line">	private List&lt;Task&gt; tasks = new ArrayList&lt;Task&gt;();</div><div class="line">	private ExecutorService exec = Executors.newCacheThreadPool();</div><div class="line">  	public TaskBarrier(int taskNum, int pause) &#123;</div><div class="line">      	barrier = new CylicBarrier(taskNum,new Runnable() &#123;</div><div class="line">          	public void run() &#123;</div><div class="line">              	// 栅栏的动作将定义在这里</div><div class="line">              	// ...</div><div class="line">              	// 同时，应该将栅栏动作的停止定义在这里，当满足相应条件时：</div><div class="line">              	exec.shutdown();</div><div class="line">              	return;</div><div class="line">          	&#125;</div><div class="line">      	&#125;);</div><div class="line">      	// 初始化、并启动所有任务</div><div class="line">      	// 如果所有任务都完成了，栅栏动作将会执行，并判断是否达到了最终的条件，如果不满足，会再次执行以下代码段（而CountDownLatch只能执行一次）</div><div class="line">      	for(int i = 0; i &lt; taskNum; i++) &#123;</div><div class="line">          	Task task = new Task(barrier);</div><div class="line">          	tasks.add(task);</div><div class="line">          	exec.execute(task);</div><div class="line">      	&#125;</div><div class="line">  	&#125;</div><div class="line">  	public static void main(String[] args)&#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CylicBarrier中的Runnable接口<code>run()</code> 方法所定义的栅栏动作，将会在所有的任务都完成之后，<strong>自动执行</strong> ，之前所需要做的，就是在创建任务对象的时候，将CylicBarrier对象作为参数传入任务对象的构造器中。</p>
<h5 id="2-6-3-DelayQueue"><a href="#2-6-3-DelayQueue" class="headerlink" title="2.6.3 DelayQueue"></a>2.6.3 DelayQueue</h5><p><strong>DelayQueue = BlockingQueue + PriorityQueue + Delayed</strong></p>
<p>DelayQueue是一个无界的BlockingQueue，用于放置实现了<strong>Delayed接口</strong>的对象，利用延迟时间作为优先级比较的标准。队列中的对象只能在其到期时才能被取出队列。所以，DelayQueue是有序的：队列头对象的延迟到期时间最短，将会被最先处理。</p>
<p>既然是有序的，那么DelayQueue就需要提供比较的方法——实际上，Delayed接口继承了Comparable接口，所以在DelayQueue中需要实现<code>compareTo()</code> 方法，提供合适的比较方式。</p>
<h5 id="2-6-4-PriorityBlockingQueue"><a href="#2-6-4-PriorityBlockingQueue" class="headerlink" title="2.6.4 PriorityBlockingQueue"></a>2.6.4 PriorityBlockingQueue</h5><p>优先级阻塞队列，提供可阻塞的读取操作。</p>
<p>同样需要提供比较方式的实现。</p>
<h5 id="2-6-5-SchedualedThreadPoolExecutor"><a href="#2-6-5-SchedualedThreadPoolExecutor" class="headerlink" title="2.6.5 SchedualedThreadPoolExecutor"></a>2.6.5 SchedualedThreadPoolExecutor</h5><p>提供让任务在特定时间运行的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 创建线程池</div><div class="line">SchedualedThreadPoolExecutor s = new SchedualedThreadPoolExecutor(SIZE);</div><div class="line">// 只在特定时间运行一次</div><div class="line">s.schedual(Runnable r, long delay, TimeUnit.MILLISECONDS);</div><div class="line">// 周期性运行</div><div class="line">s.schedualAtFixedRate(Runnable r, long delay, long period, TimeUnit.MILLISECONDS);</div></pre></td></tr></table></figure>
<h5 id="2-6-6-Semaphore"><a href="#2-6-6-Semaphore" class="headerlink" title="2.6.6 Semaphore"></a>2.6.6 Semaphore</h5><p>即信号量，允许n个任务同时访问同一资源，而锁机制在某个时刻只允许一个任务访问同一资源。</p>
<p>此外，信号量还可以看作是在向外分发资源使用的“许可证”（尽管根本不存在“许可证”），拥有“许可证”就可以访问资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private Semaphore access = new Semaphore(int size, boolean flag); // flag = true，表示使用Semaphore</div><div class="line">// 获取信号量的许可证</div><div class="line">access.acquire();</div><div class="line">// 释放信号量的许可证</div><div class="line">access.release();</div></pre></td></tr></table></figure>
<h5 id="2-6-7-Exchanger"><a href="#2-6-7-Exchanger" class="headerlink" title="2.6.7 Exchanger"></a>2.6.7 Exchanger</h5><p><strong>两个任务之间交换对象的栅栏</strong> ：当两个任务进入栅栏的时候，它们各自拥有一个对象，然后它们相互交换所持有的对象，最后他们各自离开。</p>
<p>应用场景为：一个任务在创建对象，对象的生产代价很高，另一个对象在消耗对象，于是<strong>希望在对象创建的同时将其直接消耗掉</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private Exchanger&lt;List&lt;T&gt;&gt; exchanger;</div><div class="line">// 需要双方使用相同的Exchanger对象，调用exchange()方法，才能实现对象的交换</div><div class="line">exchanger.exchange(producerHolder);</div><div class="line">exchanger.exchange(ConsumerHolder);</div></pre></td></tr></table></figure>
<h3 id="3-线程协作"><a href="#3-线程协作" class="headerlink" title="3 线程协作"></a>3 线程协作</h3><p>加锁提供的互斥量，可以实现多任务对共享资源的同时访问。而要想让多任务可以一起解决某个问题，则需要线程之间的协作。</p>
<p>线程协作，关键在于<strong>任务之间的握手</strong>。由于互斥机制确保只有一个任务可以响应某个信号，可以根除任何可能的竞争条件，所以线程协作首先要基于互斥机制，然后在之上，线程协作为任务添加了一种能力：<strong>在外界条件不满足的情况下，将自身暂时挂起，等待外界条件满足之后，由外界通知其继续执行</strong>。</p>
<p>综上，任务之间的握手，也即：<strong>Object（而不是Thread）的方法<code>wait()</code>和<code>notify()/notifyAll()</code></strong> 或<strong>Condition对象的 <code>await()</code>和<code>signal()/signalAll()</code></strong> （Conditon对象只在更加困难的多线程问题中才是必须的）。</p>
<h4 id="3-1-wait-与notify-notifyAll"><a href="#3-1-wait-与notify-notifyAll" class="headerlink" title="3.1 wait()与notify()/notifyAll()"></a>3.1 <code>wait()</code>与<code>notify()/notifyAll()</code></h4><p><code>wait()</code> 为当前任务提供了<strong>将自身挂起</strong>的能力，以等待外界某个条件变化以满足自身的要求，当外界条件满足之后，一般通过<strong>在其他任务的同步控制块中获取相应的对象的锁</strong>，然后调用<code>notify()/notifyAll()</code> 通知之前被挂起的任务，让其继续工作。</p>
<p><strong>调用<code>sleep()</code>和<code>yield()</code> 的时候锁并没有释放。</strong></p>
<p><strong>调用<code>wait()</code> ，线程的执行被挂起，同时对象的锁被释放。</strong> 允许该对象的其他synchronized方法在此期间被调用，以生成被挂起线程所需的条件（即在<code>wait()</code> 释放锁之后，需要有人获取所释放的锁，然后完成相应的任务，否则挂起的任务将永远不会被唤醒）。</p>
<p><strong>只能在同步控制方法或同步控制块中调用<code>wait()</code>与<code>notify()/notifyAll()</code></strong> ，因为这些方法之间的消息机制要求在调用这些方法的时候拥有（获取）对象的锁。</p>
<p>特定条件的检测，一般会放在<code>while</code> 循环中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">synchronized(obj) &#123; // obj 常用 this 代替</div><div class="line">  	while(condition) &#123;</div><div class="line">      	obj.wait(); // 或者直接写 wait()</div><div class="line">  	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>本质即，检查所感兴趣的特定条件，在条件不满足的情况下返回到<code>wait()</code> 中。将条件的检测包裹在<code>while</code>中，并放进 同步控制块中，这样每一个启动的线程就会不断检测特定条件，<strong>避免信号的错失</strong>。</p>
<p>如果希望使用同一时刻只能唤醒一个任务的方法<code>notify()</code> 时，必须保证唤醒特定的任务——<strong>一般会获取被挂起任务的对象，然后用该对象调用<code>notify()</code></strong> 。</p>
<p>由于不知道有多少个任务被挂起了，它们可能都在等待相同的条件，所以最好在条件满足的时候，调用<code>notifyAll()</code>  方法，一次性摆平它们。如果想单独唤醒其中一个任务，也可以<strong>单独使用某个对象调用<code>notifyAll()</code> 方法</strong> ，就可以单独之前释放该对象的锁的任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">synchronized(obj) &#123;</div><div class="line">  	obj.notifyAll(); // 将单独唤醒 传入对象obj 对应的挂起任务</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-2-生产者与消费者"><a href="#3-2-生产者与消费者" class="headerlink" title="3.2 生产者与消费者"></a>3.2 生产者与消费者</h4><p>生产者与消费者模型是多线程中很重要的模型，贯穿多线程的线程分配与回收过程以及消息机制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">// 一个饭店，一个厨师和一个服务员，服务员必须等待厨师准备好菜品，厨师准备好时会通知服务员，服务员把菜品端走，再次等待下一道菜品</div><div class="line">// 即厨师是生产者，服务员是消费者，菜品是他们之间交互的信息</div><div class="line">class Meal &#123;</div><div class="line">  	private final int orderNum;</div><div class="line">  	public Meal(int num) &#123; orderNum = num; &#125;</div><div class="line">  	public String toString() &#123; return &quot;Meal&quot; + orderNum; &#125;</div><div class="line">&#125;</div><div class="line">// Consumer</div><div class="line">class Waiter implements Runnable &#123;</div><div class="line">  	private Restaurant restaurant;</div><div class="line">  	public Waiter(Restaurant r) &#123; restaurant = r; &#125;</div><div class="line">  	public void run() &#123;</div><div class="line">    	try&#123;</div><div class="line">          	while(!Thread.interrupted()) &#123;</div><div class="line">          		synchronized(this) &#123;</div><div class="line">              		while(restaurant.meal == null) &#123;</div><div class="line">                  		wait(); // 等待厨师将菜品做好</div><div class="line">              		&#125;</div><div class="line">              		// 线程将会在上面的 wait() 挂起，直到条件满足（菜品做好并通知），才能继续执行以下代码</div><div class="line">              		System.out.println(&quot;Waiter got meal: &quot; + restaurant.meal);</div><div class="line">              		synchronized(restaurant.chef) &#123;</div><div class="line">                  		restaurant.meal = null;</div><div class="line">                  		restaurant.chef.notifyAll(); // 通知厨师，菜品已经端走，可以准备下一道菜了</div><div class="line">              		&#125;</div><div class="line">          		&#125;</div><div class="line">    		&#125;</div><div class="line">    	&#125;</div><div class="line">    	catch(InterruptedException e) &#123; System.out.print(&quot;Interrupted!&quot;); &#125;</div><div class="line">  	&#125;</div><div class="line">&#125; </div><div class="line">// Producer</div><div class="line">class Chef implements Runnable &#123;</div><div class="line">  	private Restaurant restaurant;</div><div class="line">  	private int count = 0;</div><div class="line">  	public Chef(Restaurant r) &#123; restaurant = r; &#125;</div><div class="line">  	public void run() &#123;</div><div class="line">      	try&#123;</div><div class="line">          	while(!Thread.interrupted()) &#123;</div><div class="line">              	synchronized(restaurant.chef) &#123;</div><div class="line">                  	while(restaurant.meal != null) &#123;</div><div class="line">                      	wait(); // 说明上一道菜还没上，那就不做下一道菜</div><div class="line">                  	&#125;</div><div class="line">              	&#125;</div><div class="line">              	// 除非wait()等到了相应的条件，否则保持挂起，不执行下面的代码</div><div class="line">                if(++count == 10) &#123;</div><div class="line">                	System.out.println(&quot;Time for resting...&quot;);</div><div class="line">                	restaurant.exec.shutdown();</div><div class="line">                &#125;</div><div class="line">                System.out.println(&quot;New Meal is ready!&quot;);</div><div class="line">                synchronized(restaurant.waiter) &#123;</div><div class="line">                	restaurant.meal = new Meal(count);</div><div class="line">                	restaurant.waiter.notifyAll();</div><div class="line">                &#125;</div><div class="line">                //TimeUnit.MILLISECONDS.sleep(1000);</div><div class="line">          	&#125;</div><div class="line">      	&#125;</div><div class="line">      	catch(InterruptedException e) &#123; System.out.println(&quot;Interrupted!&quot;); &#125;</div><div class="line">  	&#125;</div><div class="line">&#125; </div><div class="line"></div><div class="line">public class Restaurant &#123;</div><div class="line">  	// 在Restaurant中声明 Meal Waiter Chef，这样Restaurant对象就可以调用这些对象，访问他们的方法和状态</div><div class="line">  	Meal meal;</div><div class="line">  	Waiter waiter = new Waiter(this); // 用this作为参数，即将当前的Restaurant对象作为参数传给 Waiter 和 Chef，之后就可以使用 resraurant.waiter 调用</div><div class="line">  	Chef chef = new Chef(this);</div><div class="line">  	ExecutorService exec = Executors.newCacheThreadPool();</div><div class="line">  	public Restaurant() &#123;</div><div class="line">      	exec.execute(waiter);</div><div class="line">      	exec.execute(chef);</div><div class="line">  	&#125;</div><div class="line">  	public static void main(String[] args) &#123;</div><div class="line">      	new Restaurant();</div><div class="line">  	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>需要将同步控制块放在try语句中，以便出现异常可以抛出，在深入一点可以实现Thread.UncaughtExceptionHandler接口，提供自定义的异常捕获机制；</li>
<li>这只是个简单的生产者消费者模型，具体更复杂的模型最好使用<strong>先进先出队列</strong>实现。</li>
</ul>
<h4 id="3-3-同步队列"><a href="#3-3-同步队列" class="headerlink" title="3.3 同步队列"></a>3.3 同步队列</h4><p><code>java.util.concurrent.BlockingQueue</code> 中提供了同步队列的实现，包括<strong>LinkedBlockingQueue（无界队列）</strong> 、<strong>ArrayBlockingQueue（固定尺寸）</strong> 以及<strong>SynchronousdQueue</strong>。</p>
<p>使用了同步队列对任务进行存储、排队和取出，就可以忽略同步问题（不使用synchronized或者Lock对象）。</p>
<h4 id="3-4-线程与管道"><a href="#3-4-线程与管道" class="headerlink" title="3.4 线程与管道"></a>3.4 线程与管道</h4><p>Java以“管道”的形式，为线程之间的I/O提供了支持——<strong>PipedWriter类（允许任务向管道写）</strong>、<strong>PipedReader类（允许不同的任务从同一管道中读）</strong>。</p>
<p><strong>管道本质上就是一个阻塞队列。</strong></p>
<p>PipedReader的建立必须在其构造器中与一个PipedWriter相关联，当管道中没有数据时，读取操作将会阻塞，同时PipedReader是可中断的（而标准I/O是不能中断的）。</p>
<h3 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h3><h4 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1 进程与线程"></a>1 进程与线程</h4><p>进程是实现并发最直接的方式——操作系统级别。进程是运行在进程自身的地址空间内的<strong>自包容</strong>程序，多任务操作系统可以通过周期性地将CPU从一个进程切换到另一个进程，实现同时运行多个进程（程序），操作系统可以将进程之间相互隔离，即<strong>进程之间不共享资源、不相互干涉</strong>。</p>
<p>线程则是在由执行程序表示的单一进程中创建的任务（可以理解为在进程中创建多个线程），<strong>线程机制的好处：操作系统的透明性</strong>，即不依赖与操作系统底层的具体实现，所编写的多线程并发程序可以运行在不同的操作系统上。但是，线程实现的并发需要共享一个进程所提供的资源，包括内存、IO等，所以多线程并发编程中，最基本的挑战在于如何协调不同线程所驱动的任务之间的<strong>资源共享问题</strong>，避免同一资源在同一时刻被多个任务访问。</p>
<p>由于彼此之间的独立性，进程之间没有通信的需要，操作系统将会处理文件的细节。但是，进程的使用却有数量和开销的限制，以确保基于进程的并发系统的可应用性，毕竟进程与操作系统相关。</p>
<h4 id="2-休眠"><a href="#2-休眠" class="headerlink" title="2 休眠"></a>2 休眠</h4><p><code>java.util.concurrent.TimeUnit</code> 类提供了多线程中常用的<strong>延时</strong>和<strong>时间颗粒度转换</strong>的实用方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">TimeUnit.MILLISECONDS.sleep(10000);</div><div class="line">/*</div><div class="line">TimeUnit.DAYS          //天</div><div class="line">TimeUnit.HOURS         //小时</div><div class="line">TimeUnit.MINUTES       //分钟</div><div class="line">TimeUnit.SECONDS       //秒</div><div class="line">TimeUnit.MILLISECONDS  //毫秒</div><div class="line">*/</div></pre></td></tr></table></figure>
<h4 id="3-join"><a href="#3-join" class="headerlink" title="3 join()"></a>3 <code>join()</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Sleeper extends Thread &#123;</div><div class="line">  public void run()&#123;&#125;</div><div class="line">&#125;</div><div class="line">class Joiner extends Thread &#123;</div><div class="line">  private Sleeper sleeper;</div><div class="line">  public void run() &#123;</div><div class="line">    sleeper.join(); // Joiner线程将会被暂时挂起，直到Sleeper线程完成任务，才会轮到Joiner线程</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-原子性和可视性"><a href="#4-原子性和可视性" class="headerlink" title="4 原子性和可视性"></a>4 原子性和可视性</h4><ul>
<li>原子性</li>
</ul>
<p><strong>“原子操作不需要进行同步控制”，这是错误的。</strong></p>
<p>虽然<strong>原子操作是不能被线程调度机制中断的操作</strong>，但是由于JVM机制的问题，可能会出现“字撕裂”的情况（特别是对long/double类型数据的读写情况），造成数据不一致。</p>
<ul>
<li>可视性</li>
</ul>
<p>一个任务做出的修改，即使在不中断的意义上是原子性的，但对其他任务可能是不可视的，即<strong>不同的任务对应用的状态拥有不同的视图</strong>。</p>
<p>在处理器系统中，同步机制强制一个任务做出的修改必须在应用中是可视的，即<strong>同步机制保证了可视性</strong>，从而保证了数据的一致性。</p>
<p>此外，<strong>volatile</strong> 关键字也可以保证可视性，即若一个域用volatile修饰，则只要对该域产生写操作，那么所有的读操作都可以看到该修改。即使一个任务的修改暂存在本地缓存中，<strong>volatile域也会立即写入主存中</strong>（读操作将会访问主存）。</p>
<p>综上：</p>
<ul>
<li>在非volatile域中的原子操作不会立刻刷新到主存中，因此其他读取该域的任务也不会看到新修改的值，但是<strong>对于本任务来说，任何修改都是实时可视的</strong>；</li>
<li>若希望多个任务能够同时读取到某个域修改后的值，那么这个域需要使用volatile修饰；</li>
<li>如果不使用volatile修饰，也可以使用同步机制（比如synchronized）实现可视性，但是<strong>同步机制与volatile不能同时使用</strong>；</li>
<li>使用volatile唯一安全的情况是，类中仅有一个可变的域，而且该域的值不依赖于它之前的值（比如递增就会产生依赖）；</li>
<li>同步机制优先选择，除非很熟练；</li>
<li>volatile修饰的域，可以告知编译器对该域不进行优化。</li>
</ul>
<h4 id="5-原子类"><a href="#5-原子类" class="headerlink" title="5 原子类"></a>5 原子类</h4><p><code>java.util.concurrent.atomic</code>中，具有AtomicInteger、AtomicLong、AtomicReference等特殊的原子变量类，在涉及优化时比较有用。</p>
<h4 id="6-免锁容器"><a href="#6-免锁容器" class="headerlink" title="6 免锁容器"></a>6 免锁容器</h4><p>即对容器的修改可以与读取操作同时发生，只要<strong>读取者只能看到完成修改的结果</strong>即可。</p>
<p>所以，免锁容器将会为修改内容提供一个副本，这个副本在修改完成之前是不可视的，只有修改完成之后才会自动地并入原内容中。所以，读取操作获得的实际上是原内容（不包括正在修改的副本内容），也因此，读取的内容可能不是实时的修改结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CopyOnWriteArrayList</div><div class="line">CopyOnWriteArraySet</div><div class="line">ConcurrentHashMap</div><div class="line">ConcurrentLinkedQueue</div></pre></td></tr></table></figure>
<h4 id="7-活动对象"><a href="#7-活动对象" class="headerlink" title="7 活动对象"></a>7 活动对象</h4><p>每个对象都将维护自己的工作器线程和消息队列，并且所有对活动对象的请求都将进入队列排队，任何时刻都只能运行其中的一个——为<strong>串行化消息</strong>提供了方法。</p>
<p>代理编程，也即对活动对象的编程。</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>