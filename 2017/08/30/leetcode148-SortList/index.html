<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>leetcode148 Sort List | StarSea</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- gallery that comes before the header--><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/DivideConquerAlgorithm/">DivideConquerAlgorithm</a><a class="post-tag-link" href="/tags/Recursion/">Recursion</a><a class="post-tag-link" href="/tags/SortAlgorithms/">SortAlgorithms</a><a class="post-tag-link" href="/tags/leetcode/">leetcode</a><a class="post-tag-link" href="/tags/linkedlist/">linkedlist</a></div><div class="post-time">2017-08-30</div></div></div><div class="container post-header"><h1>leetcode148 Sort List</h1></div><div class="container post-content"><h2 id="leetcode-148-Sort-List"><a href="#leetcode-148-Sort-List" class="headerlink" title="leetcode#148 Sort List"></a>leetcode#148 Sort List</h2><blockquote>
<p>Sort a linked list in <em>O</em>(<em>n</em> log <em>n</em>) time using constant space complexity.</p>
</blockquote>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>在空间复杂度O(1)、时间复杂度O(nlogn)的情况下，对链表进行排序。</p>
<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>面对这道题的时候，排序算法已经忘得差不多了……虽然上一道题写的是直接排序和插入排序，但是面对本题时间空间复杂度的要求，明显不能用这两种算法。</p>
<p>查阅排序算法的资料后，有以下结论：</p>
<ul>
<li>堆排序、快速排序、归并排序，时间复杂度都是O(nlogn)，空间复杂度依次是O(N)、O(1)、O(N)；</li>
<li>针对数组而言，归并排序的空间复杂度确实是O(N)，因为需要开辟O(N)的额外空间，用于有序数组的归并；</li>
<li>针对链表而言，不需要额外的O(N)空间，因为链表只需要改变<code>next</code> 指针的指向即可；</li>
<li>所以本题适合使用归并排序算法解决。</li>
</ul>
<h4 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h4><ul>
<li>首先，递归将链表按照二分法的方式，切分成单个节点—— 使用快慢指针<code>slow</code>和<code>fast</code> ；</li>
<li>然后，由单个节点开始，进行归并——归并的内部没有使用递归的方式，只是简单的比较和修改指针指向；</li>
<li>最后，将归并的结果返回给上一层的递归，从而进行更大的归并。</li>
</ul>
<p>看LeetCode很多人评价这种解法并不是空间复杂度O(1)的解法，原因在于：</p>
<ul>
<li>递归本身需要存储关于递归的信息，不可能达到空间复杂度O(1)；</li>
<li>归并方法中： <code>ListNode faker = new ListNode(0);</code> 创建了新的节点。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * public class ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode next;</div><div class="line"> *     ListNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">    public ListNode sortList(ListNode head) &#123;</div><div class="line">        if(head == null || head.next == null) return head;</div><div class="line">        </div><div class="line">        ListNode pre = null;</div><div class="line">        ListNode slow = head;</div><div class="line">        ListNode fast = head;</div><div class="line">        </div><div class="line">        while(fast != null &amp;&amp; fast.next != null) &#123;</div><div class="line">            pre = slow;</div><div class="line">            slow = slow.next;</div><div class="line">            fast = fast.next.next;</div><div class="line">        &#125;</div><div class="line">        pre.next = null;</div><div class="line">        // Recursion</div><div class="line">        ListNode list1 = sortList(head);</div><div class="line">        ListNode list2 = sortList(slow);</div><div class="line">        // return the result of merge</div><div class="line">        return merge(list1,list2);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static ListNode merge(ListNode list1, ListNode list2) &#123;</div><div class="line">        ListNode faker = new ListNode(0);</div><div class="line">        ListNode mov = faker;</div><div class="line">        while(list1 != null &amp;&amp; list2 != null) &#123;</div><div class="line">            if(list1.val &lt;= list2.val) &#123;</div><div class="line">                mov.next = list1;</div><div class="line">                list1 = list1.next;</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                mov.next = list2;</div><div class="line">                list2 = list2.next;</div><div class="line">            &#125;</div><div class="line">            mov = mov.next;</div><div class="line">        &#125;</div><div class="line">        if(list1 == null) &#123;</div><div class="line">            mov.next = list2;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            mov.next = list1;</div><div class="line">        &#125;</div><div class="line">        return faker.next;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="大神解法"><a href="#大神解法" class="headerlink" title="大神解法"></a>大神解法</h4><p>递归的方法大同小异，这里介绍一个自底向上的非递归方法——据说真正达到了题目的要求（O(1)空间，O(nlogn)时间）。</p>
<p><strong>可我暂时没看懂？先贴上来慢慢看</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    ListNode dummyRes = new ListNode(0);</div><div class="line">    public class MergeResult &#123;</div><div class="line">        ListNode head;</div><div class="line">        ListNode tail;</div><div class="line">        </div><div class="line">        MergeResult(ListNode h, ListNode t) &#123; head = h; tail = t;&#125;</div><div class="line">    &#125; </div><div class="line">    </div><div class="line">    public ListNode sortList(ListNode head) &#123;</div><div class="line">        if(head == null || head.next == null) return head;</div><div class="line">        </div><div class="line">        int length = length(head);</div><div class="line">        </div><div class="line">        ListNode dummy = new ListNode(0);</div><div class="line">        dummy.next = head;</div><div class="line">        MergeResult mr = new MergeResult(null, null);</div><div class="line">        for(int step = 1; step &lt; length; step &lt;&lt;= 1) &#123;</div><div class="line">            ListNode left = dummy.next;</div><div class="line">            ListNode prev = dummy;</div><div class="line">            while(left != null) &#123;</div><div class="line">                ListNode right = split(left, step);</div><div class="line">                if(right == null) &#123;</div><div class="line">                    prev.next = left;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                ListNode next = split(right, step);</div><div class="line">                merge(left, right, mr);</div><div class="line">                prev.next = mr.head;</div><div class="line">                prev = mr.tail;</div><div class="line">                left = next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        return dummy.next;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public ListNode split(ListNode head, int step) &#123;</div><div class="line">        while(head != null &amp;&amp; step != 1) &#123;</div><div class="line">            head = head.next;</div><div class="line">            step--;</div><div class="line">        &#125;</div><div class="line">        if(head == null) return null;</div><div class="line">        ListNode res = head.next;</div><div class="line">        head.next = null;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public int length(ListNode head) &#123;</div><div class="line">        int len = 0;</div><div class="line">        while(head != null) &#123;</div><div class="line">            head = head.next;</div><div class="line">            len++;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        return len;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void merge(ListNode head1, ListNode head2, MergeResult mr) &#123;</div><div class="line">        if(head2 == null) &#123;</div><div class="line">            mr.head = head1;</div><div class="line">            mr.tail = null;</div><div class="line">        &#125;</div><div class="line">        ListNode res = dummyRes;</div><div class="line">        ListNode tail = res;</div><div class="line">        while(head1 != null &amp;&amp; head2 != null) &#123;</div><div class="line">            if(head1.val &lt; head2.val) &#123;</div><div class="line">                tail.next = head1;</div><div class="line">                head1 = head1.next;</div><div class="line">            &#125;else&#123;</div><div class="line">                tail.next = head2;</div><div class="line">                head2 = head2.next;</div><div class="line">            &#125;</div><div class="line">            tail = tail.next;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        while(head1 != null) &#123;</div><div class="line">            tail.next = head1;</div><div class="line">            head1 = head1.next;</div><div class="line">            tail = tail.next;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        while(head2 != null) &#123;</div><div class="line">            tail.next = head2;</div><div class="line">            head2 = head2.next;</div><div class="line">            tail = tail.next;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        mr.head = res.next;</div><div class="line">        mr.tail = tail;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>综上，可以发现，很多的排序算法在讨论复杂度的时候，往往都是针对数组，而且很多的排序算法都鼓励使用数组进行操作，而不是使用链表，可能是因为数组是效率最高的数据结构吧。</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>