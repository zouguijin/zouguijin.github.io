<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>leetcode35 Search Insert Position | StarSea</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- gallery that comes before the header--><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/BinarySearch/">BinarySearch</a><a class="post-tag-link" href="/tags/array/">array</a><a class="post-tag-link" href="/tags/leetcode/">leetcode</a></div><div class="post-time">2017-08-31</div></div></div><div class="container post-header"><h1>leetcode35 Search Insert Position</h1></div><div class="container post-content"><h2 id="leetcode-35-Search-Insert-Position"><a href="#leetcode-35-Search-Insert-Position" class="headerlink" title="leetcode#35 Search Insert Position"></a>leetcode#35 Search Insert Position</h2><blockquote>
<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
<p>Here are few examples.<br>[1,3,5,6], 5 → 2<br>[1,3,5,6], 2 → 1<br>[1,3,5,6], 7 → 4<br>[1,3,5,6], 0 → 0</p>
</blockquote>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>给定一个有序数组和一个目标值，对数组进行查找，如果有目标值，则返回其索引；如果没有找到目标值，则返回目标值应该插入的位置索引。（假设数组中没有重复值）</p>
<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>本题关于数组的查找问题，第一感觉是使用<strong>二分法</strong>进行查找。</p>
<h4 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h4><p>二分法对数组进行搜索和查找。</p>
<p>中间位置的节点计算使用的是：<code>midPos = (end - begin)/2 + begin</code> </p>
<p>在边界判断的时候遇到了一点小麻烦，最后写成的方法虽然完成了功能，但是语句上有点冗余。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    public int searchInsert(int[] nums, int target) &#123;</div><div class="line">        int end = nums.length;</div><div class="line">        int begin = 0;</div><div class="line">        int midPos = 0;</div><div class="line">        </div><div class="line">        while(true) &#123;</div><div class="line">            midPos = (end - begin)/2 + begin;</div><div class="line">            if(nums[midPos] == target) return midPos;</div><div class="line">            else if(nums[midPos] &gt; target) &#123;</div><div class="line">                if((midPos - begin)/2 == 0) &#123;</div><div class="line">                    if(nums[begin] &lt; target) return midPos;</div><div class="line">                    else</div><div class="line">                        return begin;</div><div class="line">                &#125;</div><div class="line">                end = midPos;</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                if((end - midPos)/2 == 0) return end;</div><div class="line">                begin = midPos;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="大神解法"><a href="#大神解法" class="headerlink" title="大神解法"></a>大神解法</h4><p>学习一下大神们简洁的二分查找算法：</p>
<ul>
<li>中间位置的计算使用的是<strong>加法</strong> &amp;&amp; <code>high = A.length-1</code> ；</li>
<li>循环判定条件是<code>low &lt;= high</code> ，也即两个节点分别向对方移动；</li>
<li>如果一直没找到，那么直到循环判定条件失效时，返回<code>low</code> 所指位置索引。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public int searchInsert(int[] A, int target) &#123;</div><div class="line">       int low = 0, high = A.length-1;</div><div class="line">       while(low&lt;=high)&#123;</div><div class="line">           int mid = (low+high)/2;</div><div class="line">           if(A[mid] == target) return mid;</div><div class="line">           else if(A[mid] &gt; target) high = mid-1;</div><div class="line">           else low = mid+1;</div><div class="line">       &#125;</div><div class="line">       return low;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>中间位置的计算使用的是<strong>减法</strong> &amp;&amp; <code>high = nums.length</code> ；</li>
<li>循环判定条件是<code>low &lt; high</code> ，也即两个节点分别向对方移动，但与上述方式有细微的差别；</li>
<li>如果一直没找到，那么直到循环判定条件失效时，返回<code>low</code> 所指位置索引；</li>
<li><code>low + (high - low) / 2</code> ，可以让<code>low</code> 不断增加，也可以让<code>high</code> 不断下降，关键是在<code>low/high</code> 两个指针相邻的时候，<code>(high - low)/2 = 0</code> 能够让<code>high</code> 再次下降使得<code>high = low</code> ，从而跳出循环，返回<code>low</code> 所指位置的索引。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">public int searchInsert(int[] nums, int target) &#123;</div><div class="line">    int low = 0, high = nums.length;</div><div class="line">    while(low &lt; high) &#123;</div><div class="line">        int mid = low + (high - low) / 2;</div><div class="line">        if(nums[mid] &lt; target)</div><div class="line">            low = mid + 1;</div><div class="line">        else</div><div class="line">            high = mid;</div><div class="line">    &#125;</div><div class="line">    return low;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>边界问题真的是有关数组算法中的麻烦事儿！解决边界问题相当于解决了一大半的数组算法问题！</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>