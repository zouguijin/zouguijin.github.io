{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/noise/source/css/highlight.less","path":"css/highlight.less","modified":0,"renderable":1},{"_id":"themes/noise/source/css/normalize.css","path":"css/normalize.css","modified":0,"renderable":1},{"_id":"themes/noise/source/css/font.less","path":"css/font.less","modified":0,"renderable":1},{"_id":"themes/noise/source/css/noise.less","path":"css/noise.less","modified":0,"renderable":1}],"Cache":[{"_id":"themes/noise/README.md","hash":"f933e665385bafbee34f6ae95307e767bbe05b62","modified":1487581801893},{"_id":"themes/noise/.travis.yml","hash":"9195328ae9f1b8c5089f2c898e1b9bf019980164","modified":1487581801893},{"_id":"themes/noise/_config.yml","hash":"32d63000d3d8aa5711fe56f56299aeb4ed392ee3","modified":1487581945862},{"_id":"themes/noise/LICENSE","hash":"86c2c15a2d0c891e5c0912e31ff7a12ef694ce3f","modified":1487581801893},{"_id":"source/about/index.md","hash":"6e5b1d8ea8a8d2d48ba046046c37c48fab7d93d8","modified":1487919728545},{"_id":"source/_posts/firstTryonTypora.md","hash":"cf19be20c0056851b12868bb908c3ddbb2ebd901","modified":1488160214298},{"_id":"source/_posts/git-multiSync.md","hash":"aa36d57e7045c6951ea88210e59e3c5aac2d3436","modified":1491125210397},{"_id":"source/_posts/git-study.md","hash":"16a4cd0060e133b7f50fc3e1ff72250227aafab1","modified":1491125203894},{"_id":"source/_posts/hello-world.md","hash":"029f91fccbe8f87c0f3ea10c4042300d2fa7edc0","modified":1487581657362},{"_id":"themes/noise/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1487581801877},{"_id":"source/_posts/leetcode83-RemoveDuplicatesfromSortedList.md","hash":"cac4df92dfa3b4c70a9000ef24574c039b60d168","modified":1491125186172},{"_id":"themes/noise/.git/config","hash":"1bff9b6eaf288cbd3cca2c31c4e14b203f29d71d","modified":1487581801893},{"_id":"themes/noise/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1487581798183},{"_id":"themes/noise/.git/index","hash":"69b40f3448eed0f10056c3cceb62bf97092cce27","modified":1487919226017},{"_id":"themes/noise/.git/packed-refs","hash":"6c16071509a9073452c8999c0a63cc23a55d7b54","modified":1487581801877},{"_id":"themes/noise/layout/archive.jade","hash":"633384e3627380c91a7ed1f23a82a448cb4a6161","modified":1487581801893},{"_id":"themes/noise/layout/index.jade","hash":"cb0e954c2848a46618757c3c20e88ef49385df47","modified":1487581801893},{"_id":"themes/noise/layout/base.jade","hash":"8f075c5dfa7a380934bcae29875b9ae85751bcfa","modified":1487581801893},{"_id":"themes/noise/layout/page.jade","hash":"acf65a9f678a3b278a4ac20de8754bc9ab0c8f37","modified":1487581801893},{"_id":"themes/noise/layout/post.jade","hash":"64c91e9eda4ca9e77607cf253694e1a9a10c7383","modified":1487581801893},{"_id":"themes/noise/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1487581798183},{"_id":"themes/noise/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1487581798183},{"_id":"themes/noise/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1487581798183},{"_id":"themes/noise/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1487581798183},{"_id":"themes/noise/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1487581798183},{"_id":"themes/noise/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1487581798183},{"_id":"themes/noise/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1487581798183},{"_id":"themes/noise/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1487581798183},{"_id":"themes/noise/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1487581798183},{"_id":"themes/noise/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1487581798183},{"_id":"themes/noise/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1487581798183},{"_id":"themes/noise/.git/logs/HEAD","hash":"2d00eb247a7a649d40054fcdb5c8e10570db7ab4","modified":1487581801877},{"_id":"themes/noise/layout/_partial/helpers.jade","hash":"f87b4f41e2ddbd3db10fb2ebaa342954c4d8d9a0","modified":1487581801893},{"_id":"themes/noise/layout/_partial/comments.jade","hash":"f97607b36dafaa9ef3dc109d7b8393aef5cef19e","modified":1487581801893},{"_id":"themes/noise/layout/_partial/paginator.jade","hash":"484f0850cdc8d8a954c0ac7131ebfd067047c5e5","modified":1487581801893},{"_id":"themes/noise/source/css/_variables.less","hash":"488149b5a7c2953396b859074fa58e4d80dd0442","modified":1487581801893},{"_id":"themes/noise/source/css/highlight.less","hash":"6a00e35295f5b890a3a6daa6f6656af50d918721","modified":1487581801893},{"_id":"themes/noise/source/css/normalize.css","hash":"46844f2fc407f66636c6e783ddaeed2a684c2f8f","modified":1487581801893},{"_id":"themes/noise/source/css/font.less","hash":"ff469bbb929ad07d8fa9a8881129ea225adeeb73","modified":1487581801893},{"_id":"themes/noise/source/css/noise.less","hash":"c2bb7170d4b8f5b8e4956e5ffe8c4f1c4069c74a","modified":1487581801893},{"_id":"themes/noise/.git/objects/pack/pack-fdb83ccd805a304799dafda5e6e40c21b321adb2.idx","hash":"5e1ff6ccdda82473dccf8ce2f0652b179982d789","modified":1487581801768},{"_id":"themes/noise/.git/refs/heads/master","hash":"44343f89297925bc1cd6ea4b4c3da6f18a18179c","modified":1487581801877},{"_id":"themes/noise/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1487581801877},{"_id":"themes/noise/.git/logs/refs/heads/master","hash":"2d00eb247a7a649d40054fcdb5c8e10570db7ab4","modified":1487581801877},{"_id":"themes/noise/.git/logs/refs/remotes/origin/HEAD","hash":"2d00eb247a7a649d40054fcdb5c8e10570db7ab4","modified":1487581801877},{"_id":"themes/noise/.git/objects/pack/pack-fdb83ccd805a304799dafda5e6e40c21b321adb2.pack","hash":"b5b7654e1bfee65e8ccb56fb6d102d6936c3f787","modified":1487581801784},{"_id":"public/about/index.html","hash":"0970be7fe8212baff4783024c5f623205ab5e914","modified":1490925371945},{"_id":"public/2017/03/30/leetcode83-RemoveDuplicatesfromSortedList/index.html","hash":"e7f0f00d6245aedbbb43bdf7fb50887bcc59e05e","modified":1491033757214},{"_id":"public/2017/02/24/hello-world/index.html","hash":"7cee61b639fa59c48a0a0a96f185e33d6917ee19","modified":1490925371945},{"_id":"public/2017/02/17/firstTryonTypora/index.html","hash":"d5a77f24259cec88011e1bbdf698abd30ba41747","modified":1490925371945},{"_id":"public/archives/index.html","hash":"4c6740d07264716a9bf1244daee5db1ad0d3db93","modified":1491530428978},{"_id":"public/archives/2017/index.html","hash":"62863f55b873052da049d077746794c29440cc02","modified":1491530428978},{"_id":"public/archives/2017/02/index.html","hash":"c3adcede81f4301f5a14e90d0e49c435b2c370dd","modified":1491530428978},{"_id":"public/archives/2017/03/index.html","hash":"78dc10a8bf44d9bc66ce6f6b199f22d8e0738924","modified":1491530428978},{"_id":"public/tags/BlogTools/index.html","hash":"7e30b55dd4a76cb9caf53b9f14b8a8edc43c7e8c","modified":1490925371945},{"_id":"public/tags/Markdown/index.html","hash":"8de6d4cac76d0a3058fbcb39655af9dfdc91bd6f","modified":1490925371945},{"_id":"public/tags/Git/index.html","hash":"50d89f697bf09f209e133df3a3475bfe09936f71","modified":1490925371945},{"_id":"public/tags/Github/index.html","hash":"e2bd63e8573b8fb50ed36b384bddb02336355bd5","modified":1490925371945},{"_id":"public/tags/hexo/index.html","hash":"9afe863ea7da769d5e5e542f8c58d0573e97e09f","modified":1490925371945},{"_id":"public/tags/leetcode/index.html","hash":"d56932fc8ed9267b8121d87ffa3578a8cbf25815","modified":1491530428978},{"_id":"public/tags/linkedlist/index.html","hash":"7612cd47b65718a9daf9c444442e1c890e244fea","modified":1491530428978},{"_id":"public/tags/array/index.html","hash":"988f38615f9810f0a5e448598ecf8f923ce394d2","modified":1491033757214},{"_id":"public/tags/recursive-algorithm/index.html","hash":"19fcfaa254fdeb4d497c026d26b5acb91aaa259b","modified":1491033757214},{"_id":"public/categories/Study/index.html","hash":"4ced9683371ace7d4763a4d50a942c1fb1ce6ff1","modified":1491530428976},{"_id":"public/index.html","hash":"3f591da59f16b88ed1a49b3af3cd48f88b32e31f","modified":1491530428978},{"_id":"public/2017/02/26/git-multiSync/index.html","hash":"66eb1a90cacc799713d89e09a533db1435289f5f","modified":1490925371947},{"_id":"public/2017/02/24/git-study/index.html","hash":"ac7e570139d3639a13279458362682f5b9f872d6","modified":1490925371947},{"_id":"public/css/normalize.css","hash":"d0fbef3dd405f26a5fdc896ca1f7875901782c6f","modified":1490925371986},{"_id":"public/css/font.css","hash":"675361046170c7a4e8c11c774f64b3d1a631b900","modified":1490925371990},{"_id":"public/css/highlight.css","hash":"061dc4e4c8f818a08c7f23aab625345b2d677d5f","modified":1490925372024},{"_id":"public/css/noise.css","hash":"56092b4a16cfcdcad32c5b6136fd5cb3c14989df","modified":1490925372024},{"_id":"source/_posts/leetcode#83-RemoveDuplicatesfromSortedList.md","hash":"42626631565912ba60316b00c24a35fd7a316e11","modified":1490925331268},{"_id":"source/_posts/leetcode#82-RemoveDuplicatesfromSortedListII.md","hash":"1eff1930cd5a0dd5365fb2dea7c1b8fe1f0bfc57","modified":1491013480347},{"_id":"public/2017/04/01/leetcode#82-RemoveDuplicatesfromSortedListII/index.html","hash":"41c240c513b9cc2489044fd7239e769e4f4fb656","modified":1491032227566},{"_id":"public/2017/03/30/leetcode#83-RemoveDuplicatesfromSortedList/index.html","hash":"e7f0f00d6245aedbbb43bdf7fb50887bcc59e05e","modified":1491032227566},{"_id":"public/archives/2017/04/index.html","hash":"354ae697e6962b5235f9d4ed919a92993f4086a3","modified":1491530428978},{"_id":"public/tags/recursive-algorithms/index.html","hash":"6109aa04f2c0a45e7089cd355b80e88418a2dfa3","modified":1491032227566},{"_id":"source/_posts/leetcode82-RemoveDuplicatesfromSortedListII.md","hash":"2a0187dc1e5d38a807a9bab97a846ecbb6cb5ae0","modified":1491125194270},{"_id":"public/2017/04/01/leetcode82-RemoveDuplicatesfromSortedListII/index.html","hash":"51e25331392ba28f7694cbe275ded207d84cbfbb","modified":1491033757214},{"_id":"source/_posts/leetcode141-LinkedListCycle.md","hash":"22b18ac47c460c50cbdd54053c5c418db6fe4a8f","modified":1491125180486},{"_id":"public/2017/04/01/leetcode141-LinkedListCycle/index.html","hash":"61a47a4c8cc7b8a8d678e848fd5f620df4d5865f","modified":1491036012721},{"_id":"public/archives/page/2/index.html","hash":"15c9950d9837cfb294277235f8d7d6522d443999","modified":1491530428978},{"_id":"public/archives/2017/page/2/index.html","hash":"b622c5afb69fcad14180fee5c03fbba1397ea4ca","modified":1491530428978},{"_id":"public/page/2/index.html","hash":"d7f62706cf8dca84440b7780d2c563acb3bd60dd","modified":1491530428978},{"_id":"source/favicon16.ico","hash":"b15e6454115eb9cb8030870097b9e6cbfcca0da0","modified":1491037208277},{"_id":"public/favicon16.ico","hash":"b15e6454115eb9cb8030870097b9e6cbfcca0da0","modified":1491037279532},{"_id":"source/_posts/leetcode142-LinkedListCycleII.md","hash":"bfd164f7e80bdc81f49b0ba5a196432b7499df3e","modified":1491125158376},{"_id":"public/2017/04/02/leetcode142-LinkedListCycleII/index.html","hash":"f2844275dbdcde652d59b42e9bc0e7666b8995b6","modified":1491125316462},{"_id":"public/categories/Study/page/2/index.html","hash":"80fe73f6d689778529ab233f1d977114b3ee989a","modified":1491530428977},{"_id":"source/_posts/leetcode160-IntersectionofTwoLinkedLists.md","hash":"1e1ed42ed82c978016fcf4e97326a3e36e720aaf","modified":1491385438161},{"_id":"public/2017/04/05/leetcode160-IntersectionofTwoLinkedLists/index.html","hash":"ac6bccb0d6d4ee81344e6acd500eae3ba698a91a","modified":1491385531681},{"_id":"source/_posts/leetcode206-ReverseLinkedList.md","hash":"a1adf01e8992b2bb30cecaf30762f1b09b8cdd91","modified":1491491294871},{"_id":"public/2017/04/06/leetcode206-ReverseLinkedList/index.html","hash":"100dfff23d8444f0ad27a4cd38ee51af040f9ae8","modified":1491492718179},{"_id":"source/_posts/leetcode203-RemoveLinkedListElements.md","hash":"af75e2111b5550fdf73ad749ffaff3d2cb49db39","modified":1491530356566},{"_id":"public/2017/04/07/leetcode203-RemoveLinkedListElements/index.html","hash":"cd53556a85fa59b46bdebb1e5c5ef4539e0641cb","modified":1491530428979},{"_id":"public/tags/leetcode/page/2/index.html","hash":"2fe057b0610be5223dd3b115e0b1f55bb7fedf81","modified":1491530428979},{"_id":"public/tags/linkedlist/page/2/index.html","hash":"2e3e688612d4bf60b33f72c81c9b6f7c64024e48","modified":1491530428979}],"Category":[{"name":"Study","_id":"cj0x6gzdz0003kkupqhpeaqtr"}],"Data":[],"Page":[{"title":"About Me","catogeries":["AboutMe"],"tags":["Career","Life"],"_content":"\n\n\n# About Me\n\n- 对美的东西有一种完美主义的执念\n- 如果要做，就尽全力做到最好\n- 认真地选择一本好书或者一部好剧，安静地从头看到尾\n- 希望，平静，且明智\n- *未完，继续探索...*","source":"about/index.md","raw":"title: About Me\n\ncatogeries:\n\n- AboutMe\n\ntags:\n\n- Career\n- Life\n\n---\n\n\n\n# About Me\n\n- 对美的东西有一种完美主义的执念\n- 如果要做，就尽全力做到最好\n- 认真地选择一本好书或者一部好剧，安静地从头看到尾\n- 希望，平静，且明智\n- *未完，继续探索...*","date":"2017-02-24T07:11:17.859Z","updated":"2017-02-24T07:02:08.545Z","path":"about/index.html","comments":1,"layout":"page","_id":"cj0x6gzdw0001kkuptuoxkofa","content":"<h1 id=\"About-Me\"><a href=\"#About-Me\" class=\"headerlink\" title=\"About Me\"></a>About Me</h1><ul>\n<li>对美的东西有一种完美主义的执念</li>\n<li>如果要做，就尽全力做到最好</li>\n<li>认真地选择一本好书或者一部好剧，安静地从头看到尾</li>\n<li>希望，平静，且明智</li>\n<li><em>未完，继续探索…</em></li>\n</ul>\n","excerpt":"","more":"<h1 id=\"About-Me\"><a href=\"#About-Me\" class=\"headerlink\" title=\"About Me\"></a>About Me</h1><ul>\n<li>对美的东西有一种完美主义的执念</li>\n<li>如果要做，就尽全力做到最好</li>\n<li>认真地选择一本好书或者一部好剧，安静地从头看到尾</li>\n<li>希望，平静，且明智</li>\n<li><em>未完，继续探索…</em></li>\n</ul>\n"}],"Post":[{"title":"Typora——Markdown编辑界的极简主义","date":"2017-02-17T01:00:00.000Z","_content":"\n### Before Typora\n\n在Windows平台上，Typora之前，我还曾经接触过[MarkdownPad](http://www.markdownpad.com/)和[MarkPad](http://code52.org/DownmarkerWPF/)两款Markdown编辑工具。\n\nMarkdownPad和MarkPad的特点：\n\n- 都支持Markdown的所有语法，可以实现不动用鼠标就完成一篇排版精美文章的书写；\n- 二者提供的都是两屏对照的实时渲染系统，即用户在左侧屏敲入带有Markdown语法的文字，在右侧屏会实时显示相应的HTML预览效果。\n- 所生成的Markdown文件可以直接用于个人博客以及上传至Github，支持程度好。\n\n不过，MarkdownPad和MarkPad仍有些许不同：\n\n- MarkdownPad的实时渲染采用的是[Awesomium](http://www.awesomium.com/)，简单来说，Awesomium是一个HTML网页UI界面的渲染引擎，适用于基于C++或者.NET的应用程序。个人觉得，Awesomium对于一个Markdown编辑器来说，功能过于强大，以至于使得MarkdownPad的运行比较吃内存，有悖于Markdown轻量级编辑器的定位，同时在Windows10操作系统下实际使用的时候发现，内嵌于MarkdownPad中的Awesomium经常崩溃，出现无法渲染的情况，需要手动下载Awesomium SDK进行修复（据说安装SDK之后就可以修复，但是我没成功...）。\n- MarkPad的渲染使用的是[JekyII](http://jekyll.com.cn/) ，一个基于Ruby语言的静态网页和网站生成工具。同时，JekyII还可以和Github结合，搭建一个免费静态博客。\n- 此外，在外观和易用性上，MarkdownPad显得比较老气，风格与MS Office比较类似，常用标记功能的图标都列在菜单栏中，较为容易上手使用，MarkPad则较为有科技感，界面简洁，但是由于没有相应的常用功能列表，所以使用起来还需要经过一段时间的锻炼，适合已经熟悉Markdown语法的用户。\n\n### Typora\n\nTypora是也是一款本地的、所写即可见的Markdown编辑器。与上述两种Markdown编辑器一样，Typora支持相同的Markdown语法，也是一款可以不用鼠标操作的编辑器，所写的Markdown文件也可以直接用于博客静态网页的生成。\n\n相比于MarkdownPad和MarkPad，Typora具有以下特点：\n\n- 当前屏幕的实时渲染。Typora不再使用Preview窗口预览渲染的效果，而是直接在文字编辑窗口实时展现标记后的效果，这样一来减少了Preview窗口占用的面积，实际上就是增大了文字编辑区的面积，可以减少翻页查询上下文的操作和时间，同时，在标记语言完成输入之后，标记语言就会直接隐去，减少了所显示的文字数量，如要修改，只需要将光标放在标记语言的位置，标记语言就会显现出来。\n\n  但是有一个问题是，目前发现标题（从一级到六级）只要样式一完成，即标记语言隐去之后，若想返回修改标题的级别，无法让标题的标记显现出来，只能先删除整个原标题，再重新标记。\n\n- 界面左侧的文件列表和大纲。Typora编辑区左侧的文件列表和大纲可以通过菜单“View”——“Show Outline Panel”展示出来，文件列表展示当前编辑的文件信息，包括文件名、存储位置、上一次修改时间、字数等，大纲则会给出整篇文章的标题（从一级到六级），并提供跳转链接，类似于Word的导航窗格。\n\n- 界面简洁，功能易找。Typora的界面十分简洁，只有上方一排文字菜单，整个编辑区很大，类似于MarkPad；但是其功能也十分容易找，在编辑区右键一下你就可以发现有很多的样式可以选择，这一点上又与MarkdownPad相似。可以说，Typora继承了MarkPad和MarkdownPad两者的优点，并且避开了他们的缺点。\n\n- 界面主题多样。Typora的界面具有5种主题样式，除了基本日间和夜间界面主题之外，还有类似于书信和报刊的主题。\n\n- 软件本身轻巧，不需要插件。Typora只需要安装即可使用，本身就可以完成实时渲染，不需要任何插件的帮助，开启关闭以及各种操作都很快捷迅速。\n\n### Summary\n\nTypora是一款很优秀、很简洁、很独特、很轻便、功能也很完善的Markdown编辑器，非常推荐使用。","source":"_posts/firstTryonTypora.md","raw":"title: Typora——Markdown编辑界的极简主义\n\ndate: 2017/2/17 09:00:00\n\ncategories:\n\n- Study\n\ntags:\n\n- BlogTools\n- Markdown\n\n---\n\n### Before Typora\n\n在Windows平台上，Typora之前，我还曾经接触过[MarkdownPad](http://www.markdownpad.com/)和[MarkPad](http://code52.org/DownmarkerWPF/)两款Markdown编辑工具。\n\nMarkdownPad和MarkPad的特点：\n\n- 都支持Markdown的所有语法，可以实现不动用鼠标就完成一篇排版精美文章的书写；\n- 二者提供的都是两屏对照的实时渲染系统，即用户在左侧屏敲入带有Markdown语法的文字，在右侧屏会实时显示相应的HTML预览效果。\n- 所生成的Markdown文件可以直接用于个人博客以及上传至Github，支持程度好。\n\n不过，MarkdownPad和MarkPad仍有些许不同：\n\n- MarkdownPad的实时渲染采用的是[Awesomium](http://www.awesomium.com/)，简单来说，Awesomium是一个HTML网页UI界面的渲染引擎，适用于基于C++或者.NET的应用程序。个人觉得，Awesomium对于一个Markdown编辑器来说，功能过于强大，以至于使得MarkdownPad的运行比较吃内存，有悖于Markdown轻量级编辑器的定位，同时在Windows10操作系统下实际使用的时候发现，内嵌于MarkdownPad中的Awesomium经常崩溃，出现无法渲染的情况，需要手动下载Awesomium SDK进行修复（据说安装SDK之后就可以修复，但是我没成功...）。\n- MarkPad的渲染使用的是[JekyII](http://jekyll.com.cn/) ，一个基于Ruby语言的静态网页和网站生成工具。同时，JekyII还可以和Github结合，搭建一个免费静态博客。\n- 此外，在外观和易用性上，MarkdownPad显得比较老气，风格与MS Office比较类似，常用标记功能的图标都列在菜单栏中，较为容易上手使用，MarkPad则较为有科技感，界面简洁，但是由于没有相应的常用功能列表，所以使用起来还需要经过一段时间的锻炼，适合已经熟悉Markdown语法的用户。\n\n### Typora\n\nTypora是也是一款本地的、所写即可见的Markdown编辑器。与上述两种Markdown编辑器一样，Typora支持相同的Markdown语法，也是一款可以不用鼠标操作的编辑器，所写的Markdown文件也可以直接用于博客静态网页的生成。\n\n相比于MarkdownPad和MarkPad，Typora具有以下特点：\n\n- 当前屏幕的实时渲染。Typora不再使用Preview窗口预览渲染的效果，而是直接在文字编辑窗口实时展现标记后的效果，这样一来减少了Preview窗口占用的面积，实际上就是增大了文字编辑区的面积，可以减少翻页查询上下文的操作和时间，同时，在标记语言完成输入之后，标记语言就会直接隐去，减少了所显示的文字数量，如要修改，只需要将光标放在标记语言的位置，标记语言就会显现出来。\n\n  但是有一个问题是，目前发现标题（从一级到六级）只要样式一完成，即标记语言隐去之后，若想返回修改标题的级别，无法让标题的标记显现出来，只能先删除整个原标题，再重新标记。\n\n- 界面左侧的文件列表和大纲。Typora编辑区左侧的文件列表和大纲可以通过菜单“View”——“Show Outline Panel”展示出来，文件列表展示当前编辑的文件信息，包括文件名、存储位置、上一次修改时间、字数等，大纲则会给出整篇文章的标题（从一级到六级），并提供跳转链接，类似于Word的导航窗格。\n\n- 界面简洁，功能易找。Typora的界面十分简洁，只有上方一排文字菜单，整个编辑区很大，类似于MarkPad；但是其功能也十分容易找，在编辑区右键一下你就可以发现有很多的样式可以选择，这一点上又与MarkdownPad相似。可以说，Typora继承了MarkPad和MarkdownPad两者的优点，并且避开了他们的缺点。\n\n- 界面主题多样。Typora的界面具有5种主题样式，除了基本日间和夜间界面主题之外，还有类似于书信和报刊的主题。\n\n- 软件本身轻巧，不需要插件。Typora只需要安装即可使用，本身就可以完成实时渲染，不需要任何插件的帮助，开启关闭以及各种操作都很快捷迅速。\n\n### Summary\n\nTypora是一款很优秀、很简洁、很独特、很轻便、功能也很完善的Markdown编辑器，非常推荐使用。","slug":"firstTryonTypora","published":1,"updated":"2017-02-27T01:50:14.298Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0x6gzdu0000kkupp98e1j9t","content":"<h3 id=\"Before-Typora\"><a href=\"#Before-Typora\" class=\"headerlink\" title=\"Before Typora\"></a>Before Typora</h3><p>在Windows平台上，Typora之前，我还曾经接触过<a href=\"http://www.markdownpad.com/\" target=\"_blank\" rel=\"external\">MarkdownPad</a>和<a href=\"http://code52.org/DownmarkerWPF/\" target=\"_blank\" rel=\"external\">MarkPad</a>两款Markdown编辑工具。</p>\n<p>MarkdownPad和MarkPad的特点：</p>\n<ul>\n<li>都支持Markdown的所有语法，可以实现不动用鼠标就完成一篇排版精美文章的书写；</li>\n<li>二者提供的都是两屏对照的实时渲染系统，即用户在左侧屏敲入带有Markdown语法的文字，在右侧屏会实时显示相应的HTML预览效果。</li>\n<li>所生成的Markdown文件可以直接用于个人博客以及上传至Github，支持程度好。</li>\n</ul>\n<p>不过，MarkdownPad和MarkPad仍有些许不同：</p>\n<ul>\n<li>MarkdownPad的实时渲染采用的是<a href=\"http://www.awesomium.com/\" target=\"_blank\" rel=\"external\">Awesomium</a>，简单来说，Awesomium是一个HTML网页UI界面的渲染引擎，适用于基于C++或者.NET的应用程序。个人觉得，Awesomium对于一个Markdown编辑器来说，功能过于强大，以至于使得MarkdownPad的运行比较吃内存，有悖于Markdown轻量级编辑器的定位，同时在Windows10操作系统下实际使用的时候发现，内嵌于MarkdownPad中的Awesomium经常崩溃，出现无法渲染的情况，需要手动下载Awesomium SDK进行修复（据说安装SDK之后就可以修复，但是我没成功…）。</li>\n<li>MarkPad的渲染使用的是<a href=\"http://jekyll.com.cn/\" target=\"_blank\" rel=\"external\">JekyII</a> ，一个基于Ruby语言的静态网页和网站生成工具。同时，JekyII还可以和Github结合，搭建一个免费静态博客。</li>\n<li>此外，在外观和易用性上，MarkdownPad显得比较老气，风格与MS Office比较类似，常用标记功能的图标都列在菜单栏中，较为容易上手使用，MarkPad则较为有科技感，界面简洁，但是由于没有相应的常用功能列表，所以使用起来还需要经过一段时间的锻炼，适合已经熟悉Markdown语法的用户。</li>\n</ul>\n<h3 id=\"Typora\"><a href=\"#Typora\" class=\"headerlink\" title=\"Typora\"></a>Typora</h3><p>Typora是也是一款本地的、所写即可见的Markdown编辑器。与上述两种Markdown编辑器一样，Typora支持相同的Markdown语法，也是一款可以不用鼠标操作的编辑器，所写的Markdown文件也可以直接用于博客静态网页的生成。</p>\n<p>相比于MarkdownPad和MarkPad，Typora具有以下特点：</p>\n<ul>\n<li><p>当前屏幕的实时渲染。Typora不再使用Preview窗口预览渲染的效果，而是直接在文字编辑窗口实时展现标记后的效果，这样一来减少了Preview窗口占用的面积，实际上就是增大了文字编辑区的面积，可以减少翻页查询上下文的操作和时间，同时，在标记语言完成输入之后，标记语言就会直接隐去，减少了所显示的文字数量，如要修改，只需要将光标放在标记语言的位置，标记语言就会显现出来。</p>\n<p>但是有一个问题是，目前发现标题（从一级到六级）只要样式一完成，即标记语言隐去之后，若想返回修改标题的级别，无法让标题的标记显现出来，只能先删除整个原标题，再重新标记。</p>\n</li>\n<li><p>界面左侧的文件列表和大纲。Typora编辑区左侧的文件列表和大纲可以通过菜单“View”——“Show Outline Panel”展示出来，文件列表展示当前编辑的文件信息，包括文件名、存储位置、上一次修改时间、字数等，大纲则会给出整篇文章的标题（从一级到六级），并提供跳转链接，类似于Word的导航窗格。</p>\n</li>\n<li><p>界面简洁，功能易找。Typora的界面十分简洁，只有上方一排文字菜单，整个编辑区很大，类似于MarkPad；但是其功能也十分容易找，在编辑区右键一下你就可以发现有很多的样式可以选择，这一点上又与MarkdownPad相似。可以说，Typora继承了MarkPad和MarkdownPad两者的优点，并且避开了他们的缺点。</p>\n</li>\n<li><p>界面主题多样。Typora的界面具有5种主题样式，除了基本日间和夜间界面主题之外，还有类似于书信和报刊的主题。</p>\n</li>\n<li><p>软件本身轻巧，不需要插件。Typora只需要安装即可使用，本身就可以完成实时渲染，不需要任何插件的帮助，开启关闭以及各种操作都很快捷迅速。</p>\n</li>\n</ul>\n<h3 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><p>Typora是一款很优秀、很简洁、很独特、很轻便、功能也很完善的Markdown编辑器，非常推荐使用。</p>\n","excerpt":"","more":"<h3 id=\"Before-Typora\"><a href=\"#Before-Typora\" class=\"headerlink\" title=\"Before Typora\"></a>Before Typora</h3><p>在Windows平台上，Typora之前，我还曾经接触过<a href=\"http://www.markdownpad.com/\">MarkdownPad</a>和<a href=\"http://code52.org/DownmarkerWPF/\">MarkPad</a>两款Markdown编辑工具。</p>\n<p>MarkdownPad和MarkPad的特点：</p>\n<ul>\n<li>都支持Markdown的所有语法，可以实现不动用鼠标就完成一篇排版精美文章的书写；</li>\n<li>二者提供的都是两屏对照的实时渲染系统，即用户在左侧屏敲入带有Markdown语法的文字，在右侧屏会实时显示相应的HTML预览效果。</li>\n<li>所生成的Markdown文件可以直接用于个人博客以及上传至Github，支持程度好。</li>\n</ul>\n<p>不过，MarkdownPad和MarkPad仍有些许不同：</p>\n<ul>\n<li>MarkdownPad的实时渲染采用的是<a href=\"http://www.awesomium.com/\">Awesomium</a>，简单来说，Awesomium是一个HTML网页UI界面的渲染引擎，适用于基于C++或者.NET的应用程序。个人觉得，Awesomium对于一个Markdown编辑器来说，功能过于强大，以至于使得MarkdownPad的运行比较吃内存，有悖于Markdown轻量级编辑器的定位，同时在Windows10操作系统下实际使用的时候发现，内嵌于MarkdownPad中的Awesomium经常崩溃，出现无法渲染的情况，需要手动下载Awesomium SDK进行修复（据说安装SDK之后就可以修复，但是我没成功…）。</li>\n<li>MarkPad的渲染使用的是<a href=\"http://jekyll.com.cn/\">JekyII</a> ，一个基于Ruby语言的静态网页和网站生成工具。同时，JekyII还可以和Github结合，搭建一个免费静态博客。</li>\n<li>此外，在外观和易用性上，MarkdownPad显得比较老气，风格与MS Office比较类似，常用标记功能的图标都列在菜单栏中，较为容易上手使用，MarkPad则较为有科技感，界面简洁，但是由于没有相应的常用功能列表，所以使用起来还需要经过一段时间的锻炼，适合已经熟悉Markdown语法的用户。</li>\n</ul>\n<h3 id=\"Typora\"><a href=\"#Typora\" class=\"headerlink\" title=\"Typora\"></a>Typora</h3><p>Typora是也是一款本地的、所写即可见的Markdown编辑器。与上述两种Markdown编辑器一样，Typora支持相同的Markdown语法，也是一款可以不用鼠标操作的编辑器，所写的Markdown文件也可以直接用于博客静态网页的生成。</p>\n<p>相比于MarkdownPad和MarkPad，Typora具有以下特点：</p>\n<ul>\n<li><p>当前屏幕的实时渲染。Typora不再使用Preview窗口预览渲染的效果，而是直接在文字编辑窗口实时展现标记后的效果，这样一来减少了Preview窗口占用的面积，实际上就是增大了文字编辑区的面积，可以减少翻页查询上下文的操作和时间，同时，在标记语言完成输入之后，标记语言就会直接隐去，减少了所显示的文字数量，如要修改，只需要将光标放在标记语言的位置，标记语言就会显现出来。</p>\n<p>但是有一个问题是，目前发现标题（从一级到六级）只要样式一完成，即标记语言隐去之后，若想返回修改标题的级别，无法让标题的标记显现出来，只能先删除整个原标题，再重新标记。</p>\n</li>\n<li><p>界面左侧的文件列表和大纲。Typora编辑区左侧的文件列表和大纲可以通过菜单“View”——“Show Outline Panel”展示出来，文件列表展示当前编辑的文件信息，包括文件名、存储位置、上一次修改时间、字数等，大纲则会给出整篇文章的标题（从一级到六级），并提供跳转链接，类似于Word的导航窗格。</p>\n</li>\n<li><p>界面简洁，功能易找。Typora的界面十分简洁，只有上方一排文字菜单，整个编辑区很大，类似于MarkPad；但是其功能也十分容易找，在编辑区右键一下你就可以发现有很多的样式可以选择，这一点上又与MarkdownPad相似。可以说，Typora继承了MarkPad和MarkdownPad两者的优点，并且避开了他们的缺点。</p>\n</li>\n<li><p>界面主题多样。Typora的界面具有5种主题样式，除了基本日间和夜间界面主题之外，还有类似于书信和报刊的主题。</p>\n</li>\n<li><p>软件本身轻巧，不需要插件。Typora只需要安装即可使用，本身就可以完成实时渲染，不需要任何插件的帮助，开启关闭以及各种操作都很快捷迅速。</p>\n</li>\n</ul>\n<h3 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><p>Typora是一款很优秀、很简洁、很独特、很轻便、功能也很完善的Markdown编辑器，非常推荐使用。</p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2017-02-24T02:40:00.739Z","updated":"2017-02-20T09:07:37.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0x6gzdx0002kkup3vp8v9oz","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n"},{"title":"Git Study","date":"2017-02-23T16:00:00.000Z","_content":"\n### 0 Git Introduction\n\nGit是一种开源的分布式版本管理系统。\n\n每台安装了Git的机器上都会维持一个Git的本地仓库。\n\n### 1 本地版本库的创建与管理\n\n#### 1.1 创建与文件提交\n\n- 初始化一个Git仓库：`git init`；\n- 添加文件到Git仓库（[背后的原理](#gitadd-principle)）:\n  1. `git add <file>` ，可以使用多次，添加多个文件；\n  2. `git commit -m \"提交说明文字\"` ，完成一次提交。\n\n#### 1.2 查看仓库状态\n\n- `git status` ，查看本地仓库的[工作区](#workplace)状态，命令会告诉我们，当前有哪些文件被修改了，现在的状态是”没有添加任何文件“OR”已添加待提交“，此外还会对后续操作提示相应的命令；\n- `git diff` ， 如果有文件被修改了，可以用该命令查看具体的修改内容（有\"-\"号的一行说明有删减，有“+”的一行说明有增加）。\n\n#### 1.2 版本回退与回退的撤销\n\n- `git log` ，查看提交的历史记录，以便确定回退到哪一个版本，精简输出可以使用`git log --pretty=oneline`；<span id=\"versionback\"></span>\n\n- `git reflog` ，查看命令的历史记录，可以用于确定版本回退之前的最新版本号`commit_id` ；\n\n- `git reset --hard <commit_id>` ，`commit_id` 是版本号，是SHA1计算得出的十六进制数字，每提交一次就会新生成一个`commit_id` ，版本号没有必要每次都输入完整，保证前几位不同就可以。此外，`HEAD` 表示当前版本号，`HEAD^` 表示上一个版本号，以此类推，`HEAD~100` 表示上100个版本号。\n\n  **注意** ：对于只有一个版本的版本库是无法再回退到上一个状态（即最初初始化的状态）\n\n#### 1.4 工作区与暂存区\n\n- <span id=\"workplace\">工作区（Working Directory）</span>\n\n  也就是当时使用`git init` 初始化的本地仓库的目录/文件夹。\n\n- 版本库（Repository）\n\n  工作区内的隐藏目录`.git` ，这个目录不算工作区，而是属于版本库。版本库中最重要的部分是暂存区（stage/index）这也是Git与SVN不同之处，同时还有Git自动创建的第一个[分支](#branch)`master` 和指向`master` 的[指针`HEAD`](#pointer-HEAD) 。\n\n- 工作区与暂存区的关系\n\n  这里通过`git add <file>` 的<span id=\"gitadd-principle\">工作原理</span>来解释一下工作区与暂存区之间的关系。\n\n  1. `git add` 添加的时候，实际上是将文件或者文件的修改添加到暂存区中；\n\n  2. `git commit` 提交文件或文件修改，实际上是将暂存区的所有内容提交到当前分支中。\n\n     **注意**：\n\n     - 提交之后，工作区就没有任何新的修改，暂存区也没有任何内容，同时产生了新的版本。\n\n     - 提交的时候，Git只负责将已经加入暂存区的修改内容提交到分支中，即若`git add` 之后再对文件进行修改，那么此时修改的内容是不会提交到分支中的。\n\n       `git diff HEAD -- <file>` ，可以用于查看工作区与版本库中最新版本之间的区别。\n\n#### 1.5 管理与修改、删除\n\nGit跟踪并管理的是**文件的修改部分** ,而非整个文件。\n\n所以，如果修改没有从工作区添加到暂存区，那么这些修改就无法被提交到版本库的最新版本中。\n\n- `git checkout -- <file>` ，直接放弃对工作区的所有修改，这比一行一行的恢复更省力气，有时候对于不知道修改了哪部分内容的情况也很有用。\n\n- `git rm --cached <file>` ，将添加到暂存区的修改撤销（unstage），并将修改重新放回工作区，如果此时仍想撤销所有的修改，则执行命令`git checkout -- <file>` ；\n\n- 如果已经向本地版本库提交了不合适的修改并想要撤销时，需要[版本回退](#versionback)操作，前提是还没有推送到远程仓库。\n\n- 若要删除<span id=\"local-delete\"></span>一个文件，需要在工作区和版本库中同时删除该文件 `git rm <file>` ，并在删除完成后重新提交`git commit -m <file> ` 一次：\n\n- 若在工作区错删了文件，则可以借助版本库，将该文件恢复到最新一次提交的状态：`git checkout -- <file>` *（当然，如果回收站还没清空的话，也可以去回收站看看）*；\n\n- **注** ：`git checkout` 的原理是，利用版本库中的最新版本替换工作区的版本。\n\n\n### 2 远程仓库\n\n可以自己搭建Git服务器作为远程仓库，也可以使用Github的免费仓库（但是是公开的所有人可见的）。\n\n一台电脑上也可以建立多个版本库，只要不在同一目录中即可。\n\nGit支持SSH协议。\n\n#### 2.1 添加远程库与推送Push\n\n在完成Github注册和SSH Key添加之后，就可以在Github上创建一个新的Git仓库，然后根据相应的提示，将本地仓库的文件推送（Push）到远程仓库中。\n\n- `git remote add origin <仓库地址>` ，在本地仓库目录下执行，将本地仓库与远程仓库进行关联，同时为远程仓库定义了新的名字`origin` ，当然也可以使用别的名字；\n- `git push -u origin master` ，将本地仓库的内容推送到远成仓库，实际上是将当前分支`master` 的内容推送到远程仓库的`master` 分支，由于刚开始远程仓库是空的，所以第一次推送的时候，需要参数`-u` ，这样在推送的同时，还会建立起本地分支`master` 和远程仓库中`master` 分支的联系，以后推送和拉取内容就可以简化命令，即`git push origin master` 和`git pull` 。\n\n#### 2.2 从远程库克隆Clone\n\n- `git clone https://github.com/zouguijin/docSync.git` \n\n- `git clone git@github.com:zouguijin/docSync.git` \n\n  Git支持多种协议，默认的git（所使用的是ssh协议），此外还可以使用https协议（但是https协议有时候比较慢，而且每次推送都需要输入口令，使用ssh就不需要输入口令，`get clone` 的时候都要口令...）。\n\n#### 2.3 远程仓库文件的删除\n\n在[管理与修改、删除](#local-delete) 部分，讲述了本地工作区和本地仓库文件的删除方法。若希望删除远程库中的文件，需要：\n\n1. 进入与远程库相对应的本地仓库，切换到相应的分支，或者建立本地分支与远程分支的连接，然后通过`git pull` 将远程库的内容抓取到本地库中；\n\n2. 将不需要的内容在本地仓库中删除，然后再次添加`git add .` ，提交`git commit -m \"...\"` ，并最后推送到远程仓库覆盖原内容即可`git push origin branch ` 。\n\n   **注** ：如果上一个提交者不是当前机器，则不能直接在本地修改然后推送，会出现冲突，否则可以直接修改并推送。\n\n### 3 分支（Branch）\n\n创建属于自己的分支，其他人是看不到的，一个未完成的项目可以在分支上不断更新，直到完成之后再一次提交到`master` 主分支上。\n\n#### 3.1 创建与合并\n\n- 原理：\n\n  一个分支就是一条时间线，随着不断地提交逐渐变长。最初只有主分支即`master` 分支，同时有一个`master` 指针指向主分支的最新提交，之前说的指针`HEAD` 指向的是指针`master` ，而不是指向最新提交。即：\n\n  > `HEAD` -> `master` -> `最新提交` \n\n  每次提交之后，`master` 分支都会向前延长，同时指针`master` 都会指向最新的提交，指针`HEAD` 的指向不变。\n\n  创建新的分支，例如`branch` 时，即创建新的指针`branch` ，指向与`master` 相同的提交，此时若将指针`HEAD` 指向`branch` ，则表示切换当前分支，由主分支切换到`branch` 分支。\n\n  > `master` ->`最新提交` <- `branch` <- `HEAD`  \n\n  如果在`branch` 分支下提交新的修改，那么`branch` 分支就会向前延长，指针`branch` 指向最新提交，但此时指针`master` 保持切换前的指向位置不变。\n\n  合并分支，也就是将主分支的`master` 指针指向`branch` 指针所指向的最新提交即可，合并分支后，一般都会将工作时使用的新分支`branch` 删除，即删除`branch` 指针。\n\n  **注** ：可见，所谓创建分支，只是创建了一个指针，切换、合并分支，只是改变了指针的指向，删除分支，只是将对应的指针删除，所有的操作都不涉及内容的改变。\n\n- 命令操作\n\n  - `git branch` ，查看分支情况，当前分支前会用`*` 标记；\n  - `git branch <name>` ，创建分支；\n  - `git checkout <name>` ，切换分支，由当前分支切换到指定命名分支；\n  - `git checkout -b <name>` ，创建&切换分支；\n  - `git merge <name>` ，合并分支，将指定命名分支合并到当前分支上；（默认使用`Fast Forward` 模式，该模式下删除分支后，分支信息也随之删除，即看不到历史合并信息；若希望能看到历史合并信息，就需要禁用FF模式，并最好添加注释信息，即`git merge --no-ff -m \"注释信息\" <name>`）\n  - `git branch -d <name>` ，删除指定命名分支。\n\n- 合并冲突<span id=\"conflict-solve\"></span>\n\n  如果两个需要合并的分支各自都有新的提交，而且两者的提交在同一位置有不同的表述，在合并的时候就会出现冲突，即不能简单地删除、添加或者替换。\n\n  冲突出现的时候，在显示分支的括号中会多出`|MERGING` 字样，表示此时必须解决合并冲突，分支切换操作被禁止，这时需要利用`git diff` 查看文件内容，并手动修改冲突的内容，然后重新添加和提交即可。（Git会用`<<<<<<<`，`=======`，`>>>>>>>`标记出不同分支的内容）\n\n  `git log --graph` 可以看到分支的合并情况，或者简化版`git log --graph --pretty=oneline --abbrev-commit` 。\n\n- 分支管理策略\n\n  - 保证主分支`master` 是稳定的，仅仅用于发布公开的、可以使用的新版本；\n  - 如果团队合作的话，需要新建一个团队开发提交的分支，例如`dev` 分支，平时的提交与合并都在该分支上完成，一个完整的版本完成之后再将`dev` 分支合并到主分支上。\n\n#### 3.2 Bug分支\n\n当遇到Bug的时候，可以切换到需要修复Bug的分支上，在该分支上创建临时的Bug分支，在临时分支上修复Bug，然后合并原分支上，最后删除临时分支即可。\n\n此时，如果手头上的工作没有做完（工作区有正在修改的内容，如果将Bug修复完成之后就添加、提交，那么之前正在处理但未处理完成的工作就会和修复的Bug一起添加并提交上去，这是我们不想看见的），那么这时候就需要将未完成的工作**先拿出工作区并暂存**起来：\n\n> `git stash` \n\n此时，利用`git status` 查看工作区，会看见工作区是干净的。\n\n完成Bug修复之后，可以再将之前的工作取出来放进工作区继续完成：\n\n- `git stash list` ，若有多个工作，可以先查看列表，再决定需要恢复哪个工作；\n- `git stash apply` ，恢复工作之后，暂存的内容并不会自动删除，需要使用`git stash drop` 将相应的内容删除；\n- `git stash pop` ，推荐使用，恢复工作的同时，可以将暂存的内容也删除；\n- 若要指定恢复或者删除哪一条`stash` ，可以添加后续命令`stash@{x}` ，`x` 可以从`stash` 列表中选取。\n\n#### 3.3 Feature分支\n\n为项目开发一个新的功能时，最好在项目分支上新建一个分支，功能完成之后再将新功能的代码合并到项目分支中。\n\n如果在合并之前，需要放弃该功能分支，则需要通过强行删除的操作完成：\n\n> `git branch -D <name>`\n\n#### 3.4 推送与抓取\n\n- `git remote -v` ，查看远程库的信息，会给出本地可以抓取和推送的远程库的地址以及远程库的命名（默认是`origin`）；\n\n- `git push origin <name> ` ，推送分支，即将指定分支上的所有本地内容推送到远程仓库中的**相对应**的分支上，可以推送本地`master` 分支内容，也可以推送其他分支的内容；\n\n- `git clone <git/https>` ，其他用户从远程库克隆的时候，默认情况下只能看到`master` 分支（当然其他分支也随之克隆下来了，只是不稍微调整是看不到的），前面说了，一般不会直接向`master` 分支推送修改，所以需要在本地创建远程仓库`origin` 的分支`branch` （这里的`branch` 需要与远程仓库的`branch` 同名）：\n\n  > `git checkout -b branch origin/branch` \n\n  只有这样，才能建立本地与远成仓库的联系，之后的抓取`git pull` 和推送`git push origin branch ` 才可以进行。\n\n- `git pull` ，抓取分支，首先需要建立本地分支与远程仓库相应分支之间的链接：\n\n  > `git branch --set-upstream branch origin/branch` \n\n  在之前建立本地分支与远程库分支的基础上，可以将最新的提交从远程库相应的分支上抓取下来：\n\n  > `git pull` \n\n  如果`git pull` 的时候出现冲突，则需要[解决冲突](#conflict-solve) 。\n\n- 本地分支，若不推送到远程，只有本地可见。\n\n### 4 标签（Tag）\n\n版本发布的时候，为了今后方便查找，一般会使用标签的方式，采用有意义的文字标记当前版本，即可以将标签当作版本库的一个快照，本质上标签就是一个指向某一次`commit` 的指针，类似于分支指针（但是分支指针可以移动，标签指针不可以移动）。\n\n- `git tag` ，查看所有标签；\n- `git tag <name>` ，为当前分支生成一个标签，标签默认标记在最新的提交上；\n- `git tag <name> <commit_id>` ，若想为历史的某一次提交生成标签，则找到该提交的`commit_id` 即可；\n- `git tag -a <tagname> -m \"注释信息\" <commit_id>` ，创建标签并生成注释；\n- `git show <tagname>` ，查看相应的标签信息；\n\n**注** ：标签是按照字母顺序排序的，而不是按照时间排序。\n\n- `git tag -d <tagname>` ，删除本地标签；\n\n- `git push origin <tagname>` ，将标签推送到远程仓库中；\n\n- `git push origin --tags` ，一次性地将本地标签全部推送到远程库中；\n\n- 若想要删除的标签已经被推送到了远程库中，那么需要两步才能删除标签：\n\n  >`git tag -d <tagname>` #首先，本地删除\n  >\n  >`git push origin :refs/tags/<tagname>` #然后，远程删除库中的标签\n\n### 5 Github\n\n如果要参与开源项目，首先将开源项目`Fork` 到自己的仓库中，然后**从自己的仓库中`Clone` **，只有这样才能在本地修改之后，再次推送到Github上，若希望开源项目的官方接受自己的修改，则需要在Github上发起`Pull Request` 。\n\n### 6 .gitignore\n\n.gitignore文件中的文件名将会在提交的时候被忽略，.gitignore文件需要放在版本库中。\n\n.gitignore文件不需要从头开始编写，可以参照[官方文档](https://github.com/github/gitignore '.gitignore-doc')并进行相应的组合即可。\n\n- `git add -f <file>` ，有时候.gitignore文件中禁止提交的文件类型中，有你希望提交的一份文件，则可以通过上述命令强行添加并提交；\n- `git check-ignore -v <file>` ，当发现一个文件无法添加和提交时，需要检查.gitignore文件中哪一条规则写错了，可以使用上述命令进行检查。\n\n### 7 Git配置\n\n- 当前仓库的配置文档存放在`.git/config` 文件中；\n- 当前用户的配置文档存放在用户主目录下的隐藏文件`.gitignore` 中；\n- `git config --global alias. <short-command> <origin-command>` ，配置别名，简化使用。\n\n### 8 Git服务器搭建\n\n服务器系统采用Linux，推荐Ubuntu或者Debian，以下操作需要sudo权限。\n\n1. 安装Git:\n\n   `sudo apt-get install git` \n\n2. 创建Git用户，用于运行Git服务：\n\n   `sudo adduser git` \n\n3. 添加公钥，保证用户的登录：\n\n   收集所有需要登录服务器的用户的公钥，即`id_rsa.pub` 文件的内容，将公钥添加进服务器的`/home/git/.ssh/authorized_keys` 文件中，一行一个。\n\n4. 初始化Git仓库：\n\n   选定一个目录作为Git仓库，例如`/git/git-server.git` ，在目录`/git` 下执行命令：\n\n   `sudo git init --bare git-server.git` \n\n   创建的是裸仓库，即没有工作区，服务器的目的是为了共享，而不允许用户登录到服务器上去修改，然后将Git仓库的所有者更改为之前添加的用户git：\n\n   `sudo chown -R git:git git-server.git` \n\n5. 禁用shell登录：\n\n   即禁止之前创建的用户git登录shell，可以通过编辑`/etc/passwd` 文件完成，将以下一行\n\n   `git:x:1001:1001:,,,:/home/git:/bin/bash` \n\n   改为\n\n   `git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell` \n\n   意思就是，用户`git` 每次一登录shell就会自动退出，即无法登录shell进行其他操作，这么做的目的是，让`git` 用户可以正常通过ssh使用git，但禁止其登录shell。\n\n6. 远程Git仓库已经建立好了，其他客户端用户可以使用`git clone` 将服务器上的内容克隆到本地进行修改：\n\n   `git clone git@server:/git/git-server.git` \n\n   修改完成之后，就是推送与共享了。","source":"_posts/git-study.md","raw":"title: Git Study\n\ndate: 2017/02/24 00:00:00\n\ncategories:\n\n- Study\n\ntags:\n\n- Git\n- Github\n\n---\n\n### 0 Git Introduction\n\nGit是一种开源的分布式版本管理系统。\n\n每台安装了Git的机器上都会维持一个Git的本地仓库。\n\n### 1 本地版本库的创建与管理\n\n#### 1.1 创建与文件提交\n\n- 初始化一个Git仓库：`git init`；\n- 添加文件到Git仓库（[背后的原理](#gitadd-principle)）:\n  1. `git add <file>` ，可以使用多次，添加多个文件；\n  2. `git commit -m \"提交说明文字\"` ，完成一次提交。\n\n#### 1.2 查看仓库状态\n\n- `git status` ，查看本地仓库的[工作区](#workplace)状态，命令会告诉我们，当前有哪些文件被修改了，现在的状态是”没有添加任何文件“OR”已添加待提交“，此外还会对后续操作提示相应的命令；\n- `git diff` ， 如果有文件被修改了，可以用该命令查看具体的修改内容（有\"-\"号的一行说明有删减，有“+”的一行说明有增加）。\n\n#### 1.2 版本回退与回退的撤销\n\n- `git log` ，查看提交的历史记录，以便确定回退到哪一个版本，精简输出可以使用`git log --pretty=oneline`；<span id=\"versionback\"></span>\n\n- `git reflog` ，查看命令的历史记录，可以用于确定版本回退之前的最新版本号`commit_id` ；\n\n- `git reset --hard <commit_id>` ，`commit_id` 是版本号，是SHA1计算得出的十六进制数字，每提交一次就会新生成一个`commit_id` ，版本号没有必要每次都输入完整，保证前几位不同就可以。此外，`HEAD` 表示当前版本号，`HEAD^` 表示上一个版本号，以此类推，`HEAD~100` 表示上100个版本号。\n\n  **注意** ：对于只有一个版本的版本库是无法再回退到上一个状态（即最初初始化的状态）\n\n#### 1.4 工作区与暂存区\n\n- <span id=\"workplace\">工作区（Working Directory）</span>\n\n  也就是当时使用`git init` 初始化的本地仓库的目录/文件夹。\n\n- 版本库（Repository）\n\n  工作区内的隐藏目录`.git` ，这个目录不算工作区，而是属于版本库。版本库中最重要的部分是暂存区（stage/index）这也是Git与SVN不同之处，同时还有Git自动创建的第一个[分支](#branch)`master` 和指向`master` 的[指针`HEAD`](#pointer-HEAD) 。\n\n- 工作区与暂存区的关系\n\n  这里通过`git add <file>` 的<span id=\"gitadd-principle\">工作原理</span>来解释一下工作区与暂存区之间的关系。\n\n  1. `git add` 添加的时候，实际上是将文件或者文件的修改添加到暂存区中；\n\n  2. `git commit` 提交文件或文件修改，实际上是将暂存区的所有内容提交到当前分支中。\n\n     **注意**：\n\n     - 提交之后，工作区就没有任何新的修改，暂存区也没有任何内容，同时产生了新的版本。\n\n     - 提交的时候，Git只负责将已经加入暂存区的修改内容提交到分支中，即若`git add` 之后再对文件进行修改，那么此时修改的内容是不会提交到分支中的。\n\n       `git diff HEAD -- <file>` ，可以用于查看工作区与版本库中最新版本之间的区别。\n\n#### 1.5 管理与修改、删除\n\nGit跟踪并管理的是**文件的修改部分** ,而非整个文件。\n\n所以，如果修改没有从工作区添加到暂存区，那么这些修改就无法被提交到版本库的最新版本中。\n\n- `git checkout -- <file>` ，直接放弃对工作区的所有修改，这比一行一行的恢复更省力气，有时候对于不知道修改了哪部分内容的情况也很有用。\n\n- `git rm --cached <file>` ，将添加到暂存区的修改撤销（unstage），并将修改重新放回工作区，如果此时仍想撤销所有的修改，则执行命令`git checkout -- <file>` ；\n\n- 如果已经向本地版本库提交了不合适的修改并想要撤销时，需要[版本回退](#versionback)操作，前提是还没有推送到远程仓库。\n\n- 若要删除<span id=\"local-delete\"></span>一个文件，需要在工作区和版本库中同时删除该文件 `git rm <file>` ，并在删除完成后重新提交`git commit -m <file> ` 一次：\n\n- 若在工作区错删了文件，则可以借助版本库，将该文件恢复到最新一次提交的状态：`git checkout -- <file>` *（当然，如果回收站还没清空的话，也可以去回收站看看）*；\n\n- **注** ：`git checkout` 的原理是，利用版本库中的最新版本替换工作区的版本。\n\n\n### 2 远程仓库\n\n可以自己搭建Git服务器作为远程仓库，也可以使用Github的免费仓库（但是是公开的所有人可见的）。\n\n一台电脑上也可以建立多个版本库，只要不在同一目录中即可。\n\nGit支持SSH协议。\n\n#### 2.1 添加远程库与推送Push\n\n在完成Github注册和SSH Key添加之后，就可以在Github上创建一个新的Git仓库，然后根据相应的提示，将本地仓库的文件推送（Push）到远程仓库中。\n\n- `git remote add origin <仓库地址>` ，在本地仓库目录下执行，将本地仓库与远程仓库进行关联，同时为远程仓库定义了新的名字`origin` ，当然也可以使用别的名字；\n- `git push -u origin master` ，将本地仓库的内容推送到远成仓库，实际上是将当前分支`master` 的内容推送到远程仓库的`master` 分支，由于刚开始远程仓库是空的，所以第一次推送的时候，需要参数`-u` ，这样在推送的同时，还会建立起本地分支`master` 和远程仓库中`master` 分支的联系，以后推送和拉取内容就可以简化命令，即`git push origin master` 和`git pull` 。\n\n#### 2.2 从远程库克隆Clone\n\n- `git clone https://github.com/zouguijin/docSync.git` \n\n- `git clone git@github.com:zouguijin/docSync.git` \n\n  Git支持多种协议，默认的git（所使用的是ssh协议），此外还可以使用https协议（但是https协议有时候比较慢，而且每次推送都需要输入口令，使用ssh就不需要输入口令，`get clone` 的时候都要口令...）。\n\n#### 2.3 远程仓库文件的删除\n\n在[管理与修改、删除](#local-delete) 部分，讲述了本地工作区和本地仓库文件的删除方法。若希望删除远程库中的文件，需要：\n\n1. 进入与远程库相对应的本地仓库，切换到相应的分支，或者建立本地分支与远程分支的连接，然后通过`git pull` 将远程库的内容抓取到本地库中；\n\n2. 将不需要的内容在本地仓库中删除，然后再次添加`git add .` ，提交`git commit -m \"...\"` ，并最后推送到远程仓库覆盖原内容即可`git push origin branch ` 。\n\n   **注** ：如果上一个提交者不是当前机器，则不能直接在本地修改然后推送，会出现冲突，否则可以直接修改并推送。\n\n### 3 分支（Branch）\n\n创建属于自己的分支，其他人是看不到的，一个未完成的项目可以在分支上不断更新，直到完成之后再一次提交到`master` 主分支上。\n\n#### 3.1 创建与合并\n\n- 原理：\n\n  一个分支就是一条时间线，随着不断地提交逐渐变长。最初只有主分支即`master` 分支，同时有一个`master` 指针指向主分支的最新提交，之前说的指针`HEAD` 指向的是指针`master` ，而不是指向最新提交。即：\n\n  > `HEAD` -> `master` -> `最新提交` \n\n  每次提交之后，`master` 分支都会向前延长，同时指针`master` 都会指向最新的提交，指针`HEAD` 的指向不变。\n\n  创建新的分支，例如`branch` 时，即创建新的指针`branch` ，指向与`master` 相同的提交，此时若将指针`HEAD` 指向`branch` ，则表示切换当前分支，由主分支切换到`branch` 分支。\n\n  > `master` ->`最新提交` <- `branch` <- `HEAD`  \n\n  如果在`branch` 分支下提交新的修改，那么`branch` 分支就会向前延长，指针`branch` 指向最新提交，但此时指针`master` 保持切换前的指向位置不变。\n\n  合并分支，也就是将主分支的`master` 指针指向`branch` 指针所指向的最新提交即可，合并分支后，一般都会将工作时使用的新分支`branch` 删除，即删除`branch` 指针。\n\n  **注** ：可见，所谓创建分支，只是创建了一个指针，切换、合并分支，只是改变了指针的指向，删除分支，只是将对应的指针删除，所有的操作都不涉及内容的改变。\n\n- 命令操作\n\n  - `git branch` ，查看分支情况，当前分支前会用`*` 标记；\n  - `git branch <name>` ，创建分支；\n  - `git checkout <name>` ，切换分支，由当前分支切换到指定命名分支；\n  - `git checkout -b <name>` ，创建&切换分支；\n  - `git merge <name>` ，合并分支，将指定命名分支合并到当前分支上；（默认使用`Fast Forward` 模式，该模式下删除分支后，分支信息也随之删除，即看不到历史合并信息；若希望能看到历史合并信息，就需要禁用FF模式，并最好添加注释信息，即`git merge --no-ff -m \"注释信息\" <name>`）\n  - `git branch -d <name>` ，删除指定命名分支。\n\n- 合并冲突<span id=\"conflict-solve\"></span>\n\n  如果两个需要合并的分支各自都有新的提交，而且两者的提交在同一位置有不同的表述，在合并的时候就会出现冲突，即不能简单地删除、添加或者替换。\n\n  冲突出现的时候，在显示分支的括号中会多出`|MERGING` 字样，表示此时必须解决合并冲突，分支切换操作被禁止，这时需要利用`git diff` 查看文件内容，并手动修改冲突的内容，然后重新添加和提交即可。（Git会用`<<<<<<<`，`=======`，`>>>>>>>`标记出不同分支的内容）\n\n  `git log --graph` 可以看到分支的合并情况，或者简化版`git log --graph --pretty=oneline --abbrev-commit` 。\n\n- 分支管理策略\n\n  - 保证主分支`master` 是稳定的，仅仅用于发布公开的、可以使用的新版本；\n  - 如果团队合作的话，需要新建一个团队开发提交的分支，例如`dev` 分支，平时的提交与合并都在该分支上完成，一个完整的版本完成之后再将`dev` 分支合并到主分支上。\n\n#### 3.2 Bug分支\n\n当遇到Bug的时候，可以切换到需要修复Bug的分支上，在该分支上创建临时的Bug分支，在临时分支上修复Bug，然后合并原分支上，最后删除临时分支即可。\n\n此时，如果手头上的工作没有做完（工作区有正在修改的内容，如果将Bug修复完成之后就添加、提交，那么之前正在处理但未处理完成的工作就会和修复的Bug一起添加并提交上去，这是我们不想看见的），那么这时候就需要将未完成的工作**先拿出工作区并暂存**起来：\n\n> `git stash` \n\n此时，利用`git status` 查看工作区，会看见工作区是干净的。\n\n完成Bug修复之后，可以再将之前的工作取出来放进工作区继续完成：\n\n- `git stash list` ，若有多个工作，可以先查看列表，再决定需要恢复哪个工作；\n- `git stash apply` ，恢复工作之后，暂存的内容并不会自动删除，需要使用`git stash drop` 将相应的内容删除；\n- `git stash pop` ，推荐使用，恢复工作的同时，可以将暂存的内容也删除；\n- 若要指定恢复或者删除哪一条`stash` ，可以添加后续命令`stash@{x}` ，`x` 可以从`stash` 列表中选取。\n\n#### 3.3 Feature分支\n\n为项目开发一个新的功能时，最好在项目分支上新建一个分支，功能完成之后再将新功能的代码合并到项目分支中。\n\n如果在合并之前，需要放弃该功能分支，则需要通过强行删除的操作完成：\n\n> `git branch -D <name>`\n\n#### 3.4 推送与抓取\n\n- `git remote -v` ，查看远程库的信息，会给出本地可以抓取和推送的远程库的地址以及远程库的命名（默认是`origin`）；\n\n- `git push origin <name> ` ，推送分支，即将指定分支上的所有本地内容推送到远程仓库中的**相对应**的分支上，可以推送本地`master` 分支内容，也可以推送其他分支的内容；\n\n- `git clone <git/https>` ，其他用户从远程库克隆的时候，默认情况下只能看到`master` 分支（当然其他分支也随之克隆下来了，只是不稍微调整是看不到的），前面说了，一般不会直接向`master` 分支推送修改，所以需要在本地创建远程仓库`origin` 的分支`branch` （这里的`branch` 需要与远程仓库的`branch` 同名）：\n\n  > `git checkout -b branch origin/branch` \n\n  只有这样，才能建立本地与远成仓库的联系，之后的抓取`git pull` 和推送`git push origin branch ` 才可以进行。\n\n- `git pull` ，抓取分支，首先需要建立本地分支与远程仓库相应分支之间的链接：\n\n  > `git branch --set-upstream branch origin/branch` \n\n  在之前建立本地分支与远程库分支的基础上，可以将最新的提交从远程库相应的分支上抓取下来：\n\n  > `git pull` \n\n  如果`git pull` 的时候出现冲突，则需要[解决冲突](#conflict-solve) 。\n\n- 本地分支，若不推送到远程，只有本地可见。\n\n### 4 标签（Tag）\n\n版本发布的时候，为了今后方便查找，一般会使用标签的方式，采用有意义的文字标记当前版本，即可以将标签当作版本库的一个快照，本质上标签就是一个指向某一次`commit` 的指针，类似于分支指针（但是分支指针可以移动，标签指针不可以移动）。\n\n- `git tag` ，查看所有标签；\n- `git tag <name>` ，为当前分支生成一个标签，标签默认标记在最新的提交上；\n- `git tag <name> <commit_id>` ，若想为历史的某一次提交生成标签，则找到该提交的`commit_id` 即可；\n- `git tag -a <tagname> -m \"注释信息\" <commit_id>` ，创建标签并生成注释；\n- `git show <tagname>` ，查看相应的标签信息；\n\n**注** ：标签是按照字母顺序排序的，而不是按照时间排序。\n\n- `git tag -d <tagname>` ，删除本地标签；\n\n- `git push origin <tagname>` ，将标签推送到远程仓库中；\n\n- `git push origin --tags` ，一次性地将本地标签全部推送到远程库中；\n\n- 若想要删除的标签已经被推送到了远程库中，那么需要两步才能删除标签：\n\n  >`git tag -d <tagname>` #首先，本地删除\n  >\n  >`git push origin :refs/tags/<tagname>` #然后，远程删除库中的标签\n\n### 5 Github\n\n如果要参与开源项目，首先将开源项目`Fork` 到自己的仓库中，然后**从自己的仓库中`Clone` **，只有这样才能在本地修改之后，再次推送到Github上，若希望开源项目的官方接受自己的修改，则需要在Github上发起`Pull Request` 。\n\n### 6 .gitignore\n\n.gitignore文件中的文件名将会在提交的时候被忽略，.gitignore文件需要放在版本库中。\n\n.gitignore文件不需要从头开始编写，可以参照[官方文档](https://github.com/github/gitignore '.gitignore-doc')并进行相应的组合即可。\n\n- `git add -f <file>` ，有时候.gitignore文件中禁止提交的文件类型中，有你希望提交的一份文件，则可以通过上述命令强行添加并提交；\n- `git check-ignore -v <file>` ，当发现一个文件无法添加和提交时，需要检查.gitignore文件中哪一条规则写错了，可以使用上述命令进行检查。\n\n### 7 Git配置\n\n- 当前仓库的配置文档存放在`.git/config` 文件中；\n- 当前用户的配置文档存放在用户主目录下的隐藏文件`.gitignore` 中；\n- `git config --global alias. <short-command> <origin-command>` ，配置别名，简化使用。\n\n### 8 Git服务器搭建\n\n服务器系统采用Linux，推荐Ubuntu或者Debian，以下操作需要sudo权限。\n\n1. 安装Git:\n\n   `sudo apt-get install git` \n\n2. 创建Git用户，用于运行Git服务：\n\n   `sudo adduser git` \n\n3. 添加公钥，保证用户的登录：\n\n   收集所有需要登录服务器的用户的公钥，即`id_rsa.pub` 文件的内容，将公钥添加进服务器的`/home/git/.ssh/authorized_keys` 文件中，一行一个。\n\n4. 初始化Git仓库：\n\n   选定一个目录作为Git仓库，例如`/git/git-server.git` ，在目录`/git` 下执行命令：\n\n   `sudo git init --bare git-server.git` \n\n   创建的是裸仓库，即没有工作区，服务器的目的是为了共享，而不允许用户登录到服务器上去修改，然后将Git仓库的所有者更改为之前添加的用户git：\n\n   `sudo chown -R git:git git-server.git` \n\n5. 禁用shell登录：\n\n   即禁止之前创建的用户git登录shell，可以通过编辑`/etc/passwd` 文件完成，将以下一行\n\n   `git:x:1001:1001:,,,:/home/git:/bin/bash` \n\n   改为\n\n   `git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell` \n\n   意思就是，用户`git` 每次一登录shell就会自动退出，即无法登录shell进行其他操作，这么做的目的是，让`git` 用户可以正常通过ssh使用git，但禁止其登录shell。\n\n6. 远程Git仓库已经建立好了，其他客户端用户可以使用`git clone` 将服务器上的内容克隆到本地进行修改：\n\n   `git clone git@server:/git/git-server.git` \n\n   修改完成之后，就是推送与共享了。","slug":"git-study","published":1,"updated":"2017-04-02T09:26:43.894Z","_id":"cj0x6gze10005kkupar21ksrk","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"0-Git-Introduction\"><a href=\"#0-Git-Introduction\" class=\"headerlink\" title=\"0 Git Introduction\"></a>0 Git Introduction</h3><p>Git是一种开源的分布式版本管理系统。</p>\n<p>每台安装了Git的机器上都会维持一个Git的本地仓库。</p>\n<h3 id=\"1-本地版本库的创建与管理\"><a href=\"#1-本地版本库的创建与管理\" class=\"headerlink\" title=\"1 本地版本库的创建与管理\"></a>1 本地版本库的创建与管理</h3><h4 id=\"1-1-创建与文件提交\"><a href=\"#1-1-创建与文件提交\" class=\"headerlink\" title=\"1.1 创建与文件提交\"></a>1.1 创建与文件提交</h4><ul>\n<li>初始化一个Git仓库：<code>git init</code>；</li>\n<li>添加文件到Git仓库（<a href=\"#gitadd-principle\">背后的原理</a>）:<ol>\n<li><code>git add &lt;file&gt;</code> ，可以使用多次，添加多个文件；</li>\n<li><code>git commit -m &quot;提交说明文字&quot;</code> ，完成一次提交。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"1-2-查看仓库状态\"><a href=\"#1-2-查看仓库状态\" class=\"headerlink\" title=\"1.2 查看仓库状态\"></a>1.2 查看仓库状态</h4><ul>\n<li><code>git status</code> ，查看本地仓库的<a href=\"#workplace\">工作区</a>状态，命令会告诉我们，当前有哪些文件被修改了，现在的状态是”没有添加任何文件“OR”已添加待提交“，此外还会对后续操作提示相应的命令；</li>\n<li><code>git diff</code> ， 如果有文件被修改了，可以用该命令查看具体的修改内容（有”-“号的一行说明有删减，有“+”的一行说明有增加）。</li>\n</ul>\n<h4 id=\"1-2-版本回退与回退的撤销\"><a href=\"#1-2-版本回退与回退的撤销\" class=\"headerlink\" title=\"1.2 版本回退与回退的撤销\"></a>1.2 版本回退与回退的撤销</h4><ul>\n<li><p><code>git log</code> ，查看提交的历史记录，以便确定回退到哪一个版本，精简输出可以使用<code>git log --pretty=oneline</code>；<span id=\"versionback\"></span></p>\n</li>\n<li><p><code>git reflog</code> ，查看命令的历史记录，可以用于确定版本回退之前的最新版本号<code>commit_id</code> ；</p>\n</li>\n<li><p><code>git reset --hard &lt;commit_id&gt;</code> ，<code>commit_id</code> 是版本号，是SHA1计算得出的十六进制数字，每提交一次就会新生成一个<code>commit_id</code> ，版本号没有必要每次都输入完整，保证前几位不同就可以。此外，<code>HEAD</code> 表示当前版本号，<code>HEAD^</code> 表示上一个版本号，以此类推，<code>HEAD~100</code> 表示上100个版本号。</p>\n<p><strong>注意</strong> ：对于只有一个版本的版本库是无法再回退到上一个状态（即最初初始化的状态）</p>\n</li>\n</ul>\n<h4 id=\"1-4-工作区与暂存区\"><a href=\"#1-4-工作区与暂存区\" class=\"headerlink\" title=\"1.4 工作区与暂存区\"></a>1.4 工作区与暂存区</h4><ul>\n<li><p><span id=\"workplace\">工作区（Working Directory）</span></p>\n<p>也就是当时使用<code>git init</code> 初始化的本地仓库的目录/文件夹。</p>\n</li>\n<li><p>版本库（Repository）</p>\n<p>工作区内的隐藏目录<code>.git</code> ，这个目录不算工作区，而是属于版本库。版本库中最重要的部分是暂存区（stage/index）这也是Git与SVN不同之处，同时还有Git自动创建的第一个<a href=\"#branch\">分支</a><code>master</code> 和指向<code>master</code> 的<a href=\"#pointer-HEAD\">指针<code>HEAD</code></a> 。</p>\n</li>\n<li><p>工作区与暂存区的关系</p>\n<p>这里通过<code>git add &lt;file&gt;</code> 的<span id=\"gitadd-principle\">工作原理</span>来解释一下工作区与暂存区之间的关系。</p>\n<ol>\n<li><p><code>git add</code> 添加的时候，实际上是将文件或者文件的修改添加到暂存区中；</p>\n</li>\n<li><p><code>git commit</code> 提交文件或文件修改，实际上是将暂存区的所有内容提交到当前分支中。</p>\n<p><strong>注意</strong>：</p>\n<ul>\n<li><p>提交之后，工作区就没有任何新的修改，暂存区也没有任何内容，同时产生了新的版本。</p>\n</li>\n<li><p>提交的时候，Git只负责将已经加入暂存区的修改内容提交到分支中，即若<code>git add</code> 之后再对文件进行修改，那么此时修改的内容是不会提交到分支中的。</p>\n<p><code>git diff HEAD -- &lt;file&gt;</code> ，可以用于查看工作区与版本库中最新版本之间的区别。</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"1-5-管理与修改、删除\"><a href=\"#1-5-管理与修改、删除\" class=\"headerlink\" title=\"1.5 管理与修改、删除\"></a>1.5 管理与修改、删除</h4><p>Git跟踪并管理的是<strong>文件的修改部分</strong> ,而非整个文件。</p>\n<p>所以，如果修改没有从工作区添加到暂存区，那么这些修改就无法被提交到版本库的最新版本中。</p>\n<ul>\n<li><p><code>git checkout -- &lt;file&gt;</code> ，直接放弃对工作区的所有修改，这比一行一行的恢复更省力气，有时候对于不知道修改了哪部分内容的情况也很有用。</p>\n</li>\n<li><p><code>git rm --cached &lt;file&gt;</code> ，将添加到暂存区的修改撤销（unstage），并将修改重新放回工作区，如果此时仍想撤销所有的修改，则执行命令<code>git checkout -- &lt;file&gt;</code> ；</p>\n</li>\n<li><p>如果已经向本地版本库提交了不合适的修改并想要撤销时，需要<a href=\"#versionback\">版本回退</a>操作，前提是还没有推送到远程仓库。</p>\n</li>\n<li><p>若要删除<span id=\"local-delete\"></span>一个文件，需要在工作区和版本库中同时删除该文件 <code>git rm &lt;file&gt;</code> ，并在删除完成后重新提交<code>git commit -m &lt;file&gt;</code> 一次：</p>\n</li>\n<li><p>若在工作区错删了文件，则可以借助版本库，将该文件恢复到最新一次提交的状态：<code>git checkout -- &lt;file&gt;</code> <em>（当然，如果回收站还没清空的话，也可以去回收站看看）</em>；</p>\n</li>\n<li><p><strong>注</strong> ：<code>git checkout</code> 的原理是，利用版本库中的最新版本替换工作区的版本。</p>\n</li>\n</ul>\n<h3 id=\"2-远程仓库\"><a href=\"#2-远程仓库\" class=\"headerlink\" title=\"2 远程仓库\"></a>2 远程仓库</h3><p>可以自己搭建Git服务器作为远程仓库，也可以使用Github的免费仓库（但是是公开的所有人可见的）。</p>\n<p>一台电脑上也可以建立多个版本库，只要不在同一目录中即可。</p>\n<p>Git支持SSH协议。</p>\n<h4 id=\"2-1-添加远程库与推送Push\"><a href=\"#2-1-添加远程库与推送Push\" class=\"headerlink\" title=\"2.1 添加远程库与推送Push\"></a>2.1 添加远程库与推送Push</h4><p>在完成Github注册和SSH Key添加之后，就可以在Github上创建一个新的Git仓库，然后根据相应的提示，将本地仓库的文件推送（Push）到远程仓库中。</p>\n<ul>\n<li><code>git remote add origin &lt;仓库地址&gt;</code> ，在本地仓库目录下执行，将本地仓库与远程仓库进行关联，同时为远程仓库定义了新的名字<code>origin</code> ，当然也可以使用别的名字；</li>\n<li><code>git push -u origin master</code> ，将本地仓库的内容推送到远成仓库，实际上是将当前分支<code>master</code> 的内容推送到远程仓库的<code>master</code> 分支，由于刚开始远程仓库是空的，所以第一次推送的时候，需要参数<code>-u</code> ，这样在推送的同时，还会建立起本地分支<code>master</code> 和远程仓库中<code>master</code> 分支的联系，以后推送和拉取内容就可以简化命令，即<code>git push origin master</code> 和<code>git pull</code> 。</li>\n</ul>\n<h4 id=\"2-2-从远程库克隆Clone\"><a href=\"#2-2-从远程库克隆Clone\" class=\"headerlink\" title=\"2.2 从远程库克隆Clone\"></a>2.2 从远程库克隆Clone</h4><ul>\n<li><p><code>git clone https://github.com/zouguijin/docSync.git</code> </p>\n</li>\n<li><p><code>git clone git@github.com:zouguijin/docSync.git</code> </p>\n<p>Git支持多种协议，默认的git（所使用的是ssh协议），此外还可以使用https协议（但是https协议有时候比较慢，而且每次推送都需要输入口令，使用ssh就不需要输入口令，<code>get clone</code> 的时候都要口令…）。</p>\n</li>\n</ul>\n<h4 id=\"2-3-远程仓库文件的删除\"><a href=\"#2-3-远程仓库文件的删除\" class=\"headerlink\" title=\"2.3 远程仓库文件的删除\"></a>2.3 远程仓库文件的删除</h4><p>在<a href=\"#local-delete\">管理与修改、删除</a> 部分，讲述了本地工作区和本地仓库文件的删除方法。若希望删除远程库中的文件，需要：</p>\n<ol>\n<li><p>进入与远程库相对应的本地仓库，切换到相应的分支，或者建立本地分支与远程分支的连接，然后通过<code>git pull</code> 将远程库的内容抓取到本地库中；</p>\n</li>\n<li><p>将不需要的内容在本地仓库中删除，然后再次添加<code>git add .</code> ，提交<code>git commit -m &quot;...&quot;</code> ，并最后推送到远程仓库覆盖原内容即可<code>git push origin branch</code> 。</p>\n<p><strong>注</strong> ：如果上一个提交者不是当前机器，则不能直接在本地修改然后推送，会出现冲突，否则可以直接修改并推送。</p>\n</li>\n</ol>\n<h3 id=\"3-分支（Branch）\"><a href=\"#3-分支（Branch）\" class=\"headerlink\" title=\"3 分支（Branch）\"></a>3 分支（Branch）</h3><p>创建属于自己的分支，其他人是看不到的，一个未完成的项目可以在分支上不断更新，直到完成之后再一次提交到<code>master</code> 主分支上。</p>\n<h4 id=\"3-1-创建与合并\"><a href=\"#3-1-创建与合并\" class=\"headerlink\" title=\"3.1 创建与合并\"></a>3.1 创建与合并</h4><ul>\n<li><p>原理：</p>\n<p>一个分支就是一条时间线，随着不断地提交逐渐变长。最初只有主分支即<code>master</code> 分支，同时有一个<code>master</code> 指针指向主分支的最新提交，之前说的指针<code>HEAD</code> 指向的是指针<code>master</code> ，而不是指向最新提交。即：</p>\n<blockquote>\n<p><code>HEAD</code> -&gt; <code>master</code> -&gt; <code>最新提交</code> </p>\n</blockquote>\n<p>每次提交之后，<code>master</code> 分支都会向前延长，同时指针<code>master</code> 都会指向最新的提交，指针<code>HEAD</code> 的指向不变。</p>\n<p>创建新的分支，例如<code>branch</code> 时，即创建新的指针<code>branch</code> ，指向与<code>master</code> 相同的提交，此时若将指针<code>HEAD</code> 指向<code>branch</code> ，则表示切换当前分支，由主分支切换到<code>branch</code> 分支。</p>\n<blockquote>\n<p><code>master</code> -&gt;<code>最新提交</code> &lt;- <code>branch</code> &lt;- <code>HEAD</code>  </p>\n</blockquote>\n<p>如果在<code>branch</code> 分支下提交新的修改，那么<code>branch</code> 分支就会向前延长，指针<code>branch</code> 指向最新提交，但此时指针<code>master</code> 保持切换前的指向位置不变。</p>\n<p>合并分支，也就是将主分支的<code>master</code> 指针指向<code>branch</code> 指针所指向的最新提交即可，合并分支后，一般都会将工作时使用的新分支<code>branch</code> 删除，即删除<code>branch</code> 指针。</p>\n<p><strong>注</strong> ：可见，所谓创建分支，只是创建了一个指针，切换、合并分支，只是改变了指针的指向，删除分支，只是将对应的指针删除，所有的操作都不涉及内容的改变。</p>\n</li>\n<li><p>命令操作</p>\n<ul>\n<li><code>git branch</code> ，查看分支情况，当前分支前会用<code>*</code> 标记；</li>\n<li><code>git branch &lt;name&gt;</code> ，创建分支；</li>\n<li><code>git checkout &lt;name&gt;</code> ，切换分支，由当前分支切换到指定命名分支；</li>\n<li><code>git checkout -b &lt;name&gt;</code> ，创建&amp;切换分支；</li>\n<li><code>git merge &lt;name&gt;</code> ，合并分支，将指定命名分支合并到当前分支上；（默认使用<code>Fast Forward</code> 模式，该模式下删除分支后，分支信息也随之删除，即看不到历史合并信息；若希望能看到历史合并信息，就需要禁用FF模式，并最好添加注释信息，即<code>git merge --no-ff -m &quot;注释信息&quot; &lt;name&gt;</code>）</li>\n<li><code>git branch -d &lt;name&gt;</code> ，删除指定命名分支。</li>\n</ul>\n</li>\n<li><p>合并冲突<span id=\"conflict-solve\"></span></p>\n<p>如果两个需要合并的分支各自都有新的提交，而且两者的提交在同一位置有不同的表述，在合并的时候就会出现冲突，即不能简单地删除、添加或者替换。</p>\n<p>冲突出现的时候，在显示分支的括号中会多出<code>|MERGING</code> 字样，表示此时必须解决合并冲突，分支切换操作被禁止，这时需要利用<code>git diff</code> 查看文件内容，并手动修改冲突的内容，然后重新添加和提交即可。（Git会用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容）</p>\n<p><code>git log --graph</code> 可以看到分支的合并情况，或者简化版<code>git log --graph --pretty=oneline --abbrev-commit</code> 。</p>\n</li>\n<li><p>分支管理策略</p>\n<ul>\n<li>保证主分支<code>master</code> 是稳定的，仅仅用于发布公开的、可以使用的新版本；</li>\n<li>如果团队合作的话，需要新建一个团队开发提交的分支，例如<code>dev</code> 分支，平时的提交与合并都在该分支上完成，一个完整的版本完成之后再将<code>dev</code> 分支合并到主分支上。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-2-Bug分支\"><a href=\"#3-2-Bug分支\" class=\"headerlink\" title=\"3.2 Bug分支\"></a>3.2 Bug分支</h4><p>当遇到Bug的时候，可以切换到需要修复Bug的分支上，在该分支上创建临时的Bug分支，在临时分支上修复Bug，然后合并原分支上，最后删除临时分支即可。</p>\n<p>此时，如果手头上的工作没有做完（工作区有正在修改的内容，如果将Bug修复完成之后就添加、提交，那么之前正在处理但未处理完成的工作就会和修复的Bug一起添加并提交上去，这是我们不想看见的），那么这时候就需要将未完成的工作<strong>先拿出工作区并暂存</strong>起来：</p>\n<blockquote>\n<p><code>git stash</code> </p>\n</blockquote>\n<p>此时，利用<code>git status</code> 查看工作区，会看见工作区是干净的。</p>\n<p>完成Bug修复之后，可以再将之前的工作取出来放进工作区继续完成：</p>\n<ul>\n<li><code>git stash list</code> ，若有多个工作，可以先查看列表，再决定需要恢复哪个工作；</li>\n<li><code>git stash apply</code> ，恢复工作之后，暂存的内容并不会自动删除，需要使用<code>git stash drop</code> 将相应的内容删除；</li>\n<li><code>git stash pop</code> ，推荐使用，恢复工作的同时，可以将暂存的内容也删除；</li>\n<li>若要指定恢复或者删除哪一条<code>stash</code> ，可以添加后续命令<code>stash@{x}</code> ，<code>x</code> 可以从<code>stash</code> 列表中选取。</li>\n</ul>\n<h4 id=\"3-3-Feature分支\"><a href=\"#3-3-Feature分支\" class=\"headerlink\" title=\"3.3 Feature分支\"></a>3.3 Feature分支</h4><p>为项目开发一个新的功能时，最好在项目分支上新建一个分支，功能完成之后再将新功能的代码合并到项目分支中。</p>\n<p>如果在合并之前，需要放弃该功能分支，则需要通过强行删除的操作完成：</p>\n<blockquote>\n<p><code>git branch -D &lt;name&gt;</code></p>\n</blockquote>\n<h4 id=\"3-4-推送与抓取\"><a href=\"#3-4-推送与抓取\" class=\"headerlink\" title=\"3.4 推送与抓取\"></a>3.4 推送与抓取</h4><ul>\n<li><p><code>git remote -v</code> ，查看远程库的信息，会给出本地可以抓取和推送的远程库的地址以及远程库的命名（默认是<code>origin</code>）；</p>\n</li>\n<li><p><code>git push origin &lt;name&gt;</code> ，推送分支，即将指定分支上的所有本地内容推送到远程仓库中的<strong>相对应</strong>的分支上，可以推送本地<code>master</code> 分支内容，也可以推送其他分支的内容；</p>\n</li>\n<li><p><code>git clone &lt;git/https&gt;</code> ，其他用户从远程库克隆的时候，默认情况下只能看到<code>master</code> 分支（当然其他分支也随之克隆下来了，只是不稍微调整是看不到的），前面说了，一般不会直接向<code>master</code> 分支推送修改，所以需要在本地创建远程仓库<code>origin</code> 的分支<code>branch</code> （这里的<code>branch</code> 需要与远程仓库的<code>branch</code> 同名）：</p>\n<blockquote>\n<p><code>git checkout -b branch origin/branch</code> </p>\n</blockquote>\n<p>只有这样，才能建立本地与远成仓库的联系，之后的抓取<code>git pull</code> 和推送<code>git push origin branch</code> 才可以进行。</p>\n</li>\n<li><p><code>git pull</code> ，抓取分支，首先需要建立本地分支与远程仓库相应分支之间的链接：</p>\n<blockquote>\n<p><code>git branch --set-upstream branch origin/branch</code> </p>\n</blockquote>\n<p>在之前建立本地分支与远程库分支的基础上，可以将最新的提交从远程库相应的分支上抓取下来：</p>\n<blockquote>\n<p><code>git pull</code> </p>\n</blockquote>\n<p>如果<code>git pull</code> 的时候出现冲突，则需要<a href=\"#conflict-solve\">解决冲突</a> 。</p>\n</li>\n<li><p>本地分支，若不推送到远程，只有本地可见。</p>\n</li>\n</ul>\n<h3 id=\"4-标签（Tag）\"><a href=\"#4-标签（Tag）\" class=\"headerlink\" title=\"4 标签（Tag）\"></a>4 标签（Tag）</h3><p>版本发布的时候，为了今后方便查找，一般会使用标签的方式，采用有意义的文字标记当前版本，即可以将标签当作版本库的一个快照，本质上标签就是一个指向某一次<code>commit</code> 的指针，类似于分支指针（但是分支指针可以移动，标签指针不可以移动）。</p>\n<ul>\n<li><code>git tag</code> ，查看所有标签；</li>\n<li><code>git tag &lt;name&gt;</code> ，为当前分支生成一个标签，标签默认标记在最新的提交上；</li>\n<li><code>git tag &lt;name&gt; &lt;commit_id&gt;</code> ，若想为历史的某一次提交生成标签，则找到该提交的<code>commit_id</code> 即可；</li>\n<li><code>git tag -a &lt;tagname&gt; -m &quot;注释信息&quot; &lt;commit_id&gt;</code> ，创建标签并生成注释；</li>\n<li><code>git show &lt;tagname&gt;</code> ，查看相应的标签信息；</li>\n</ul>\n<p><strong>注</strong> ：标签是按照字母顺序排序的，而不是按照时间排序。</p>\n<ul>\n<li><p><code>git tag -d &lt;tagname&gt;</code> ，删除本地标签；</p>\n</li>\n<li><p><code>git push origin &lt;tagname&gt;</code> ，将标签推送到远程仓库中；</p>\n</li>\n<li><p><code>git push origin --tags</code> ，一次性地将本地标签全部推送到远程库中；</p>\n</li>\n<li><p>若想要删除的标签已经被推送到了远程库中，那么需要两步才能删除标签：</p>\n<blockquote>\n<p><code>git tag -d &lt;tagname&gt;</code> #首先，本地删除</p>\n<p><code>git push origin :refs/tags/&lt;tagname&gt;</code> #然后，远程删除库中的标签</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"5-Github\"><a href=\"#5-Github\" class=\"headerlink\" title=\"5 Github\"></a>5 Github</h3><p>如果要参与开源项目，首先将开源项目<code>Fork</code> 到自己的仓库中，然后<strong>从自己的仓库中<code>Clone</code> </strong>，只有这样才能在本地修改之后，再次推送到Github上，若希望开源项目的官方接受自己的修改，则需要在Github上发起<code>Pull Request</code> 。</p>\n<h3 id=\"6-gitignore\"><a href=\"#6-gitignore\" class=\"headerlink\" title=\"6 .gitignore\"></a>6 .gitignore</h3><p>.gitignore文件中的文件名将会在提交的时候被忽略，.gitignore文件需要放在版本库中。</p>\n<p>.gitignore文件不需要从头开始编写，可以参照<a href=\"https://github.com/github/gitignore\" title=\".gitignore-doc\" target=\"_blank\" rel=\"external\">官方文档</a>并进行相应的组合即可。</p>\n<ul>\n<li><code>git add -f &lt;file&gt;</code> ，有时候.gitignore文件中禁止提交的文件类型中，有你希望提交的一份文件，则可以通过上述命令强行添加并提交；</li>\n<li><code>git check-ignore -v &lt;file&gt;</code> ，当发现一个文件无法添加和提交时，需要检查.gitignore文件中哪一条规则写错了，可以使用上述命令进行检查。</li>\n</ul>\n<h3 id=\"7-Git配置\"><a href=\"#7-Git配置\" class=\"headerlink\" title=\"7 Git配置\"></a>7 Git配置</h3><ul>\n<li>当前仓库的配置文档存放在<code>.git/config</code> 文件中；</li>\n<li>当前用户的配置文档存放在用户主目录下的隐藏文件<code>.gitignore</code> 中；</li>\n<li><code>git config --global alias. &lt;short-command&gt; &lt;origin-command&gt;</code> ，配置别名，简化使用。</li>\n</ul>\n<h3 id=\"8-Git服务器搭建\"><a href=\"#8-Git服务器搭建\" class=\"headerlink\" title=\"8 Git服务器搭建\"></a>8 Git服务器搭建</h3><p>服务器系统采用Linux，推荐Ubuntu或者Debian，以下操作需要sudo权限。</p>\n<ol>\n<li><p>安装Git:</p>\n<p><code>sudo apt-get install git</code> </p>\n</li>\n<li><p>创建Git用户，用于运行Git服务：</p>\n<p><code>sudo adduser git</code> </p>\n</li>\n<li><p>添加公钥，保证用户的登录：</p>\n<p>收集所有需要登录服务器的用户的公钥，即<code>id_rsa.pub</code> 文件的内容，将公钥添加进服务器的<code>/home/git/.ssh/authorized_keys</code> 文件中，一行一个。</p>\n</li>\n<li><p>初始化Git仓库：</p>\n<p>选定一个目录作为Git仓库，例如<code>/git/git-server.git</code> ，在目录<code>/git</code> 下执行命令：</p>\n<p><code>sudo git init --bare git-server.git</code> </p>\n<p>创建的是裸仓库，即没有工作区，服务器的目的是为了共享，而不允许用户登录到服务器上去修改，然后将Git仓库的所有者更改为之前添加的用户git：</p>\n<p><code>sudo chown -R git:git git-server.git</code> </p>\n</li>\n<li><p>禁用shell登录：</p>\n<p>即禁止之前创建的用户git登录shell，可以通过编辑<code>/etc/passwd</code> 文件完成，将以下一行</p>\n<p><code>git:x:1001:1001:,,,:/home/git:/bin/bash</code> </p>\n<p>改为</p>\n<p><code>git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</code> </p>\n<p>意思就是，用户<code>git</code> 每次一登录shell就会自动退出，即无法登录shell进行其他操作，这么做的目的是，让<code>git</code> 用户可以正常通过ssh使用git，但禁止其登录shell。</p>\n</li>\n<li><p>远程Git仓库已经建立好了，其他客户端用户可以使用<code>git clone</code> 将服务器上的内容克隆到本地进行修改：</p>\n<p><code>git clone git@server:/git/git-server.git</code> </p>\n<p>修改完成之后，就是推送与共享了。</p>\n</li>\n</ol>\n","excerpt":"","more":"<h3 id=\"0-Git-Introduction\"><a href=\"#0-Git-Introduction\" class=\"headerlink\" title=\"0 Git Introduction\"></a>0 Git Introduction</h3><p>Git是一种开源的分布式版本管理系统。</p>\n<p>每台安装了Git的机器上都会维持一个Git的本地仓库。</p>\n<h3 id=\"1-本地版本库的创建与管理\"><a href=\"#1-本地版本库的创建与管理\" class=\"headerlink\" title=\"1 本地版本库的创建与管理\"></a>1 本地版本库的创建与管理</h3><h4 id=\"1-1-创建与文件提交\"><a href=\"#1-1-创建与文件提交\" class=\"headerlink\" title=\"1.1 创建与文件提交\"></a>1.1 创建与文件提交</h4><ul>\n<li>初始化一个Git仓库：<code>git init</code>；</li>\n<li>添加文件到Git仓库（<a href=\"#gitadd-principle\">背后的原理</a>）:<ol>\n<li><code>git add &lt;file&gt;</code> ，可以使用多次，添加多个文件；</li>\n<li><code>git commit -m &quot;提交说明文字&quot;</code> ，完成一次提交。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"1-2-查看仓库状态\"><a href=\"#1-2-查看仓库状态\" class=\"headerlink\" title=\"1.2 查看仓库状态\"></a>1.2 查看仓库状态</h4><ul>\n<li><code>git status</code> ，查看本地仓库的<a href=\"#workplace\">工作区</a>状态，命令会告诉我们，当前有哪些文件被修改了，现在的状态是”没有添加任何文件“OR”已添加待提交“，此外还会对后续操作提示相应的命令；</li>\n<li><code>git diff</code> ， 如果有文件被修改了，可以用该命令查看具体的修改内容（有”-“号的一行说明有删减，有“+”的一行说明有增加）。</li>\n</ul>\n<h4 id=\"1-2-版本回退与回退的撤销\"><a href=\"#1-2-版本回退与回退的撤销\" class=\"headerlink\" title=\"1.2 版本回退与回退的撤销\"></a>1.2 版本回退与回退的撤销</h4><ul>\n<li><p><code>git log</code> ，查看提交的历史记录，以便确定回退到哪一个版本，精简输出可以使用<code>git log --pretty=oneline</code>；<span id=\"versionback\"></span></p>\n</li>\n<li><p><code>git reflog</code> ，查看命令的历史记录，可以用于确定版本回退之前的最新版本号<code>commit_id</code> ；</p>\n</li>\n<li><p><code>git reset --hard &lt;commit_id&gt;</code> ，<code>commit_id</code> 是版本号，是SHA1计算得出的十六进制数字，每提交一次就会新生成一个<code>commit_id</code> ，版本号没有必要每次都输入完整，保证前几位不同就可以。此外，<code>HEAD</code> 表示当前版本号，<code>HEAD^</code> 表示上一个版本号，以此类推，<code>HEAD~100</code> 表示上100个版本号。</p>\n<p><strong>注意</strong> ：对于只有一个版本的版本库是无法再回退到上一个状态（即最初初始化的状态）</p>\n</li>\n</ul>\n<h4 id=\"1-4-工作区与暂存区\"><a href=\"#1-4-工作区与暂存区\" class=\"headerlink\" title=\"1.4 工作区与暂存区\"></a>1.4 工作区与暂存区</h4><ul>\n<li><p><span id=\"workplace\">工作区（Working Directory）</span></p>\n<p>也就是当时使用<code>git init</code> 初始化的本地仓库的目录/文件夹。</p>\n</li>\n<li><p>版本库（Repository）</p>\n<p>工作区内的隐藏目录<code>.git</code> ，这个目录不算工作区，而是属于版本库。版本库中最重要的部分是暂存区（stage/index）这也是Git与SVN不同之处，同时还有Git自动创建的第一个<a href=\"#branch\">分支</a><code>master</code> 和指向<code>master</code> 的<a href=\"#pointer-HEAD\">指针<code>HEAD</code></a> 。</p>\n</li>\n<li><p>工作区与暂存区的关系</p>\n<p>这里通过<code>git add &lt;file&gt;</code> 的<span id=\"gitadd-principle\">工作原理</span>来解释一下工作区与暂存区之间的关系。</p>\n<ol>\n<li><p><code>git add</code> 添加的时候，实际上是将文件或者文件的修改添加到暂存区中；</p>\n</li>\n<li><p><code>git commit</code> 提交文件或文件修改，实际上是将暂存区的所有内容提交到当前分支中。</p>\n<p><strong>注意</strong>：</p>\n<ul>\n<li><p>提交之后，工作区就没有任何新的修改，暂存区也没有任何内容，同时产生了新的版本。</p>\n</li>\n<li><p>提交的时候，Git只负责将已经加入暂存区的修改内容提交到分支中，即若<code>git add</code> 之后再对文件进行修改，那么此时修改的内容是不会提交到分支中的。</p>\n<p><code>git diff HEAD -- &lt;file&gt;</code> ，可以用于查看工作区与版本库中最新版本之间的区别。</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"1-5-管理与修改、删除\"><a href=\"#1-5-管理与修改、删除\" class=\"headerlink\" title=\"1.5 管理与修改、删除\"></a>1.5 管理与修改、删除</h4><p>Git跟踪并管理的是<strong>文件的修改部分</strong> ,而非整个文件。</p>\n<p>所以，如果修改没有从工作区添加到暂存区，那么这些修改就无法被提交到版本库的最新版本中。</p>\n<ul>\n<li><p><code>git checkout -- &lt;file&gt;</code> ，直接放弃对工作区的所有修改，这比一行一行的恢复更省力气，有时候对于不知道修改了哪部分内容的情况也很有用。</p>\n</li>\n<li><p><code>git rm --cached &lt;file&gt;</code> ，将添加到暂存区的修改撤销（unstage），并将修改重新放回工作区，如果此时仍想撤销所有的修改，则执行命令<code>git checkout -- &lt;file&gt;</code> ；</p>\n</li>\n<li><p>如果已经向本地版本库提交了不合适的修改并想要撤销时，需要<a href=\"#versionback\">版本回退</a>操作，前提是还没有推送到远程仓库。</p>\n</li>\n<li><p>若要删除<span id=\"local-delete\"></span>一个文件，需要在工作区和版本库中同时删除该文件 <code>git rm &lt;file&gt;</code> ，并在删除完成后重新提交<code>git commit -m &lt;file&gt;</code> 一次：</p>\n</li>\n<li><p>若在工作区错删了文件，则可以借助版本库，将该文件恢复到最新一次提交的状态：<code>git checkout -- &lt;file&gt;</code> <em>（当然，如果回收站还没清空的话，也可以去回收站看看）</em>；</p>\n</li>\n<li><p><strong>注</strong> ：<code>git checkout</code> 的原理是，利用版本库中的最新版本替换工作区的版本。</p>\n</li>\n</ul>\n<h3 id=\"2-远程仓库\"><a href=\"#2-远程仓库\" class=\"headerlink\" title=\"2 远程仓库\"></a>2 远程仓库</h3><p>可以自己搭建Git服务器作为远程仓库，也可以使用Github的免费仓库（但是是公开的所有人可见的）。</p>\n<p>一台电脑上也可以建立多个版本库，只要不在同一目录中即可。</p>\n<p>Git支持SSH协议。</p>\n<h4 id=\"2-1-添加远程库与推送Push\"><a href=\"#2-1-添加远程库与推送Push\" class=\"headerlink\" title=\"2.1 添加远程库与推送Push\"></a>2.1 添加远程库与推送Push</h4><p>在完成Github注册和SSH Key添加之后，就可以在Github上创建一个新的Git仓库，然后根据相应的提示，将本地仓库的文件推送（Push）到远程仓库中。</p>\n<ul>\n<li><code>git remote add origin &lt;仓库地址&gt;</code> ，在本地仓库目录下执行，将本地仓库与远程仓库进行关联，同时为远程仓库定义了新的名字<code>origin</code> ，当然也可以使用别的名字；</li>\n<li><code>git push -u origin master</code> ，将本地仓库的内容推送到远成仓库，实际上是将当前分支<code>master</code> 的内容推送到远程仓库的<code>master</code> 分支，由于刚开始远程仓库是空的，所以第一次推送的时候，需要参数<code>-u</code> ，这样在推送的同时，还会建立起本地分支<code>master</code> 和远程仓库中<code>master</code> 分支的联系，以后推送和拉取内容就可以简化命令，即<code>git push origin master</code> 和<code>git pull</code> 。</li>\n</ul>\n<h4 id=\"2-2-从远程库克隆Clone\"><a href=\"#2-2-从远程库克隆Clone\" class=\"headerlink\" title=\"2.2 从远程库克隆Clone\"></a>2.2 从远程库克隆Clone</h4><ul>\n<li><p><code>git clone https://github.com/zouguijin/docSync.git</code> </p>\n</li>\n<li><p><code>git clone git@github.com:zouguijin/docSync.git</code> </p>\n<p>Git支持多种协议，默认的git（所使用的是ssh协议），此外还可以使用https协议（但是https协议有时候比较慢，而且每次推送都需要输入口令，使用ssh就不需要输入口令，<code>get clone</code> 的时候都要口令…）。</p>\n</li>\n</ul>\n<h4 id=\"2-3-远程仓库文件的删除\"><a href=\"#2-3-远程仓库文件的删除\" class=\"headerlink\" title=\"2.3 远程仓库文件的删除\"></a>2.3 远程仓库文件的删除</h4><p>在<a href=\"#local-delete\">管理与修改、删除</a> 部分，讲述了本地工作区和本地仓库文件的删除方法。若希望删除远程库中的文件，需要：</p>\n<ol>\n<li><p>进入与远程库相对应的本地仓库，切换到相应的分支，或者建立本地分支与远程分支的连接，然后通过<code>git pull</code> 将远程库的内容抓取到本地库中；</p>\n</li>\n<li><p>将不需要的内容在本地仓库中删除，然后再次添加<code>git add .</code> ，提交<code>git commit -m &quot;...&quot;</code> ，并最后推送到远程仓库覆盖原内容即可<code>git push origin branch</code> 。</p>\n<p><strong>注</strong> ：如果上一个提交者不是当前机器，则不能直接在本地修改然后推送，会出现冲突，否则可以直接修改并推送。</p>\n</li>\n</ol>\n<h3 id=\"3-分支（Branch）\"><a href=\"#3-分支（Branch）\" class=\"headerlink\" title=\"3 分支（Branch）\"></a>3 分支（Branch）</h3><p>创建属于自己的分支，其他人是看不到的，一个未完成的项目可以在分支上不断更新，直到完成之后再一次提交到<code>master</code> 主分支上。</p>\n<h4 id=\"3-1-创建与合并\"><a href=\"#3-1-创建与合并\" class=\"headerlink\" title=\"3.1 创建与合并\"></a>3.1 创建与合并</h4><ul>\n<li><p>原理：</p>\n<p>一个分支就是一条时间线，随着不断地提交逐渐变长。最初只有主分支即<code>master</code> 分支，同时有一个<code>master</code> 指针指向主分支的最新提交，之前说的指针<code>HEAD</code> 指向的是指针<code>master</code> ，而不是指向最新提交。即：</p>\n<blockquote>\n<p><code>HEAD</code> -&gt; <code>master</code> -&gt; <code>最新提交</code> </p>\n</blockquote>\n<p>每次提交之后，<code>master</code> 分支都会向前延长，同时指针<code>master</code> 都会指向最新的提交，指针<code>HEAD</code> 的指向不变。</p>\n<p>创建新的分支，例如<code>branch</code> 时，即创建新的指针<code>branch</code> ，指向与<code>master</code> 相同的提交，此时若将指针<code>HEAD</code> 指向<code>branch</code> ，则表示切换当前分支，由主分支切换到<code>branch</code> 分支。</p>\n<blockquote>\n<p><code>master</code> -&gt;<code>最新提交</code> &lt;- <code>branch</code> &lt;- <code>HEAD</code>  </p>\n</blockquote>\n<p>如果在<code>branch</code> 分支下提交新的修改，那么<code>branch</code> 分支就会向前延长，指针<code>branch</code> 指向最新提交，但此时指针<code>master</code> 保持切换前的指向位置不变。</p>\n<p>合并分支，也就是将主分支的<code>master</code> 指针指向<code>branch</code> 指针所指向的最新提交即可，合并分支后，一般都会将工作时使用的新分支<code>branch</code> 删除，即删除<code>branch</code> 指针。</p>\n<p><strong>注</strong> ：可见，所谓创建分支，只是创建了一个指针，切换、合并分支，只是改变了指针的指向，删除分支，只是将对应的指针删除，所有的操作都不涉及内容的改变。</p>\n</li>\n<li><p>命令操作</p>\n<ul>\n<li><code>git branch</code> ，查看分支情况，当前分支前会用<code>*</code> 标记；</li>\n<li><code>git branch &lt;name&gt;</code> ，创建分支；</li>\n<li><code>git checkout &lt;name&gt;</code> ，切换分支，由当前分支切换到指定命名分支；</li>\n<li><code>git checkout -b &lt;name&gt;</code> ，创建&amp;切换分支；</li>\n<li><code>git merge &lt;name&gt;</code> ，合并分支，将指定命名分支合并到当前分支上；（默认使用<code>Fast Forward</code> 模式，该模式下删除分支后，分支信息也随之删除，即看不到历史合并信息；若希望能看到历史合并信息，就需要禁用FF模式，并最好添加注释信息，即<code>git merge --no-ff -m &quot;注释信息&quot; &lt;name&gt;</code>）</li>\n<li><code>git branch -d &lt;name&gt;</code> ，删除指定命名分支。</li>\n</ul>\n</li>\n<li><p>合并冲突<span id=\"conflict-solve\"></span></p>\n<p>如果两个需要合并的分支各自都有新的提交，而且两者的提交在同一位置有不同的表述，在合并的时候就会出现冲突，即不能简单地删除、添加或者替换。</p>\n<p>冲突出现的时候，在显示分支的括号中会多出<code>|MERGING</code> 字样，表示此时必须解决合并冲突，分支切换操作被禁止，这时需要利用<code>git diff</code> 查看文件内容，并手动修改冲突的内容，然后重新添加和提交即可。（Git会用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容）</p>\n<p><code>git log --graph</code> 可以看到分支的合并情况，或者简化版<code>git log --graph --pretty=oneline --abbrev-commit</code> 。</p>\n</li>\n<li><p>分支管理策略</p>\n<ul>\n<li>保证主分支<code>master</code> 是稳定的，仅仅用于发布公开的、可以使用的新版本；</li>\n<li>如果团队合作的话，需要新建一个团队开发提交的分支，例如<code>dev</code> 分支，平时的提交与合并都在该分支上完成，一个完整的版本完成之后再将<code>dev</code> 分支合并到主分支上。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-2-Bug分支\"><a href=\"#3-2-Bug分支\" class=\"headerlink\" title=\"3.2 Bug分支\"></a>3.2 Bug分支</h4><p>当遇到Bug的时候，可以切换到需要修复Bug的分支上，在该分支上创建临时的Bug分支，在临时分支上修复Bug，然后合并原分支上，最后删除临时分支即可。</p>\n<p>此时，如果手头上的工作没有做完（工作区有正在修改的内容，如果将Bug修复完成之后就添加、提交，那么之前正在处理但未处理完成的工作就会和修复的Bug一起添加并提交上去，这是我们不想看见的），那么这时候就需要将未完成的工作<strong>先拿出工作区并暂存</strong>起来：</p>\n<blockquote>\n<p><code>git stash</code> </p>\n</blockquote>\n<p>此时，利用<code>git status</code> 查看工作区，会看见工作区是干净的。</p>\n<p>完成Bug修复之后，可以再将之前的工作取出来放进工作区继续完成：</p>\n<ul>\n<li><code>git stash list</code> ，若有多个工作，可以先查看列表，再决定需要恢复哪个工作；</li>\n<li><code>git stash apply</code> ，恢复工作之后，暂存的内容并不会自动删除，需要使用<code>git stash drop</code> 将相应的内容删除；</li>\n<li><code>git stash pop</code> ，推荐使用，恢复工作的同时，可以将暂存的内容也删除；</li>\n<li>若要指定恢复或者删除哪一条<code>stash</code> ，可以添加后续命令<code>stash@{x}</code> ，<code>x</code> 可以从<code>stash</code> 列表中选取。</li>\n</ul>\n<h4 id=\"3-3-Feature分支\"><a href=\"#3-3-Feature分支\" class=\"headerlink\" title=\"3.3 Feature分支\"></a>3.3 Feature分支</h4><p>为项目开发一个新的功能时，最好在项目分支上新建一个分支，功能完成之后再将新功能的代码合并到项目分支中。</p>\n<p>如果在合并之前，需要放弃该功能分支，则需要通过强行删除的操作完成：</p>\n<blockquote>\n<p><code>git branch -D &lt;name&gt;</code></p>\n</blockquote>\n<h4 id=\"3-4-推送与抓取\"><a href=\"#3-4-推送与抓取\" class=\"headerlink\" title=\"3.4 推送与抓取\"></a>3.4 推送与抓取</h4><ul>\n<li><p><code>git remote -v</code> ，查看远程库的信息，会给出本地可以抓取和推送的远程库的地址以及远程库的命名（默认是<code>origin</code>）；</p>\n</li>\n<li><p><code>git push origin &lt;name&gt;</code> ，推送分支，即将指定分支上的所有本地内容推送到远程仓库中的<strong>相对应</strong>的分支上，可以推送本地<code>master</code> 分支内容，也可以推送其他分支的内容；</p>\n</li>\n<li><p><code>git clone &lt;git/https&gt;</code> ，其他用户从远程库克隆的时候，默认情况下只能看到<code>master</code> 分支（当然其他分支也随之克隆下来了，只是不稍微调整是看不到的），前面说了，一般不会直接向<code>master</code> 分支推送修改，所以需要在本地创建远程仓库<code>origin</code> 的分支<code>branch</code> （这里的<code>branch</code> 需要与远程仓库的<code>branch</code> 同名）：</p>\n<blockquote>\n<p><code>git checkout -b branch origin/branch</code> </p>\n</blockquote>\n<p>只有这样，才能建立本地与远成仓库的联系，之后的抓取<code>git pull</code> 和推送<code>git push origin branch</code> 才可以进行。</p>\n</li>\n<li><p><code>git pull</code> ，抓取分支，首先需要建立本地分支与远程仓库相应分支之间的链接：</p>\n<blockquote>\n<p><code>git branch --set-upstream branch origin/branch</code> </p>\n</blockquote>\n<p>在之前建立本地分支与远程库分支的基础上，可以将最新的提交从远程库相应的分支上抓取下来：</p>\n<blockquote>\n<p><code>git pull</code> </p>\n</blockquote>\n<p>如果<code>git pull</code> 的时候出现冲突，则需要<a href=\"#conflict-solve\">解决冲突</a> 。</p>\n</li>\n<li><p>本地分支，若不推送到远程，只有本地可见。</p>\n</li>\n</ul>\n<h3 id=\"4-标签（Tag）\"><a href=\"#4-标签（Tag）\" class=\"headerlink\" title=\"4 标签（Tag）\"></a>4 标签（Tag）</h3><p>版本发布的时候，为了今后方便查找，一般会使用标签的方式，采用有意义的文字标记当前版本，即可以将标签当作版本库的一个快照，本质上标签就是一个指向某一次<code>commit</code> 的指针，类似于分支指针（但是分支指针可以移动，标签指针不可以移动）。</p>\n<ul>\n<li><code>git tag</code> ，查看所有标签；</li>\n<li><code>git tag &lt;name&gt;</code> ，为当前分支生成一个标签，标签默认标记在最新的提交上；</li>\n<li><code>git tag &lt;name&gt; &lt;commit_id&gt;</code> ，若想为历史的某一次提交生成标签，则找到该提交的<code>commit_id</code> 即可；</li>\n<li><code>git tag -a &lt;tagname&gt; -m &quot;注释信息&quot; &lt;commit_id&gt;</code> ，创建标签并生成注释；</li>\n<li><code>git show &lt;tagname&gt;</code> ，查看相应的标签信息；</li>\n</ul>\n<p><strong>注</strong> ：标签是按照字母顺序排序的，而不是按照时间排序。</p>\n<ul>\n<li><p><code>git tag -d &lt;tagname&gt;</code> ，删除本地标签；</p>\n</li>\n<li><p><code>git push origin &lt;tagname&gt;</code> ，将标签推送到远程仓库中；</p>\n</li>\n<li><p><code>git push origin --tags</code> ，一次性地将本地标签全部推送到远程库中；</p>\n</li>\n<li><p>若想要删除的标签已经被推送到了远程库中，那么需要两步才能删除标签：</p>\n<blockquote>\n<p><code>git tag -d &lt;tagname&gt;</code> #首先，本地删除</p>\n<p><code>git push origin :refs/tags/&lt;tagname&gt;</code> #然后，远程删除库中的标签</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"5-Github\"><a href=\"#5-Github\" class=\"headerlink\" title=\"5 Github\"></a>5 Github</h3><p>如果要参与开源项目，首先将开源项目<code>Fork</code> 到自己的仓库中，然后<strong>从自己的仓库中<code>Clone</code> </strong>，只有这样才能在本地修改之后，再次推送到Github上，若希望开源项目的官方接受自己的修改，则需要在Github上发起<code>Pull Request</code> 。</p>\n<h3 id=\"6-gitignore\"><a href=\"#6-gitignore\" class=\"headerlink\" title=\"6 .gitignore\"></a>6 .gitignore</h3><p>.gitignore文件中的文件名将会在提交的时候被忽略，.gitignore文件需要放在版本库中。</p>\n<p>.gitignore文件不需要从头开始编写，可以参照<a href=\"https://github.com/github/gitignore\" title=\".gitignore-doc\">官方文档</a>并进行相应的组合即可。</p>\n<ul>\n<li><code>git add -f &lt;file&gt;</code> ，有时候.gitignore文件中禁止提交的文件类型中，有你希望提交的一份文件，则可以通过上述命令强行添加并提交；</li>\n<li><code>git check-ignore -v &lt;file&gt;</code> ，当发现一个文件无法添加和提交时，需要检查.gitignore文件中哪一条规则写错了，可以使用上述命令进行检查。</li>\n</ul>\n<h3 id=\"7-Git配置\"><a href=\"#7-Git配置\" class=\"headerlink\" title=\"7 Git配置\"></a>7 Git配置</h3><ul>\n<li>当前仓库的配置文档存放在<code>.git/config</code> 文件中；</li>\n<li>当前用户的配置文档存放在用户主目录下的隐藏文件<code>.gitignore</code> 中；</li>\n<li><code>git config --global alias. &lt;short-command&gt; &lt;origin-command&gt;</code> ，配置别名，简化使用。</li>\n</ul>\n<h3 id=\"8-Git服务器搭建\"><a href=\"#8-Git服务器搭建\" class=\"headerlink\" title=\"8 Git服务器搭建\"></a>8 Git服务器搭建</h3><p>服务器系统采用Linux，推荐Ubuntu或者Debian，以下操作需要sudo权限。</p>\n<ol>\n<li><p>安装Git:</p>\n<p><code>sudo apt-get install git</code> </p>\n</li>\n<li><p>创建Git用户，用于运行Git服务：</p>\n<p><code>sudo adduser git</code> </p>\n</li>\n<li><p>添加公钥，保证用户的登录：</p>\n<p>收集所有需要登录服务器的用户的公钥，即<code>id_rsa.pub</code> 文件的内容，将公钥添加进服务器的<code>/home/git/.ssh/authorized_keys</code> 文件中，一行一个。</p>\n</li>\n<li><p>初始化Git仓库：</p>\n<p>选定一个目录作为Git仓库，例如<code>/git/git-server.git</code> ，在目录<code>/git</code> 下执行命令：</p>\n<p><code>sudo git init --bare git-server.git</code> </p>\n<p>创建的是裸仓库，即没有工作区，服务器的目的是为了共享，而不允许用户登录到服务器上去修改，然后将Git仓库的所有者更改为之前添加的用户git：</p>\n<p><code>sudo chown -R git:git git-server.git</code> </p>\n</li>\n<li><p>禁用shell登录：</p>\n<p>即禁止之前创建的用户git登录shell，可以通过编辑<code>/etc/passwd</code> 文件完成，将以下一行</p>\n<p><code>git:x:1001:1001:,,,:/home/git:/bin/bash</code> </p>\n<p>改为</p>\n<p><code>git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</code> </p>\n<p>意思就是，用户<code>git</code> 每次一登录shell就会自动退出，即无法登录shell进行其他操作，这么做的目的是，让<code>git</code> 用户可以正常通过ssh使用git，但禁止其登录shell。</p>\n</li>\n<li><p>远程Git仓库已经建立好了，其他客户端用户可以使用<code>git clone</code> 将服务器上的内容克隆到本地进行修改：</p>\n<p><code>git clone git@server:/git/git-server.git</code> </p>\n<p>修改完成之后，就是推送与共享了。</p>\n</li>\n</ol>\n"},{"title":"Github Pages+hexo博客的创建与多机更新博客的实现","date":"2017-02-26T11:00:00.000Z","_content":"\n### 0 前言\n\n---\n\n本篇博文主要介绍在Windows 10系统上创建Github Pages+hexo博客的过程，同时，考虑到可能会在不同地点使用不同机器进行博客的更新操作，所以本篇博文还会介绍如何实现多台机器更新博客内容的方法，主要涉及的名词有：\n\n- Github与Github Pages\n\n  [Github](https://github.com/) 是一个面向开源以及私有软件项目的托管平台，简单来说就是一个远程仓库，注册账号以后可以在Github上存放软件代码，当然也可以存放文件，但是要注意的是，免费使用的情况下，你的Github是开放的，也就是所有人都可以看到你的仓库里存放了什么，如果想要加密则需要付费。\n\n  Github Pages则是在Github上搭建的博客或者网页，网页地址都是 `<your_githubname>.github.io` 。既然Github可以存放软件代码，那当然也可以存放博客文章以及网页需要的HTML/CSS/JS文件，从而Github Pages以Github仓库作为网页服务器，向外界提供一个可以访问的静态网页。\n\n- Markdown\n\n  [Markdown](http://sspai.com/25137/) 是一种用于写作的轻量级标记语言，虽然不像Word那样拥有大量的排版和字体设置，可以排版出一篇或精美或专业的文章，但是Markdown中简单的标记字符易于使用和记忆，甚至可以完成脱离鼠标，单单使用键盘就可以完成一篇文章的书写以及简洁精致的排版，这让使用者可以更加专心的码字，而不是过多地在意繁琐的排版工作。\n\n  Markdown有很多相关的编辑器，这里强烈推荐[Typora](https://typora.io/) 。\n\n  *有关Markdown编辑器的介绍和分析，请见另一篇博文《Typora——Markdown编辑界的极简主义》* \n\n- hexo\n\n  [hexo](https://hexo.io/) 是一款基于[node.js](https://nodejs.org/en/) 、开源的静态博客生成器。所谓“静态”，指的是所生成的博客网页本身只能提供浏览，而不能提交信息（当然，如果嵌入第三方插件，则可以通过插件提交信息，这是后话...）。hexo将书写好的Markdown文件根据选定的hexo主题转换成一堆HTML/CSS/JS文件，并支持本地预览网页，如果觉得没有问题，hexo还提供部署的功能，将网页文件上传到Github中，之后就可以通过访问Github Pages看到已发布的博客网页。\n\n- Git\n\n  [Git](https://git-scm.com/) 是一种开源的分布式版本管理系统，Github是Git发展壮大之后的产物，只支持Git作为唯一的版本库格式进行托管。\n\n  *有关Git的命令操作，请见另一篇文章《Git Study》*\n\n### 1 创建Github Pages并建立Github与本地的连接\n\n---\n\n#### 1.1 注册Github并创建一个新仓库（Repository）\n\n登录Github网站并注册账号成功之后，可以按照<span id=\"create-repo\"></span>[Create a new repository on GitHub](https://help.github.com/articles/create-a-repo/#create-a-new-repository-on-github) 的官方教程，一步一步地创建一个新的仓库，需要注意的只有一点：即因为我们这里是为了创建Github Pages博客的仓库，所以Repository name一定要是`<your_githubname>.github.io` 的形式。\n\n#### 1.2 建立Github与本地的连接（Authenticating）\n\n为了能够将本地的博客内容提交到远端的Github仓库中，需要建立本地与Github仓库的连接<span id=\"create-githublink\"></span>，即要让本地通过Github的身份验证（Authenticating）。考虑到Git默认使用SSH协议，所以我们使用SSH协议建立本地与Github之间的连接，参照[Connecting to GitHub with SSH](https://help.github.com/articles/connecting-to-github-with-ssh/) 。*（以下命令需要安装Git，并在Git Bash中完成输入）* \n\n当然也可以使用HTTPS建立连接，具体可以参照[Authenticating with GitHub from Git](https://help.github.com/articles/set-up-git/#next-steps-authenticating-with-github-from-git) 并做进一步的阅读。\n\n##### 1.2.1 本地生成新的SSH Key\n\n- 执行以下命令，输入你注册Github时使用的邮箱：\n\n   `ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"` \n\n- 出现以下提示的时候，说明已经使用你的邮箱生成了一个新的SSH Key：\n\n  `Generating public/private rsa key pair.` \n\n- 随后会出现以下提示，如果你对保存SSH Key的位置没有特殊的要求时，可以直接回车选择默认保存位置进行SSH Key的保存，保存的位置就是括号中所示的位置（根据实际系统有所不同）：\n\n  ```\n  Enter a file in which to save the key (/Users/you/.ssh/id_rsa):[Press enter]\n  ```\n\n- 接下来，需要为你的SSH Key输入密码，当然也可以选择不要密码，直接两个回车就可以了：\n\n  ```\n  Enter passphrase (empty for no passphrase): [Type a passphrase]\n  Enter same passphrase again: [Type passphrase again]\n  ```\n\n**注** ：如果你之前就有SSH Key，那么你可以检查一下是不是有合适的SSH Key可以使用：`ls -al ~/.ssh` \n\n##### 1.2.2 将SSH Key加入ssh-agent\n\n- 确定ssh-agent正在运行，执行以下命令开启ssh-agent：\n\n  `eval $(ssh-agent -s)` \n\n- 将SSH Key添加到ssh-agent中：\n\n  `ssh-add ~/.ssh/id_rsa` \n\n##### 1.2.3 将SSH Key添加到Github账号中\n\n- 将SSH Key复制到粘贴板：\n\n  ````\n  clip < ~/.ssh/id_rsa.pub\n  ````\n\n- 登录Github，点击右上方的头像，在下拉菜单中选择**Setting** ，然后**SSH and GPG keys** —— **New SSH Key** 或者**Add SSH Key** ，在\"Title\"里输入你想要的名称，然后在下方的“Key”文本框内添加刚才复制的SSH Key，最后点击**Add SSH Key** ，密码验证一下就好。\n\n##### 1.2.4 测试一下SSH连接是否成功\n\n- 执行以下命令：\n\n  `ssh -T git@github.com` \n\n  若输出以下两则信息中的一种，且其中一种是你的签名信息，那么输入`yes` 并回车即可：\n\n  ```\n  The authenticity of host 'github.com (192.30.252.1)' can't be established.\n  RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.\n  Are you sure you want to continue connecting (yes/no)?\n  ```\n\n  ```\n  The authenticity of host 'github.com (192.30.252.1)' can't be established.\n  RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.\n  Are you sure you want to continue connecting (yes/no)?\n  ```\n\n- 之后就可以看到验证成功的消息，确认其中有你的用户名：\n\n  ```\n  Hi <username>! You've successfully authenticated, but GitHub does not provide shell access.\n  ```\n\n  如果出现了`access denied` 的错误信息，请参照 [Error: Permission denied (publickey)](https://help.github.com/articles/error-permission-denied-publickey) 以及 [read these instructions for diagnosing the issue](https://help.github.com/articles/error-permission-denied-publickey) 进行修复。\n\n### 2 Hexo本地建站\n\n---\n\n#### 2.1 hexo安装\n\nhexo是基于node.js且在博客部署的时候需要Git命令操作的，所以在安装hexo之前，需要先安装[node.js](https://nodejs.org/en/) 和[Git](https://git-scm.com/download/win) 。\n\n完成上述两者的安装后，打开Git Bash，执行以下命令即可完成hexo的安装：\n\n```\nnpm install -g hexo-cli\n```\n\n#### 2.2 hexo站点建立\n\n- **1. 确定博客本地站点的位置：** \n\n  ~~选择一个位置，作为今后博客本地站点文件的存放位置， 在该位置建立名为`<your_githubname>.github.io` 的文件夹，`<your_githubname>.github.io` 也就是之前在Github上创建的仓库名~~ \n\n  由于我想要建立的是一个可以实现多机更新的博客，所以应该将hexo站点建立在**本地的Github仓库**中，这样在一台机器上配置好的主题和配置文件就可以随时上传到**Github远程仓库**中保存。如果希望在其他机器上建立hexo站点，在安装Git的基础上，可以先将之前保存在Github远程仓库中的hexo站点文件**克隆**到本地，形成Github本地仓库，然后在本地仓库中安装hexo即可使用，不需要重复配置。\n\n  同时，由于我们的博客静态网页是发布在远程仓库的`master` 分支，即主分支上，所以我们需要在`master` 分支的基础上，**新建一个分支**，命名随意，我这里记为`hexo-files` ，用于保存推送上来的hexo站点文件，同时在Github中将`hexo-files` 分支设置为当前仓库的**默认分支**，这样可以方便将本地仓库的文件推送到远端仓库中。\n\n  综上，在上文[创建Github远端新仓库](#create-repo) 以及新建并设置默认分支为`hexo-files` 的基础上，将这个新仓库**克隆**到本地，从而建立本地的Github仓库：\n\n  ```\n  # 切换到在你希望建立Github本地仓库的路径下\n  git clone git@github.com:<your_githubname>/<your_githubname>.github.io.git\n  ```\n\n  上述命令会自动创建一个名为`<your_githubname>.github.io` 的文件夹，并将远程仓库中的文件都放到这个文件夹中。同时，可以发现文件夹中有一个名为`.git` 的文件夹，这个文件夹保存了有关Github本地仓库的信息以及本地仓库与远程仓库的连接信息，也就是能将`<your_githubname>.github.io` 文件夹中内容推送到远程仓库中的关键。\n\n  **注** ：由于后续建站的时候，`hexo init` 命令初始化时，会将`.git` 文件夹覆盖，所以在这一步结束的时候，需要先将`.git` 文件夹保存起来，等待下一步`hexo init` 之后再复制进来。\n\n- **2. 建站：**\n\n  进入站点文件夹`<your_githubname>.github.io` 内，依次执行以下两条命令，完成hexo站点的建立：\n\n  ```\n  hexo init\n  npm install\n  ```\n\n  **注** ：记得将`.git` 文件夹复制到`<your_githubname>.github.io` 中。\n\n  此时，在Git Bash中进入`<your_githubname>.github.io` 目录下，可以看到当前所处Github分支是`hexo-files` ，如果不是，请返回上一步，设置好默认分支，再克隆远程仓库到本地。\n\n  完成后，站点文件夹内的目录结构大致如下：\n\n  ```\n  .\n  ├── .git\n  ├── _config.yml\n  ├── package.json\n  ├── node_modules\n  ├── scaffolds\n  ├── source\n  |   └── _posts\n  └── themes\n  ```\n\n  各文件和文件夹的含义大致为：\n\n  - `_config.yml` ，存放站点的配置信息，比如站点主题、站点名、站点菜单、站点链接以及第三方插件等等；\n\n  - `package.json` ，存放插件信息，可以查看安装了哪些插件；\n\n  - `node_modules` ，存放站点主题相关的样式文件；\n\n  - `scaffolds` ，模板文件，生成静态网页时，hexo会将Markdown文件中`---` 以上的部分对比模板文件，然后生成新的静态网页文件；\n\n  - `source` ，存放用户写好的Markdown文件，想要生成静态网页的Markdown文件写好之后，就可以放在`_post` 文件夹下。除了`_post` 文件夹，其他以`_` 开头的文件夹都会被忽略，而且，只有将Markdown文件放在`_post` 文件夹下，生成之后才会具有完整的主题样式。\n\n    当然，如果想在网页上创建类似于`About` 的更多菜单选项，可以在`source` 文件夹下新建更多的文件夹，并在其中添加Markdown文件，当然，这些文件生成静态网页后不会具有完整主题样式，只能手动调整。\n\n  - `themes` ，存放主题文件。\n\n  **注** ：由于默认的NPM镜像有时候会很慢，在这时候可以将默认的源切换到淘宝镜像：\n\n  ```\n  npm config set registry \"https://registry.npm.taobao.org\"\n  ```\n\n#### 2.3 hexo站点配置\n\n站点大部分的配置都可以通过`_config.yml` 文件实现，具体各个部分的含义可以参考[Hexo-配置](https://hexo.io/zh-cn/docs/configuration.html) 。\n\n#### 2.4 hexo新内容生成\n\n将一篇写好的Markdown文件放入`_post` 文件夹中（如果你还不知道怎么写，可以先参照和使用文件夹中已有的一个示例），关于如何写一篇Markdown文章，推荐使用[Typora](https://typora.io/) Markdown编辑器，关于Markdown语法，推荐[Typora For Markdown 语法](http://www.jianshu.com/p/092de536d948) ，当然也可以自行搜索。\n\n将Markdown文件生成静态网页文件，执行以下命令之后，会产生一个`public` 文件夹，其中包含的就是所生成的静态网页文件和样式：\n\n``` \nhexo generate\n# 或者简化为 hexo g\n```\n\n启动hexo本地服务器，然后在浏览器中输入`http://localhost:4000/` ，就可以在本地预览新生成的网页：\n\n```\nhexo server\n```\n\n需要注意的是，单纯写一篇文章，生成之后只会在网页显示一部分，如果要阅读全文或者支持文章分类，必须在文章开头添加[Front-matter](https://hexo.io/zh-cn/docs/front-matter.html) ，如下所示：\n\n```\ntitle: Hexo\ndate: 2017/02/27 00:00:00\ncategories:\n- Study\ntags:\n- Hexo\n- Github\n---\nHello World.\n```\n\n#### 2.5 hexo主题更换\n\nhexo的主题很多，可以访问[Themes|Hexo](https://hexo.io/themes/) 选取。\n\n以下将以[Noise](https://github.com/lotabout/hexo-theme-noise) 主题为例，讲解一下主题的更换。\n\n- 找到主题的Github主页，主页上一般都会有安装的步骤和使用教程；\n- 将主题的代码克隆到`/themes` 文件夹下，并安装主题和主题渲染器：\n\n```\ngit clone https://github.com/lotabout/hexo-theme-noise themes/noise\nnpm install hexo-renderer-less --save\nnpm install hexo-renderer-jade --save\n```\n\n- 修改配置文档`_config.yml` ，将`theme` 的值由`landscape` 修改为`noise` 。\n- 重新执行一遍生成操作即可预览:\n\n```\nhexo clean\nhexo generate\nhexo server\n```\n\n#### 2.6 小结\n\n以上就完成了hexo的本地建站工作，如果只想在本地玩玩，到这里就完成了，日常的工作就是写写Markdown文章，然后在站点目录下依次执行以下命令即可：\n\n```\nhexo generate\nhexo server\n# visit http://localhost:4000/\n```\n\nPS. 顺便总结一下不问原因的、从零开始的快速建站方法：\n\n```\n# install node.js and git\nnpm install -g hexo-cli\n# choose a path and clone <your_githubname>.github.io.git to local dir\ngit clone git@github.com:<your_githubname>/<your_githubname>.github.io.git\ncd <your_githubname>.github.io\n# 先将 .git 文件夹复制\nhexo init\n# 再将 .git 文件夹粘贴进来\nnpm install\n# write a markdown file and put it into /source/_post/\nhexo generate\nhexo server\n```\n\n### 3 hexo部署到Github\n\n---\n\n- 安装插件：\n\n```\nnpm install hexo-deployer-git --save\n```\n\n- 修改配置文件`_config.yml` ：\n\n```\ndeploy:\n  type: git\n  repo:  https://github.com/<your_githubname>/<your_name>.github.io.git\n  branch: master\n# branch: master 意思是，部署的时候选择master分支发布\n```\n\n​\t**注 ：配置文件中冒号后面一定要空一格** \n\n- 将hexo站点文件推送到远程仓库中，并将生成的静态网页部署到Github Pages：\n\n```\ngit add .\ngit commit -m \"注释\"\ngit push origin hexo-files # 意思是，将本地仓库hexo-files分支的内容推送到名为origin的远程仓库的默认分支中\n# 生成静态网页并部署到Github上\nhexo generate\nhexo deploy\n# 或者简化  hexo g -d\n```\n\n​\t有时候会跳出一个窗口，输入Github账号和密码即可。\n\n- 登录`https://<your_githubname>.github.io` ，查看部署完成的博客内容。\n\n**注** ：我还没有出现过部署不成功的情况，如果有，请查看[hexo部署后没动静，咋办](http://lowrank.science/Hexo-Github/) 。\n\n### 4 hexo博客更新以及多机更新流程\n\n---\n\n- **Status1** ：如果上一次更新时使用的就是当前的机器，那么只需要将新完成的Markdown文件放入`_post` 文件夹内，按照情况执行以下命令即可：\n\n```\n# 本地预览时\nhexo generate\nhexo server\n# 确定完成，需要推送&发布\nhexo clean # 清理一下减少推送的数据量\ngit add .\ngit commit -m \"注释\"\ngit push origin hexo-files\nhexo g -d\n```\n\n- **Status2** ：如果上一次更新时使用的不是当前机器，那么首先需要确定当前机器已经[建立了Github与本地的连接](#create-githublink) 并且已经安装了node.js和Git，之后根据情况执行以下命令：\n\n```\n# 创建本地仓库\ngit clone git@github.com:<your_githubname>/<your_githubname>.github.io.git\ncd <your_githubname>.github.io\n# 若当前机器是第一次用于编写发布博客，则需要安装hexo\nnpm install -g hexo-cli\n# 否则，从这里开始\nnpm install hexo \nnpm install\nnpm install hexo-deployer-git --save\n# npm install hexo-renderer-less --save\n# npm install hexo-renderer-jade --save\n# 之后，就可以按照上述的 Status1 推送和发布博客了\n```\n\n### 5 总结\n\n本文介绍了Hexo+Github Pages博客的建立方法和过程，以及如何实现多机更新Github博客的原理和方法。\n\n总的来说，如果是第一次搭建Github博客，要学习的东西还是蛮多的，如果不明白其中的道理，加上网上零零散散不完全的教程，经常会绕到死胡同里。其中，我认为掌握Github**仓库**和**分支**的概念是很重要的，当然这也是学习Github中很重要的两个知识点。\n\n在简单学习Github之后，我又萌生了将未完成的Markdown文件存储在Github远程仓库上的想法，这样未编写完成的Markdown文章就可以在不同机器上抓取并编写，然后推送共享，随时随地编写文章，直到完成。这对于我一个经常在实验室和宿舍两头跑的学生来说，是一件挺方便的事情。\n\n之后的工作......应该是系统地学习Github，了解Github上更多有趣的东西吧，先放个链接吧，[如何使用Github](https://www.zhihu.com/question/20070065) 以及[Github上有趣的项目](https://www.zhihu.com/question/23498424)。","source":"_posts/git-multiSync.md","raw":"title: Github Pages+hexo博客的创建与多机更新博客的实现\n\ndate: 2017/2/26 19:00:00\n\ncategories:\n\n- Study\n\ntags:\n\n- BlogTools\n- Github\n- hexo\n\n---\n\n### 0 前言\n\n---\n\n本篇博文主要介绍在Windows 10系统上创建Github Pages+hexo博客的过程，同时，考虑到可能会在不同地点使用不同机器进行博客的更新操作，所以本篇博文还会介绍如何实现多台机器更新博客内容的方法，主要涉及的名词有：\n\n- Github与Github Pages\n\n  [Github](https://github.com/) 是一个面向开源以及私有软件项目的托管平台，简单来说就是一个远程仓库，注册账号以后可以在Github上存放软件代码，当然也可以存放文件，但是要注意的是，免费使用的情况下，你的Github是开放的，也就是所有人都可以看到你的仓库里存放了什么，如果想要加密则需要付费。\n\n  Github Pages则是在Github上搭建的博客或者网页，网页地址都是 `<your_githubname>.github.io` 。既然Github可以存放软件代码，那当然也可以存放博客文章以及网页需要的HTML/CSS/JS文件，从而Github Pages以Github仓库作为网页服务器，向外界提供一个可以访问的静态网页。\n\n- Markdown\n\n  [Markdown](http://sspai.com/25137/) 是一种用于写作的轻量级标记语言，虽然不像Word那样拥有大量的排版和字体设置，可以排版出一篇或精美或专业的文章，但是Markdown中简单的标记字符易于使用和记忆，甚至可以完成脱离鼠标，单单使用键盘就可以完成一篇文章的书写以及简洁精致的排版，这让使用者可以更加专心的码字，而不是过多地在意繁琐的排版工作。\n\n  Markdown有很多相关的编辑器，这里强烈推荐[Typora](https://typora.io/) 。\n\n  *有关Markdown编辑器的介绍和分析，请见另一篇博文《Typora——Markdown编辑界的极简主义》* \n\n- hexo\n\n  [hexo](https://hexo.io/) 是一款基于[node.js](https://nodejs.org/en/) 、开源的静态博客生成器。所谓“静态”，指的是所生成的博客网页本身只能提供浏览，而不能提交信息（当然，如果嵌入第三方插件，则可以通过插件提交信息，这是后话...）。hexo将书写好的Markdown文件根据选定的hexo主题转换成一堆HTML/CSS/JS文件，并支持本地预览网页，如果觉得没有问题，hexo还提供部署的功能，将网页文件上传到Github中，之后就可以通过访问Github Pages看到已发布的博客网页。\n\n- Git\n\n  [Git](https://git-scm.com/) 是一种开源的分布式版本管理系统，Github是Git发展壮大之后的产物，只支持Git作为唯一的版本库格式进行托管。\n\n  *有关Git的命令操作，请见另一篇文章《Git Study》*\n\n### 1 创建Github Pages并建立Github与本地的连接\n\n---\n\n#### 1.1 注册Github并创建一个新仓库（Repository）\n\n登录Github网站并注册账号成功之后，可以按照<span id=\"create-repo\"></span>[Create a new repository on GitHub](https://help.github.com/articles/create-a-repo/#create-a-new-repository-on-github) 的官方教程，一步一步地创建一个新的仓库，需要注意的只有一点：即因为我们这里是为了创建Github Pages博客的仓库，所以Repository name一定要是`<your_githubname>.github.io` 的形式。\n\n#### 1.2 建立Github与本地的连接（Authenticating）\n\n为了能够将本地的博客内容提交到远端的Github仓库中，需要建立本地与Github仓库的连接<span id=\"create-githublink\"></span>，即要让本地通过Github的身份验证（Authenticating）。考虑到Git默认使用SSH协议，所以我们使用SSH协议建立本地与Github之间的连接，参照[Connecting to GitHub with SSH](https://help.github.com/articles/connecting-to-github-with-ssh/) 。*（以下命令需要安装Git，并在Git Bash中完成输入）* \n\n当然也可以使用HTTPS建立连接，具体可以参照[Authenticating with GitHub from Git](https://help.github.com/articles/set-up-git/#next-steps-authenticating-with-github-from-git) 并做进一步的阅读。\n\n##### 1.2.1 本地生成新的SSH Key\n\n- 执行以下命令，输入你注册Github时使用的邮箱：\n\n   `ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"` \n\n- 出现以下提示的时候，说明已经使用你的邮箱生成了一个新的SSH Key：\n\n  `Generating public/private rsa key pair.` \n\n- 随后会出现以下提示，如果你对保存SSH Key的位置没有特殊的要求时，可以直接回车选择默认保存位置进行SSH Key的保存，保存的位置就是括号中所示的位置（根据实际系统有所不同）：\n\n  ```\n  Enter a file in which to save the key (/Users/you/.ssh/id_rsa):[Press enter]\n  ```\n\n- 接下来，需要为你的SSH Key输入密码，当然也可以选择不要密码，直接两个回车就可以了：\n\n  ```\n  Enter passphrase (empty for no passphrase): [Type a passphrase]\n  Enter same passphrase again: [Type passphrase again]\n  ```\n\n**注** ：如果你之前就有SSH Key，那么你可以检查一下是不是有合适的SSH Key可以使用：`ls -al ~/.ssh` \n\n##### 1.2.2 将SSH Key加入ssh-agent\n\n- 确定ssh-agent正在运行，执行以下命令开启ssh-agent：\n\n  `eval $(ssh-agent -s)` \n\n- 将SSH Key添加到ssh-agent中：\n\n  `ssh-add ~/.ssh/id_rsa` \n\n##### 1.2.3 将SSH Key添加到Github账号中\n\n- 将SSH Key复制到粘贴板：\n\n  ````\n  clip < ~/.ssh/id_rsa.pub\n  ````\n\n- 登录Github，点击右上方的头像，在下拉菜单中选择**Setting** ，然后**SSH and GPG keys** —— **New SSH Key** 或者**Add SSH Key** ，在\"Title\"里输入你想要的名称，然后在下方的“Key”文本框内添加刚才复制的SSH Key，最后点击**Add SSH Key** ，密码验证一下就好。\n\n##### 1.2.4 测试一下SSH连接是否成功\n\n- 执行以下命令：\n\n  `ssh -T git@github.com` \n\n  若输出以下两则信息中的一种，且其中一种是你的签名信息，那么输入`yes` 并回车即可：\n\n  ```\n  The authenticity of host 'github.com (192.30.252.1)' can't be established.\n  RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.\n  Are you sure you want to continue connecting (yes/no)?\n  ```\n\n  ```\n  The authenticity of host 'github.com (192.30.252.1)' can't be established.\n  RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.\n  Are you sure you want to continue connecting (yes/no)?\n  ```\n\n- 之后就可以看到验证成功的消息，确认其中有你的用户名：\n\n  ```\n  Hi <username>! You've successfully authenticated, but GitHub does not provide shell access.\n  ```\n\n  如果出现了`access denied` 的错误信息，请参照 [Error: Permission denied (publickey)](https://help.github.com/articles/error-permission-denied-publickey) 以及 [read these instructions for diagnosing the issue](https://help.github.com/articles/error-permission-denied-publickey) 进行修复。\n\n### 2 Hexo本地建站\n\n---\n\n#### 2.1 hexo安装\n\nhexo是基于node.js且在博客部署的时候需要Git命令操作的，所以在安装hexo之前，需要先安装[node.js](https://nodejs.org/en/) 和[Git](https://git-scm.com/download/win) 。\n\n完成上述两者的安装后，打开Git Bash，执行以下命令即可完成hexo的安装：\n\n```\nnpm install -g hexo-cli\n```\n\n#### 2.2 hexo站点建立\n\n- **1. 确定博客本地站点的位置：** \n\n  ~~选择一个位置，作为今后博客本地站点文件的存放位置， 在该位置建立名为`<your_githubname>.github.io` 的文件夹，`<your_githubname>.github.io` 也就是之前在Github上创建的仓库名~~ \n\n  由于我想要建立的是一个可以实现多机更新的博客，所以应该将hexo站点建立在**本地的Github仓库**中，这样在一台机器上配置好的主题和配置文件就可以随时上传到**Github远程仓库**中保存。如果希望在其他机器上建立hexo站点，在安装Git的基础上，可以先将之前保存在Github远程仓库中的hexo站点文件**克隆**到本地，形成Github本地仓库，然后在本地仓库中安装hexo即可使用，不需要重复配置。\n\n  同时，由于我们的博客静态网页是发布在远程仓库的`master` 分支，即主分支上，所以我们需要在`master` 分支的基础上，**新建一个分支**，命名随意，我这里记为`hexo-files` ，用于保存推送上来的hexo站点文件，同时在Github中将`hexo-files` 分支设置为当前仓库的**默认分支**，这样可以方便将本地仓库的文件推送到远端仓库中。\n\n  综上，在上文[创建Github远端新仓库](#create-repo) 以及新建并设置默认分支为`hexo-files` 的基础上，将这个新仓库**克隆**到本地，从而建立本地的Github仓库：\n\n  ```\n  # 切换到在你希望建立Github本地仓库的路径下\n  git clone git@github.com:<your_githubname>/<your_githubname>.github.io.git\n  ```\n\n  上述命令会自动创建一个名为`<your_githubname>.github.io` 的文件夹，并将远程仓库中的文件都放到这个文件夹中。同时，可以发现文件夹中有一个名为`.git` 的文件夹，这个文件夹保存了有关Github本地仓库的信息以及本地仓库与远程仓库的连接信息，也就是能将`<your_githubname>.github.io` 文件夹中内容推送到远程仓库中的关键。\n\n  **注** ：由于后续建站的时候，`hexo init` 命令初始化时，会将`.git` 文件夹覆盖，所以在这一步结束的时候，需要先将`.git` 文件夹保存起来，等待下一步`hexo init` 之后再复制进来。\n\n- **2. 建站：**\n\n  进入站点文件夹`<your_githubname>.github.io` 内，依次执行以下两条命令，完成hexo站点的建立：\n\n  ```\n  hexo init\n  npm install\n  ```\n\n  **注** ：记得将`.git` 文件夹复制到`<your_githubname>.github.io` 中。\n\n  此时，在Git Bash中进入`<your_githubname>.github.io` 目录下，可以看到当前所处Github分支是`hexo-files` ，如果不是，请返回上一步，设置好默认分支，再克隆远程仓库到本地。\n\n  完成后，站点文件夹内的目录结构大致如下：\n\n  ```\n  .\n  ├── .git\n  ├── _config.yml\n  ├── package.json\n  ├── node_modules\n  ├── scaffolds\n  ├── source\n  |   └── _posts\n  └── themes\n  ```\n\n  各文件和文件夹的含义大致为：\n\n  - `_config.yml` ，存放站点的配置信息，比如站点主题、站点名、站点菜单、站点链接以及第三方插件等等；\n\n  - `package.json` ，存放插件信息，可以查看安装了哪些插件；\n\n  - `node_modules` ，存放站点主题相关的样式文件；\n\n  - `scaffolds` ，模板文件，生成静态网页时，hexo会将Markdown文件中`---` 以上的部分对比模板文件，然后生成新的静态网页文件；\n\n  - `source` ，存放用户写好的Markdown文件，想要生成静态网页的Markdown文件写好之后，就可以放在`_post` 文件夹下。除了`_post` 文件夹，其他以`_` 开头的文件夹都会被忽略，而且，只有将Markdown文件放在`_post` 文件夹下，生成之后才会具有完整的主题样式。\n\n    当然，如果想在网页上创建类似于`About` 的更多菜单选项，可以在`source` 文件夹下新建更多的文件夹，并在其中添加Markdown文件，当然，这些文件生成静态网页后不会具有完整主题样式，只能手动调整。\n\n  - `themes` ，存放主题文件。\n\n  **注** ：由于默认的NPM镜像有时候会很慢，在这时候可以将默认的源切换到淘宝镜像：\n\n  ```\n  npm config set registry \"https://registry.npm.taobao.org\"\n  ```\n\n#### 2.3 hexo站点配置\n\n站点大部分的配置都可以通过`_config.yml` 文件实现，具体各个部分的含义可以参考[Hexo-配置](https://hexo.io/zh-cn/docs/configuration.html) 。\n\n#### 2.4 hexo新内容生成\n\n将一篇写好的Markdown文件放入`_post` 文件夹中（如果你还不知道怎么写，可以先参照和使用文件夹中已有的一个示例），关于如何写一篇Markdown文章，推荐使用[Typora](https://typora.io/) Markdown编辑器，关于Markdown语法，推荐[Typora For Markdown 语法](http://www.jianshu.com/p/092de536d948) ，当然也可以自行搜索。\n\n将Markdown文件生成静态网页文件，执行以下命令之后，会产生一个`public` 文件夹，其中包含的就是所生成的静态网页文件和样式：\n\n``` \nhexo generate\n# 或者简化为 hexo g\n```\n\n启动hexo本地服务器，然后在浏览器中输入`http://localhost:4000/` ，就可以在本地预览新生成的网页：\n\n```\nhexo server\n```\n\n需要注意的是，单纯写一篇文章，生成之后只会在网页显示一部分，如果要阅读全文或者支持文章分类，必须在文章开头添加[Front-matter](https://hexo.io/zh-cn/docs/front-matter.html) ，如下所示：\n\n```\ntitle: Hexo\ndate: 2017/02/27 00:00:00\ncategories:\n- Study\ntags:\n- Hexo\n- Github\n---\nHello World.\n```\n\n#### 2.5 hexo主题更换\n\nhexo的主题很多，可以访问[Themes|Hexo](https://hexo.io/themes/) 选取。\n\n以下将以[Noise](https://github.com/lotabout/hexo-theme-noise) 主题为例，讲解一下主题的更换。\n\n- 找到主题的Github主页，主页上一般都会有安装的步骤和使用教程；\n- 将主题的代码克隆到`/themes` 文件夹下，并安装主题和主题渲染器：\n\n```\ngit clone https://github.com/lotabout/hexo-theme-noise themes/noise\nnpm install hexo-renderer-less --save\nnpm install hexo-renderer-jade --save\n```\n\n- 修改配置文档`_config.yml` ，将`theme` 的值由`landscape` 修改为`noise` 。\n- 重新执行一遍生成操作即可预览:\n\n```\nhexo clean\nhexo generate\nhexo server\n```\n\n#### 2.6 小结\n\n以上就完成了hexo的本地建站工作，如果只想在本地玩玩，到这里就完成了，日常的工作就是写写Markdown文章，然后在站点目录下依次执行以下命令即可：\n\n```\nhexo generate\nhexo server\n# visit http://localhost:4000/\n```\n\nPS. 顺便总结一下不问原因的、从零开始的快速建站方法：\n\n```\n# install node.js and git\nnpm install -g hexo-cli\n# choose a path and clone <your_githubname>.github.io.git to local dir\ngit clone git@github.com:<your_githubname>/<your_githubname>.github.io.git\ncd <your_githubname>.github.io\n# 先将 .git 文件夹复制\nhexo init\n# 再将 .git 文件夹粘贴进来\nnpm install\n# write a markdown file and put it into /source/_post/\nhexo generate\nhexo server\n```\n\n### 3 hexo部署到Github\n\n---\n\n- 安装插件：\n\n```\nnpm install hexo-deployer-git --save\n```\n\n- 修改配置文件`_config.yml` ：\n\n```\ndeploy:\n  type: git\n  repo:  https://github.com/<your_githubname>/<your_name>.github.io.git\n  branch: master\n# branch: master 意思是，部署的时候选择master分支发布\n```\n\n​\t**注 ：配置文件中冒号后面一定要空一格** \n\n- 将hexo站点文件推送到远程仓库中，并将生成的静态网页部署到Github Pages：\n\n```\ngit add .\ngit commit -m \"注释\"\ngit push origin hexo-files # 意思是，将本地仓库hexo-files分支的内容推送到名为origin的远程仓库的默认分支中\n# 生成静态网页并部署到Github上\nhexo generate\nhexo deploy\n# 或者简化  hexo g -d\n```\n\n​\t有时候会跳出一个窗口，输入Github账号和密码即可。\n\n- 登录`https://<your_githubname>.github.io` ，查看部署完成的博客内容。\n\n**注** ：我还没有出现过部署不成功的情况，如果有，请查看[hexo部署后没动静，咋办](http://lowrank.science/Hexo-Github/) 。\n\n### 4 hexo博客更新以及多机更新流程\n\n---\n\n- **Status1** ：如果上一次更新时使用的就是当前的机器，那么只需要将新完成的Markdown文件放入`_post` 文件夹内，按照情况执行以下命令即可：\n\n```\n# 本地预览时\nhexo generate\nhexo server\n# 确定完成，需要推送&发布\nhexo clean # 清理一下减少推送的数据量\ngit add .\ngit commit -m \"注释\"\ngit push origin hexo-files\nhexo g -d\n```\n\n- **Status2** ：如果上一次更新时使用的不是当前机器，那么首先需要确定当前机器已经[建立了Github与本地的连接](#create-githublink) 并且已经安装了node.js和Git，之后根据情况执行以下命令：\n\n```\n# 创建本地仓库\ngit clone git@github.com:<your_githubname>/<your_githubname>.github.io.git\ncd <your_githubname>.github.io\n# 若当前机器是第一次用于编写发布博客，则需要安装hexo\nnpm install -g hexo-cli\n# 否则，从这里开始\nnpm install hexo \nnpm install\nnpm install hexo-deployer-git --save\n# npm install hexo-renderer-less --save\n# npm install hexo-renderer-jade --save\n# 之后，就可以按照上述的 Status1 推送和发布博客了\n```\n\n### 5 总结\n\n本文介绍了Hexo+Github Pages博客的建立方法和过程，以及如何实现多机更新Github博客的原理和方法。\n\n总的来说，如果是第一次搭建Github博客，要学习的东西还是蛮多的，如果不明白其中的道理，加上网上零零散散不完全的教程，经常会绕到死胡同里。其中，我认为掌握Github**仓库**和**分支**的概念是很重要的，当然这也是学习Github中很重要的两个知识点。\n\n在简单学习Github之后，我又萌生了将未完成的Markdown文件存储在Github远程仓库上的想法，这样未编写完成的Markdown文章就可以在不同机器上抓取并编写，然后推送共享，随时随地编写文章，直到完成。这对于我一个经常在实验室和宿舍两头跑的学生来说，是一件挺方便的事情。\n\n之后的工作......应该是系统地学习Github，了解Github上更多有趣的东西吧，先放个链接吧，[如何使用Github](https://www.zhihu.com/question/20070065) 以及[Github上有趣的项目](https://www.zhihu.com/question/23498424)。","slug":"git-multiSync","published":1,"updated":"2017-04-02T09:26:50.397Z","_id":"cj0x6gze30006kkup735oxhbj","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"0-前言\"><a href=\"#0-前言\" class=\"headerlink\" title=\"0 前言\"></a>0 前言</h3><hr>\n<p>本篇博文主要介绍在Windows 10系统上创建Github Pages+hexo博客的过程，同时，考虑到可能会在不同地点使用不同机器进行博客的更新操作，所以本篇博文还会介绍如何实现多台机器更新博客内容的方法，主要涉及的名词有：</p>\n<ul>\n<li><p>Github与Github Pages</p>\n<p><a href=\"https://github.com/\" target=\"_blank\" rel=\"external\">Github</a> 是一个面向开源以及私有软件项目的托管平台，简单来说就是一个远程仓库，注册账号以后可以在Github上存放软件代码，当然也可以存放文件，但是要注意的是，免费使用的情况下，你的Github是开放的，也就是所有人都可以看到你的仓库里存放了什么，如果想要加密则需要付费。</p>\n<p>Github Pages则是在Github上搭建的博客或者网页，网页地址都是 <code>&lt;your_githubname&gt;.github.io</code> 。既然Github可以存放软件代码，那当然也可以存放博客文章以及网页需要的HTML/CSS/JS文件，从而Github Pages以Github仓库作为网页服务器，向外界提供一个可以访问的静态网页。</p>\n</li>\n<li><p>Markdown</p>\n<p><a href=\"http://sspai.com/25137/\" target=\"_blank\" rel=\"external\">Markdown</a> 是一种用于写作的轻量级标记语言，虽然不像Word那样拥有大量的排版和字体设置，可以排版出一篇或精美或专业的文章，但是Markdown中简单的标记字符易于使用和记忆，甚至可以完成脱离鼠标，单单使用键盘就可以完成一篇文章的书写以及简洁精致的排版，这让使用者可以更加专心的码字，而不是过多地在意繁琐的排版工作。</p>\n<p>Markdown有很多相关的编辑器，这里强烈推荐<a href=\"https://typora.io/\" target=\"_blank\" rel=\"external\">Typora</a> 。</p>\n<p><em>有关Markdown编辑器的介绍和分析，请见另一篇博文《Typora——Markdown编辑界的极简主义》</em> </p>\n</li>\n<li><p>hexo</p>\n<p><a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">hexo</a> 是一款基于<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"external\">node.js</a> 、开源的静态博客生成器。所谓“静态”，指的是所生成的博客网页本身只能提供浏览，而不能提交信息（当然，如果嵌入第三方插件，则可以通过插件提交信息，这是后话…）。hexo将书写好的Markdown文件根据选定的hexo主题转换成一堆HTML/CSS/JS文件，并支持本地预览网页，如果觉得没有问题，hexo还提供部署的功能，将网页文件上传到Github中，之后就可以通过访问Github Pages看到已发布的博客网页。</p>\n</li>\n<li><p>Git</p>\n<p><a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"external\">Git</a> 是一种开源的分布式版本管理系统，Github是Git发展壮大之后的产物，只支持Git作为唯一的版本库格式进行托管。</p>\n<p><em>有关Git的命令操作，请见另一篇文章《Git Study》</em></p>\n</li>\n</ul>\n<h3 id=\"1-创建Github-Pages并建立Github与本地的连接\"><a href=\"#1-创建Github-Pages并建立Github与本地的连接\" class=\"headerlink\" title=\"1 创建Github Pages并建立Github与本地的连接\"></a>1 创建Github Pages并建立Github与本地的连接</h3><hr>\n<h4 id=\"1-1-注册Github并创建一个新仓库（Repository）\"><a href=\"#1-1-注册Github并创建一个新仓库（Repository）\" class=\"headerlink\" title=\"1.1 注册Github并创建一个新仓库（Repository）\"></a>1.1 注册Github并创建一个新仓库（Repository）</h4><p>登录Github网站并注册账号成功之后，可以按照<span id=\"create-repo\"></span><a href=\"https://help.github.com/articles/create-a-repo/#create-a-new-repository-on-github\" target=\"_blank\" rel=\"external\">Create a new repository on GitHub</a> 的官方教程，一步一步地创建一个新的仓库，需要注意的只有一点：即因为我们这里是为了创建Github Pages博客的仓库，所以Repository name一定要是<code>&lt;your_githubname&gt;.github.io</code> 的形式。</p>\n<h4 id=\"1-2-建立Github与本地的连接（Authenticating）\"><a href=\"#1-2-建立Github与本地的连接（Authenticating）\" class=\"headerlink\" title=\"1.2 建立Github与本地的连接（Authenticating）\"></a>1.2 建立Github与本地的连接（Authenticating）</h4><p>为了能够将本地的博客内容提交到远端的Github仓库中，需要建立本地与Github仓库的连接<span id=\"create-githublink\"></span>，即要让本地通过Github的身份验证（Authenticating）。考虑到Git默认使用SSH协议，所以我们使用SSH协议建立本地与Github之间的连接，参照<a href=\"https://help.github.com/articles/connecting-to-github-with-ssh/\" target=\"_blank\" rel=\"external\">Connecting to GitHub with SSH</a> 。<em>（以下命令需要安装Git，并在Git Bash中完成输入）</em> </p>\n<p>当然也可以使用HTTPS建立连接，具体可以参照<a href=\"https://help.github.com/articles/set-up-git/#next-steps-authenticating-with-github-from-git\" target=\"_blank\" rel=\"external\">Authenticating with GitHub from Git</a> 并做进一步的阅读。</p>\n<h5 id=\"1-2-1-本地生成新的SSH-Key\"><a href=\"#1-2-1-本地生成新的SSH-Key\" class=\"headerlink\" title=\"1.2.1 本地生成新的SSH Key\"></a>1.2.1 本地生成新的SSH Key</h5><ul>\n<li><p>执行以下命令，输入你注册Github时使用的邮箱：</p>\n<p> <code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code> </p>\n</li>\n<li><p>出现以下提示的时候，说明已经使用你的邮箱生成了一个新的SSH Key：</p>\n<p><code>Generating public/private rsa key pair.</code> </p>\n</li>\n<li><p>随后会出现以下提示，如果你对保存SSH Key的位置没有特殊的要求时，可以直接回车选择默认保存位置进行SSH Key的保存，保存的位置就是括号中所示的位置（根据实际系统有所不同）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Enter a file in which to save the key (/Users/you/.ssh/id_rsa):[Press enter]</div></pre></td></tr></table></figure>\n</li>\n<li><p>接下来，需要为你的SSH Key输入密码，当然也可以选择不要密码，直接两个回车就可以了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Enter passphrase (empty for no passphrase): [Type a passphrase]</div><div class=\"line\">Enter same passphrase again: [Type passphrase again]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>注</strong> ：如果你之前就有SSH Key，那么你可以检查一下是不是有合适的SSH Key可以使用：<code>ls -al ~/.ssh</code> </p>\n<h5 id=\"1-2-2-将SSH-Key加入ssh-agent\"><a href=\"#1-2-2-将SSH-Key加入ssh-agent\" class=\"headerlink\" title=\"1.2.2 将SSH Key加入ssh-agent\"></a>1.2.2 将SSH Key加入ssh-agent</h5><ul>\n<li><p>确定ssh-agent正在运行，执行以下命令开启ssh-agent：</p>\n<p><code>eval $(ssh-agent -s)</code> </p>\n</li>\n<li><p>将SSH Key添加到ssh-agent中：</p>\n<p><code>ssh-add ~/.ssh/id_rsa</code> </p>\n</li>\n</ul>\n<h5 id=\"1-2-3-将SSH-Key添加到Github账号中\"><a href=\"#1-2-3-将SSH-Key添加到Github账号中\" class=\"headerlink\" title=\"1.2.3 将SSH Key添加到Github账号中\"></a>1.2.3 将SSH Key添加到Github账号中</h5><ul>\n<li><p>将SSH Key复制到粘贴板：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clip &lt; ~/.ssh/id_rsa.pub</div></pre></td></tr></table></figure>\n</li>\n<li><p>登录Github，点击右上方的头像，在下拉菜单中选择<strong>Setting</strong> ，然后<strong>SSH and GPG keys</strong> —— <strong>New SSH Key</strong> 或者<strong>Add SSH Key</strong> ，在”Title”里输入你想要的名称，然后在下方的“Key”文本框内添加刚才复制的SSH Key，最后点击<strong>Add SSH Key</strong> ，密码验证一下就好。</p>\n</li>\n</ul>\n<h5 id=\"1-2-4-测试一下SSH连接是否成功\"><a href=\"#1-2-4-测试一下SSH连接是否成功\" class=\"headerlink\" title=\"1.2.4 测试一下SSH连接是否成功\"></a>1.2.4 测试一下SSH连接是否成功</h5><ul>\n<li><p>执行以下命令：</p>\n<p><code>ssh -T git@github.com</code> </p>\n<p>若输出以下两则信息中的一种，且其中一种是你的签名信息，那么输入<code>yes</code> 并回车即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">The authenticity of host &apos;github.com (192.30.252.1)&apos; can&apos;t be established.</div><div class=\"line\">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</div><div class=\"line\">Are you sure you want to continue connecting (yes/no)?</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">The authenticity of host &apos;github.com (192.30.252.1)&apos; can&apos;t be established.</div><div class=\"line\">RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</div><div class=\"line\">Are you sure you want to continue connecting (yes/no)?</div></pre></td></tr></table></figure>\n</li>\n<li><p>之后就可以看到验证成功的消息，确认其中有你的用户名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Hi &lt;username&gt;! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</div></pre></td></tr></table></figure>\n<p>如果出现了<code>access denied</code> 的错误信息，请参照 <a href=\"https://help.github.com/articles/error-permission-denied-publickey\" target=\"_blank\" rel=\"external\">Error: Permission denied (publickey)</a> 以及 <a href=\"https://help.github.com/articles/error-permission-denied-publickey\" target=\"_blank\" rel=\"external\">read these instructions for diagnosing the issue</a> 进行修复。</p>\n</li>\n</ul>\n<h3 id=\"2-Hexo本地建站\"><a href=\"#2-Hexo本地建站\" class=\"headerlink\" title=\"2 Hexo本地建站\"></a>2 Hexo本地建站</h3><hr>\n<h4 id=\"2-1-hexo安装\"><a href=\"#2-1-hexo安装\" class=\"headerlink\" title=\"2.1 hexo安装\"></a>2.1 hexo安装</h4><p>hexo是基于node.js且在博客部署的时候需要Git命令操作的，所以在安装hexo之前，需要先安装<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"external\">node.js</a> 和<a href=\"https://git-scm.com/download/win\" target=\"_blank\" rel=\"external\">Git</a> 。</p>\n<p>完成上述两者的安装后，打开Git Bash，执行以下命令即可完成hexo的安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g hexo-cli</div></pre></td></tr></table></figure>\n<h4 id=\"2-2-hexo站点建立\"><a href=\"#2-2-hexo站点建立\" class=\"headerlink\" title=\"2.2 hexo站点建立\"></a>2.2 hexo站点建立</h4><ul>\n<li><p><strong>1. 确定博客本地站点的位置：</strong> </p>\n<p><del>选择一个位置，作为今后博客本地站点文件的存放位置， 在该位置建立名为<code>&lt;your_githubname&gt;.github.io</code> 的文件夹，<code>&lt;your_githubname&gt;.github.io</code> 也就是之前在Github上创建的仓库名</del> </p>\n<p>由于我想要建立的是一个可以实现多机更新的博客，所以应该将hexo站点建立在<strong>本地的Github仓库</strong>中，这样在一台机器上配置好的主题和配置文件就可以随时上传到<strong>Github远程仓库</strong>中保存。如果希望在其他机器上建立hexo站点，在安装Git的基础上，可以先将之前保存在Github远程仓库中的hexo站点文件<strong>克隆</strong>到本地，形成Github本地仓库，然后在本地仓库中安装hexo即可使用，不需要重复配置。</p>\n<p>同时，由于我们的博客静态网页是发布在远程仓库的<code>master</code> 分支，即主分支上，所以我们需要在<code>master</code> 分支的基础上，<strong>新建一个分支</strong>，命名随意，我这里记为<code>hexo-files</code> ，用于保存推送上来的hexo站点文件，同时在Github中将<code>hexo-files</code> 分支设置为当前仓库的<strong>默认分支</strong>，这样可以方便将本地仓库的文件推送到远端仓库中。</p>\n<p>综上，在上文<a href=\"#create-repo\">创建Github远端新仓库</a> 以及新建并设置默认分支为<code>hexo-files</code> 的基础上，将这个新仓库<strong>克隆</strong>到本地，从而建立本地的Github仓库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 切换到在你希望建立Github本地仓库的路径下</div><div class=\"line\">git clone git@github.com:&lt;your_githubname&gt;/&lt;your_githubname&gt;.github.io.git</div></pre></td></tr></table></figure>\n<p>上述命令会自动创建一个名为<code>&lt;your_githubname&gt;.github.io</code> 的文件夹，并将远程仓库中的文件都放到这个文件夹中。同时，可以发现文件夹中有一个名为<code>.git</code> 的文件夹，这个文件夹保存了有关Github本地仓库的信息以及本地仓库与远程仓库的连接信息，也就是能将<code>&lt;your_githubname&gt;.github.io</code> 文件夹中内容推送到远程仓库中的关键。</p>\n<p><strong>注</strong> ：由于后续建站的时候，<code>hexo init</code> 命令初始化时，会将<code>.git</code> 文件夹覆盖，所以在这一步结束的时候，需要先将<code>.git</code> 文件夹保存起来，等待下一步<code>hexo init</code> 之后再复制进来。</p>\n</li>\n<li><p><strong>2. 建站：</strong></p>\n<p>进入站点文件夹<code>&lt;your_githubname&gt;.github.io</code> 内，依次执行以下两条命令，完成hexo站点的建立：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init</div><div class=\"line\">npm install</div></pre></td></tr></table></figure>\n<p><strong>注</strong> ：记得将<code>.git</code> 文件夹复制到<code>&lt;your_githubname&gt;.github.io</code> 中。</p>\n<p>此时，在Git Bash中进入<code>&lt;your_githubname&gt;.github.io</code> 目录下，可以看到当前所处Github分支是<code>hexo-files</code> ，如果不是，请返回上一步，设置好默认分支，再克隆远程仓库到本地。</p>\n<p>完成后，站点文件夹内的目录结构大致如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── .git</div><div class=\"line\">├── _config.yml</div><div class=\"line\">├── package.json</div><div class=\"line\">├── node_modules</div><div class=\"line\">├── scaffolds</div><div class=\"line\">├── source</div><div class=\"line\">|   └── _posts</div><div class=\"line\">└── themes</div></pre></td></tr></table></figure>\n<p>各文件和文件夹的含义大致为：</p>\n<ul>\n<li><p><code>_config.yml</code> ，存放站点的配置信息，比如站点主题、站点名、站点菜单、站点链接以及第三方插件等等；</p>\n</li>\n<li><p><code>package.json</code> ，存放插件信息，可以查看安装了哪些插件；</p>\n</li>\n<li><p><code>node_modules</code> ，存放站点主题相关的样式文件；</p>\n</li>\n<li><p><code>scaffolds</code> ，模板文件，生成静态网页时，hexo会将Markdown文件中<code>---</code> 以上的部分对比模板文件，然后生成新的静态网页文件；</p>\n</li>\n<li><p><code>source</code> ，存放用户写好的Markdown文件，想要生成静态网页的Markdown文件写好之后，就可以放在<code>_post</code> 文件夹下。除了<code>_post</code> 文件夹，其他以<code>_</code> 开头的文件夹都会被忽略，而且，只有将Markdown文件放在<code>_post</code> 文件夹下，生成之后才会具有完整的主题样式。</p>\n<p>当然，如果想在网页上创建类似于<code>About</code> 的更多菜单选项，可以在<code>source</code> 文件夹下新建更多的文件夹，并在其中添加Markdown文件，当然，这些文件生成静态网页后不会具有完整主题样式，只能手动调整。</p>\n</li>\n<li><p><code>themes</code> ，存放主题文件。</p>\n</li>\n</ul>\n<p><strong>注</strong> ：由于默认的NPM镜像有时候会很慢，在这时候可以将默认的源切换到淘宝镜像：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm config set registry &quot;https://registry.npm.taobao.org&quot;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-3-hexo站点配置\"><a href=\"#2-3-hexo站点配置\" class=\"headerlink\" title=\"2.3 hexo站点配置\"></a>2.3 hexo站点配置</h4><p>站点大部分的配置都可以通过<code>_config.yml</code> 文件实现，具体各个部分的含义可以参考<a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"external\">Hexo-配置</a> 。</p>\n<h4 id=\"2-4-hexo新内容生成\"><a href=\"#2-4-hexo新内容生成\" class=\"headerlink\" title=\"2.4 hexo新内容生成\"></a>2.4 hexo新内容生成</h4><p>将一篇写好的Markdown文件放入<code>_post</code> 文件夹中（如果你还不知道怎么写，可以先参照和使用文件夹中已有的一个示例），关于如何写一篇Markdown文章，推荐使用<a href=\"https://typora.io/\" target=\"_blank\" rel=\"external\">Typora</a> Markdown编辑器，关于Markdown语法，推荐<a href=\"http://www.jianshu.com/p/092de536d948\" target=\"_blank\" rel=\"external\">Typora For Markdown 语法</a> ，当然也可以自行搜索。</p>\n<p>将Markdown文件生成静态网页文件，执行以下命令之后，会产生一个<code>public</code> 文件夹，其中包含的就是所生成的静态网页文件和样式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate</div><div class=\"line\"># 或者简化为 hexo g</div></pre></td></tr></table></figure>\n<p>启动hexo本地服务器，然后在浏览器中输入<code>http://localhost:4000/</code> ，就可以在本地预览新生成的网页：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo server</div></pre></td></tr></table></figure>\n<p>需要注意的是，单纯写一篇文章，生成之后只会在网页显示一部分，如果要阅读全文或者支持文章分类，必须在文章开头添加<a href=\"https://hexo.io/zh-cn/docs/front-matter.html\" target=\"_blank\" rel=\"external\">Front-matter</a> ，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">title: Hexo</div><div class=\"line\">date: 2017/02/27 00:00:00</div><div class=\"line\">categories:</div><div class=\"line\">- Study</div><div class=\"line\">tags:</div><div class=\"line\">- Hexo</div><div class=\"line\">- Github</div><div class=\"line\">---</div><div class=\"line\">Hello World.</div></pre></td></tr></table></figure>\n<h4 id=\"2-5-hexo主题更换\"><a href=\"#2-5-hexo主题更换\" class=\"headerlink\" title=\"2.5 hexo主题更换\"></a>2.5 hexo主题更换</h4><p>hexo的主题很多，可以访问<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"external\">Themes|Hexo</a> 选取。</p>\n<p>以下将以<a href=\"https://github.com/lotabout/hexo-theme-noise\" target=\"_blank\" rel=\"external\">Noise</a> 主题为例，讲解一下主题的更换。</p>\n<ul>\n<li>找到主题的Github主页，主页上一般都会有安装的步骤和使用教程；</li>\n<li>将主题的代码克隆到<code>/themes</code> 文件夹下，并安装主题和主题渲染器：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone https://github.com/lotabout/hexo-theme-noise themes/noise</div><div class=\"line\">npm install hexo-renderer-less --save</div><div class=\"line\">npm install hexo-renderer-jade --save</div></pre></td></tr></table></figure>\n<ul>\n<li>修改配置文档<code>_config.yml</code> ，将<code>theme</code> 的值由<code>landscape</code> 修改为<code>noise</code> 。</li>\n<li>重新执行一遍生成操作即可预览:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo clean</div><div class=\"line\">hexo generate</div><div class=\"line\">hexo server</div></pre></td></tr></table></figure>\n<h4 id=\"2-6-小结\"><a href=\"#2-6-小结\" class=\"headerlink\" title=\"2.6 小结\"></a>2.6 小结</h4><p>以上就完成了hexo的本地建站工作，如果只想在本地玩玩，到这里就完成了，日常的工作就是写写Markdown文章，然后在站点目录下依次执行以下命令即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate</div><div class=\"line\">hexo server</div><div class=\"line\"># visit http://localhost:4000/</div></pre></td></tr></table></figure>\n<p>PS. 顺便总结一下不问原因的、从零开始的快速建站方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"># install node.js and git</div><div class=\"line\">npm install -g hexo-cli</div><div class=\"line\"># choose a path and clone &lt;your_githubname&gt;.github.io.git to local dir</div><div class=\"line\">git clone git@github.com:&lt;your_githubname&gt;/&lt;your_githubname&gt;.github.io.git</div><div class=\"line\">cd &lt;your_githubname&gt;.github.io</div><div class=\"line\"># 先将 .git 文件夹复制</div><div class=\"line\">hexo init</div><div class=\"line\"># 再将 .git 文件夹粘贴进来</div><div class=\"line\">npm install</div><div class=\"line\"># write a markdown file and put it into /source/_post/</div><div class=\"line\">hexo generate</div><div class=\"line\">hexo server</div></pre></td></tr></table></figure>\n<h3 id=\"3-hexo部署到Github\"><a href=\"#3-hexo部署到Github\" class=\"headerlink\" title=\"3 hexo部署到Github\"></a>3 hexo部署到Github</h3><hr>\n<ul>\n<li>安装插件：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>\n<ul>\n<li>修改配置文件<code>_config.yml</code> ：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repo:  https://github.com/&lt;your_githubname&gt;/&lt;your_name&gt;.github.io.git</div><div class=\"line\">  branch: master</div><div class=\"line\"># branch: master 意思是，部署的时候选择master分支发布</div></pre></td></tr></table></figure>\n<p>​    <strong>注 ：配置文件中冒号后面一定要空一格</strong> </p>\n<ul>\n<li>将hexo站点文件推送到远程仓库中，并将生成的静态网页部署到Github Pages：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">git add .</div><div class=\"line\">git commit -m &quot;注释&quot;</div><div class=\"line\">git push origin hexo-files # 意思是，将本地仓库hexo-files分支的内容推送到名为origin的远程仓库的默认分支中</div><div class=\"line\"># 生成静态网页并部署到Github上</div><div class=\"line\">hexo generate</div><div class=\"line\">hexo deploy</div><div class=\"line\"># 或者简化  hexo g -d</div></pre></td></tr></table></figure>\n<p>​    有时候会跳出一个窗口，输入Github账号和密码即可。</p>\n<ul>\n<li>登录<code>https://&lt;your_githubname&gt;.github.io</code> ，查看部署完成的博客内容。</li>\n</ul>\n<p><strong>注</strong> ：我还没有出现过部署不成功的情况，如果有，请查看<a href=\"http://lowrank.science/Hexo-Github/\" target=\"_blank\" rel=\"external\">hexo部署后没动静，咋办</a> 。</p>\n<h3 id=\"4-hexo博客更新以及多机更新流程\"><a href=\"#4-hexo博客更新以及多机更新流程\" class=\"headerlink\" title=\"4 hexo博客更新以及多机更新流程\"></a>4 hexo博客更新以及多机更新流程</h3><hr>\n<ul>\n<li><strong>Status1</strong> ：如果上一次更新时使用的就是当前的机器，那么只需要将新完成的Markdown文件放入<code>_post</code> 文件夹内，按照情况执行以下命令即可：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 本地预览时</div><div class=\"line\">hexo generate</div><div class=\"line\">hexo server</div><div class=\"line\"># 确定完成，需要推送&amp;发布</div><div class=\"line\">hexo clean # 清理一下减少推送的数据量</div><div class=\"line\">git add .</div><div class=\"line\">git commit -m &quot;注释&quot;</div><div class=\"line\">git push origin hexo-files</div><div class=\"line\">hexo g -d</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>Status2</strong> ：如果上一次更新时使用的不是当前机器，那么首先需要确定当前机器已经<a href=\"#create-githublink\">建立了Github与本地的连接</a> 并且已经安装了node.js和Git，之后根据情况执行以下命令：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 创建本地仓库</div><div class=\"line\">git clone git@github.com:&lt;your_githubname&gt;/&lt;your_githubname&gt;.github.io.git</div><div class=\"line\">cd &lt;your_githubname&gt;.github.io</div><div class=\"line\"># 若当前机器是第一次用于编写发布博客，则需要安装hexo</div><div class=\"line\">npm install -g hexo-cli</div><div class=\"line\"># 否则，从这里开始</div><div class=\"line\">npm install hexo </div><div class=\"line\">npm install</div><div class=\"line\">npm install hexo-deployer-git --save</div><div class=\"line\"># npm install hexo-renderer-less --save</div><div class=\"line\"># npm install hexo-renderer-jade --save</div><div class=\"line\"># 之后，就可以按照上述的 Status1 推送和发布博客了</div></pre></td></tr></table></figure>\n<h3 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5 总结\"></a>5 总结</h3><p>本文介绍了Hexo+Github Pages博客的建立方法和过程，以及如何实现多机更新Github博客的原理和方法。</p>\n<p>总的来说，如果是第一次搭建Github博客，要学习的东西还是蛮多的，如果不明白其中的道理，加上网上零零散散不完全的教程，经常会绕到死胡同里。其中，我认为掌握Github<strong>仓库</strong>和<strong>分支</strong>的概念是很重要的，当然这也是学习Github中很重要的两个知识点。</p>\n<p>在简单学习Github之后，我又萌生了将未完成的Markdown文件存储在Github远程仓库上的想法，这样未编写完成的Markdown文章就可以在不同机器上抓取并编写，然后推送共享，随时随地编写文章，直到完成。这对于我一个经常在实验室和宿舍两头跑的学生来说，是一件挺方便的事情。</p>\n<p>之后的工作……应该是系统地学习Github，了解Github上更多有趣的东西吧，先放个链接吧，<a href=\"https://www.zhihu.com/question/20070065\" target=\"_blank\" rel=\"external\">如何使用Github</a> 以及<a href=\"https://www.zhihu.com/question/23498424\" target=\"_blank\" rel=\"external\">Github上有趣的项目</a>。</p>\n","excerpt":"","more":"<h3 id=\"0-前言\"><a href=\"#0-前言\" class=\"headerlink\" title=\"0 前言\"></a>0 前言</h3><hr>\n<p>本篇博文主要介绍在Windows 10系统上创建Github Pages+hexo博客的过程，同时，考虑到可能会在不同地点使用不同机器进行博客的更新操作，所以本篇博文还会介绍如何实现多台机器更新博客内容的方法，主要涉及的名词有：</p>\n<ul>\n<li><p>Github与Github Pages</p>\n<p><a href=\"https://github.com/\">Github</a> 是一个面向开源以及私有软件项目的托管平台，简单来说就是一个远程仓库，注册账号以后可以在Github上存放软件代码，当然也可以存放文件，但是要注意的是，免费使用的情况下，你的Github是开放的，也就是所有人都可以看到你的仓库里存放了什么，如果想要加密则需要付费。</p>\n<p>Github Pages则是在Github上搭建的博客或者网页，网页地址都是 <code>&lt;your_githubname&gt;.github.io</code> 。既然Github可以存放软件代码，那当然也可以存放博客文章以及网页需要的HTML/CSS/JS文件，从而Github Pages以Github仓库作为网页服务器，向外界提供一个可以访问的静态网页。</p>\n</li>\n<li><p>Markdown</p>\n<p><a href=\"http://sspai.com/25137/\">Markdown</a> 是一种用于写作的轻量级标记语言，虽然不像Word那样拥有大量的排版和字体设置，可以排版出一篇或精美或专业的文章，但是Markdown中简单的标记字符易于使用和记忆，甚至可以完成脱离鼠标，单单使用键盘就可以完成一篇文章的书写以及简洁精致的排版，这让使用者可以更加专心的码字，而不是过多地在意繁琐的排版工作。</p>\n<p>Markdown有很多相关的编辑器，这里强烈推荐<a href=\"https://typora.io/\">Typora</a> 。</p>\n<p><em>有关Markdown编辑器的介绍和分析，请见另一篇博文《Typora——Markdown编辑界的极简主义》</em> </p>\n</li>\n<li><p>hexo</p>\n<p><a href=\"https://hexo.io/\">hexo</a> 是一款基于<a href=\"https://nodejs.org/en/\">node.js</a> 、开源的静态博客生成器。所谓“静态”，指的是所生成的博客网页本身只能提供浏览，而不能提交信息（当然，如果嵌入第三方插件，则可以通过插件提交信息，这是后话…）。hexo将书写好的Markdown文件根据选定的hexo主题转换成一堆HTML/CSS/JS文件，并支持本地预览网页，如果觉得没有问题，hexo还提供部署的功能，将网页文件上传到Github中，之后就可以通过访问Github Pages看到已发布的博客网页。</p>\n</li>\n<li><p>Git</p>\n<p><a href=\"https://git-scm.com/\">Git</a> 是一种开源的分布式版本管理系统，Github是Git发展壮大之后的产物，只支持Git作为唯一的版本库格式进行托管。</p>\n<p><em>有关Git的命令操作，请见另一篇文章《Git Study》</em></p>\n</li>\n</ul>\n<h3 id=\"1-创建Github-Pages并建立Github与本地的连接\"><a href=\"#1-创建Github-Pages并建立Github与本地的连接\" class=\"headerlink\" title=\"1 创建Github Pages并建立Github与本地的连接\"></a>1 创建Github Pages并建立Github与本地的连接</h3><hr>\n<h4 id=\"1-1-注册Github并创建一个新仓库（Repository）\"><a href=\"#1-1-注册Github并创建一个新仓库（Repository）\" class=\"headerlink\" title=\"1.1 注册Github并创建一个新仓库（Repository）\"></a>1.1 注册Github并创建一个新仓库（Repository）</h4><p>登录Github网站并注册账号成功之后，可以按照<span id=\"create-repo\"></span><a href=\"https://help.github.com/articles/create-a-repo/#create-a-new-repository-on-github\">Create a new repository on GitHub</a> 的官方教程，一步一步地创建一个新的仓库，需要注意的只有一点：即因为我们这里是为了创建Github Pages博客的仓库，所以Repository name一定要是<code>&lt;your_githubname&gt;.github.io</code> 的形式。</p>\n<h4 id=\"1-2-建立Github与本地的连接（Authenticating）\"><a href=\"#1-2-建立Github与本地的连接（Authenticating）\" class=\"headerlink\" title=\"1.2 建立Github与本地的连接（Authenticating）\"></a>1.2 建立Github与本地的连接（Authenticating）</h4><p>为了能够将本地的博客内容提交到远端的Github仓库中，需要建立本地与Github仓库的连接<span id=\"create-githublink\"></span>，即要让本地通过Github的身份验证（Authenticating）。考虑到Git默认使用SSH协议，所以我们使用SSH协议建立本地与Github之间的连接，参照<a href=\"https://help.github.com/articles/connecting-to-github-with-ssh/\">Connecting to GitHub with SSH</a> 。<em>（以下命令需要安装Git，并在Git Bash中完成输入）</em> </p>\n<p>当然也可以使用HTTPS建立连接，具体可以参照<a href=\"https://help.github.com/articles/set-up-git/#next-steps-authenticating-with-github-from-git\">Authenticating with GitHub from Git</a> 并做进一步的阅读。</p>\n<h5 id=\"1-2-1-本地生成新的SSH-Key\"><a href=\"#1-2-1-本地生成新的SSH-Key\" class=\"headerlink\" title=\"1.2.1 本地生成新的SSH Key\"></a>1.2.1 本地生成新的SSH Key</h5><ul>\n<li><p>执行以下命令，输入你注册Github时使用的邮箱：</p>\n<p> <code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code> </p>\n</li>\n<li><p>出现以下提示的时候，说明已经使用你的邮箱生成了一个新的SSH Key：</p>\n<p><code>Generating public/private rsa key pair.</code> </p>\n</li>\n<li><p>随后会出现以下提示，如果你对保存SSH Key的位置没有特殊的要求时，可以直接回车选择默认保存位置进行SSH Key的保存，保存的位置就是括号中所示的位置（根据实际系统有所不同）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Enter a file in which to save the key (/Users/you/.ssh/id_rsa):[Press enter]</div></pre></td></tr></table></figure>\n</li>\n<li><p>接下来，需要为你的SSH Key输入密码，当然也可以选择不要密码，直接两个回车就可以了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Enter passphrase (empty for no passphrase): [Type a passphrase]</div><div class=\"line\">Enter same passphrase again: [Type passphrase again]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>注</strong> ：如果你之前就有SSH Key，那么你可以检查一下是不是有合适的SSH Key可以使用：<code>ls -al ~/.ssh</code> </p>\n<h5 id=\"1-2-2-将SSH-Key加入ssh-agent\"><a href=\"#1-2-2-将SSH-Key加入ssh-agent\" class=\"headerlink\" title=\"1.2.2 将SSH Key加入ssh-agent\"></a>1.2.2 将SSH Key加入ssh-agent</h5><ul>\n<li><p>确定ssh-agent正在运行，执行以下命令开启ssh-agent：</p>\n<p><code>eval $(ssh-agent -s)</code> </p>\n</li>\n<li><p>将SSH Key添加到ssh-agent中：</p>\n<p><code>ssh-add ~/.ssh/id_rsa</code> </p>\n</li>\n</ul>\n<h5 id=\"1-2-3-将SSH-Key添加到Github账号中\"><a href=\"#1-2-3-将SSH-Key添加到Github账号中\" class=\"headerlink\" title=\"1.2.3 将SSH Key添加到Github账号中\"></a>1.2.3 将SSH Key添加到Github账号中</h5><ul>\n<li><p>将SSH Key复制到粘贴板：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clip &lt; ~/.ssh/id_rsa.pub</div></pre></td></tr></table></figure>\n</li>\n<li><p>登录Github，点击右上方的头像，在下拉菜单中选择<strong>Setting</strong> ，然后<strong>SSH and GPG keys</strong> —— <strong>New SSH Key</strong> 或者<strong>Add SSH Key</strong> ，在”Title”里输入你想要的名称，然后在下方的“Key”文本框内添加刚才复制的SSH Key，最后点击<strong>Add SSH Key</strong> ，密码验证一下就好。</p>\n</li>\n</ul>\n<h5 id=\"1-2-4-测试一下SSH连接是否成功\"><a href=\"#1-2-4-测试一下SSH连接是否成功\" class=\"headerlink\" title=\"1.2.4 测试一下SSH连接是否成功\"></a>1.2.4 测试一下SSH连接是否成功</h5><ul>\n<li><p>执行以下命令：</p>\n<p><code>ssh -T git@github.com</code> </p>\n<p>若输出以下两则信息中的一种，且其中一种是你的签名信息，那么输入<code>yes</code> 并回车即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">The authenticity of host &apos;github.com (192.30.252.1)&apos; can&apos;t be established.</div><div class=\"line\">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</div><div class=\"line\">Are you sure you want to continue connecting (yes/no)?</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">The authenticity of host &apos;github.com (192.30.252.1)&apos; can&apos;t be established.</div><div class=\"line\">RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</div><div class=\"line\">Are you sure you want to continue connecting (yes/no)?</div></pre></td></tr></table></figure>\n</li>\n<li><p>之后就可以看到验证成功的消息，确认其中有你的用户名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Hi &lt;username&gt;! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</div></pre></td></tr></table></figure>\n<p>如果出现了<code>access denied</code> 的错误信息，请参照 <a href=\"https://help.github.com/articles/error-permission-denied-publickey\">Error: Permission denied (publickey)</a> 以及 <a href=\"https://help.github.com/articles/error-permission-denied-publickey\">read these instructions for diagnosing the issue</a> 进行修复。</p>\n</li>\n</ul>\n<h3 id=\"2-Hexo本地建站\"><a href=\"#2-Hexo本地建站\" class=\"headerlink\" title=\"2 Hexo本地建站\"></a>2 Hexo本地建站</h3><hr>\n<h4 id=\"2-1-hexo安装\"><a href=\"#2-1-hexo安装\" class=\"headerlink\" title=\"2.1 hexo安装\"></a>2.1 hexo安装</h4><p>hexo是基于node.js且在博客部署的时候需要Git命令操作的，所以在安装hexo之前，需要先安装<a href=\"https://nodejs.org/en/\">node.js</a> 和<a href=\"https://git-scm.com/download/win\">Git</a> 。</p>\n<p>完成上述两者的安装后，打开Git Bash，执行以下命令即可完成hexo的安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g hexo-cli</div></pre></td></tr></table></figure>\n<h4 id=\"2-2-hexo站点建立\"><a href=\"#2-2-hexo站点建立\" class=\"headerlink\" title=\"2.2 hexo站点建立\"></a>2.2 hexo站点建立</h4><ul>\n<li><p><strong>1. 确定博客本地站点的位置：</strong> </p>\n<p><del>选择一个位置，作为今后博客本地站点文件的存放位置， 在该位置建立名为<code>&lt;your_githubname&gt;.github.io</code> 的文件夹，<code>&lt;your_githubname&gt;.github.io</code> 也就是之前在Github上创建的仓库名</del> </p>\n<p>由于我想要建立的是一个可以实现多机更新的博客，所以应该将hexo站点建立在<strong>本地的Github仓库</strong>中，这样在一台机器上配置好的主题和配置文件就可以随时上传到<strong>Github远程仓库</strong>中保存。如果希望在其他机器上建立hexo站点，在安装Git的基础上，可以先将之前保存在Github远程仓库中的hexo站点文件<strong>克隆</strong>到本地，形成Github本地仓库，然后在本地仓库中安装hexo即可使用，不需要重复配置。</p>\n<p>同时，由于我们的博客静态网页是发布在远程仓库的<code>master</code> 分支，即主分支上，所以我们需要在<code>master</code> 分支的基础上，<strong>新建一个分支</strong>，命名随意，我这里记为<code>hexo-files</code> ，用于保存推送上来的hexo站点文件，同时在Github中将<code>hexo-files</code> 分支设置为当前仓库的<strong>默认分支</strong>，这样可以方便将本地仓库的文件推送到远端仓库中。</p>\n<p>综上，在上文<a href=\"#create-repo\">创建Github远端新仓库</a> 以及新建并设置默认分支为<code>hexo-files</code> 的基础上，将这个新仓库<strong>克隆</strong>到本地，从而建立本地的Github仓库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 切换到在你希望建立Github本地仓库的路径下</div><div class=\"line\">git clone git@github.com:&lt;your_githubname&gt;/&lt;your_githubname&gt;.github.io.git</div></pre></td></tr></table></figure>\n<p>上述命令会自动创建一个名为<code>&lt;your_githubname&gt;.github.io</code> 的文件夹，并将远程仓库中的文件都放到这个文件夹中。同时，可以发现文件夹中有一个名为<code>.git</code> 的文件夹，这个文件夹保存了有关Github本地仓库的信息以及本地仓库与远程仓库的连接信息，也就是能将<code>&lt;your_githubname&gt;.github.io</code> 文件夹中内容推送到远程仓库中的关键。</p>\n<p><strong>注</strong> ：由于后续建站的时候，<code>hexo init</code> 命令初始化时，会将<code>.git</code> 文件夹覆盖，所以在这一步结束的时候，需要先将<code>.git</code> 文件夹保存起来，等待下一步<code>hexo init</code> 之后再复制进来。</p>\n</li>\n<li><p><strong>2. 建站：</strong></p>\n<p>进入站点文件夹<code>&lt;your_githubname&gt;.github.io</code> 内，依次执行以下两条命令，完成hexo站点的建立：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init</div><div class=\"line\">npm install</div></pre></td></tr></table></figure>\n<p><strong>注</strong> ：记得将<code>.git</code> 文件夹复制到<code>&lt;your_githubname&gt;.github.io</code> 中。</p>\n<p>此时，在Git Bash中进入<code>&lt;your_githubname&gt;.github.io</code> 目录下，可以看到当前所处Github分支是<code>hexo-files</code> ，如果不是，请返回上一步，设置好默认分支，再克隆远程仓库到本地。</p>\n<p>完成后，站点文件夹内的目录结构大致如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── .git</div><div class=\"line\">├── _config.yml</div><div class=\"line\">├── package.json</div><div class=\"line\">├── node_modules</div><div class=\"line\">├── scaffolds</div><div class=\"line\">├── source</div><div class=\"line\">|   └── _posts</div><div class=\"line\">└── themes</div></pre></td></tr></table></figure>\n<p>各文件和文件夹的含义大致为：</p>\n<ul>\n<li><p><code>_config.yml</code> ，存放站点的配置信息，比如站点主题、站点名、站点菜单、站点链接以及第三方插件等等；</p>\n</li>\n<li><p><code>package.json</code> ，存放插件信息，可以查看安装了哪些插件；</p>\n</li>\n<li><p><code>node_modules</code> ，存放站点主题相关的样式文件；</p>\n</li>\n<li><p><code>scaffolds</code> ，模板文件，生成静态网页时，hexo会将Markdown文件中<code>---</code> 以上的部分对比模板文件，然后生成新的静态网页文件；</p>\n</li>\n<li><p><code>source</code> ，存放用户写好的Markdown文件，想要生成静态网页的Markdown文件写好之后，就可以放在<code>_post</code> 文件夹下。除了<code>_post</code> 文件夹，其他以<code>_</code> 开头的文件夹都会被忽略，而且，只有将Markdown文件放在<code>_post</code> 文件夹下，生成之后才会具有完整的主题样式。</p>\n<p>当然，如果想在网页上创建类似于<code>About</code> 的更多菜单选项，可以在<code>source</code> 文件夹下新建更多的文件夹，并在其中添加Markdown文件，当然，这些文件生成静态网页后不会具有完整主题样式，只能手动调整。</p>\n</li>\n<li><p><code>themes</code> ，存放主题文件。</p>\n</li>\n</ul>\n<p><strong>注</strong> ：由于默认的NPM镜像有时候会很慢，在这时候可以将默认的源切换到淘宝镜像：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm config set registry &quot;https://registry.npm.taobao.org&quot;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-3-hexo站点配置\"><a href=\"#2-3-hexo站点配置\" class=\"headerlink\" title=\"2.3 hexo站点配置\"></a>2.3 hexo站点配置</h4><p>站点大部分的配置都可以通过<code>_config.yml</code> 文件实现，具体各个部分的含义可以参考<a href=\"https://hexo.io/zh-cn/docs/configuration.html\">Hexo-配置</a> 。</p>\n<h4 id=\"2-4-hexo新内容生成\"><a href=\"#2-4-hexo新内容生成\" class=\"headerlink\" title=\"2.4 hexo新内容生成\"></a>2.4 hexo新内容生成</h4><p>将一篇写好的Markdown文件放入<code>_post</code> 文件夹中（如果你还不知道怎么写，可以先参照和使用文件夹中已有的一个示例），关于如何写一篇Markdown文章，推荐使用<a href=\"https://typora.io/\">Typora</a> Markdown编辑器，关于Markdown语法，推荐<a href=\"http://www.jianshu.com/p/092de536d948\">Typora For Markdown 语法</a> ，当然也可以自行搜索。</p>\n<p>将Markdown文件生成静态网页文件，执行以下命令之后，会产生一个<code>public</code> 文件夹，其中包含的就是所生成的静态网页文件和样式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate</div><div class=\"line\"># 或者简化为 hexo g</div></pre></td></tr></table></figure>\n<p>启动hexo本地服务器，然后在浏览器中输入<code>http://localhost:4000/</code> ，就可以在本地预览新生成的网页：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo server</div></pre></td></tr></table></figure>\n<p>需要注意的是，单纯写一篇文章，生成之后只会在网页显示一部分，如果要阅读全文或者支持文章分类，必须在文章开头添加<a href=\"https://hexo.io/zh-cn/docs/front-matter.html\">Front-matter</a> ，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">title: Hexo</div><div class=\"line\">date: 2017/02/27 00:00:00</div><div class=\"line\">categories:</div><div class=\"line\">- Study</div><div class=\"line\">tags:</div><div class=\"line\">- Hexo</div><div class=\"line\">- Github</div><div class=\"line\">---</div><div class=\"line\">Hello World.</div></pre></td></tr></table></figure>\n<h4 id=\"2-5-hexo主题更换\"><a href=\"#2-5-hexo主题更换\" class=\"headerlink\" title=\"2.5 hexo主题更换\"></a>2.5 hexo主题更换</h4><p>hexo的主题很多，可以访问<a href=\"https://hexo.io/themes/\">Themes|Hexo</a> 选取。</p>\n<p>以下将以<a href=\"https://github.com/lotabout/hexo-theme-noise\">Noise</a> 主题为例，讲解一下主题的更换。</p>\n<ul>\n<li>找到主题的Github主页，主页上一般都会有安装的步骤和使用教程；</li>\n<li>将主题的代码克隆到<code>/themes</code> 文件夹下，并安装主题和主题渲染器：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone https://github.com/lotabout/hexo-theme-noise themes/noise</div><div class=\"line\">npm install hexo-renderer-less --save</div><div class=\"line\">npm install hexo-renderer-jade --save</div></pre></td></tr></table></figure>\n<ul>\n<li>修改配置文档<code>_config.yml</code> ，将<code>theme</code> 的值由<code>landscape</code> 修改为<code>noise</code> 。</li>\n<li>重新执行一遍生成操作即可预览:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo clean</div><div class=\"line\">hexo generate</div><div class=\"line\">hexo server</div></pre></td></tr></table></figure>\n<h4 id=\"2-6-小结\"><a href=\"#2-6-小结\" class=\"headerlink\" title=\"2.6 小结\"></a>2.6 小结</h4><p>以上就完成了hexo的本地建站工作，如果只想在本地玩玩，到这里就完成了，日常的工作就是写写Markdown文章，然后在站点目录下依次执行以下命令即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate</div><div class=\"line\">hexo server</div><div class=\"line\"># visit http://localhost:4000/</div></pre></td></tr></table></figure>\n<p>PS. 顺便总结一下不问原因的、从零开始的快速建站方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"># install node.js and git</div><div class=\"line\">npm install -g hexo-cli</div><div class=\"line\"># choose a path and clone &lt;your_githubname&gt;.github.io.git to local dir</div><div class=\"line\">git clone git@github.com:&lt;your_githubname&gt;/&lt;your_githubname&gt;.github.io.git</div><div class=\"line\">cd &lt;your_githubname&gt;.github.io</div><div class=\"line\"># 先将 .git 文件夹复制</div><div class=\"line\">hexo init</div><div class=\"line\"># 再将 .git 文件夹粘贴进来</div><div class=\"line\">npm install</div><div class=\"line\"># write a markdown file and put it into /source/_post/</div><div class=\"line\">hexo generate</div><div class=\"line\">hexo server</div></pre></td></tr></table></figure>\n<h3 id=\"3-hexo部署到Github\"><a href=\"#3-hexo部署到Github\" class=\"headerlink\" title=\"3 hexo部署到Github\"></a>3 hexo部署到Github</h3><hr>\n<ul>\n<li>安装插件：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>\n<ul>\n<li>修改配置文件<code>_config.yml</code> ：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repo:  https://github.com/&lt;your_githubname&gt;/&lt;your_name&gt;.github.io.git</div><div class=\"line\">  branch: master</div><div class=\"line\"># branch: master 意思是，部署的时候选择master分支发布</div></pre></td></tr></table></figure>\n<p>​    <strong>注 ：配置文件中冒号后面一定要空一格</strong> </p>\n<ul>\n<li>将hexo站点文件推送到远程仓库中，并将生成的静态网页部署到Github Pages：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">git add .</div><div class=\"line\">git commit -m &quot;注释&quot;</div><div class=\"line\">git push origin hexo-files # 意思是，将本地仓库hexo-files分支的内容推送到名为origin的远程仓库的默认分支中</div><div class=\"line\"># 生成静态网页并部署到Github上</div><div class=\"line\">hexo generate</div><div class=\"line\">hexo deploy</div><div class=\"line\"># 或者简化  hexo g -d</div></pre></td></tr></table></figure>\n<p>​    有时候会跳出一个窗口，输入Github账号和密码即可。</p>\n<ul>\n<li>登录<code>https://&lt;your_githubname&gt;.github.io</code> ，查看部署完成的博客内容。</li>\n</ul>\n<p><strong>注</strong> ：我还没有出现过部署不成功的情况，如果有，请查看<a href=\"http://lowrank.science/Hexo-Github/\">hexo部署后没动静，咋办</a> 。</p>\n<h3 id=\"4-hexo博客更新以及多机更新流程\"><a href=\"#4-hexo博客更新以及多机更新流程\" class=\"headerlink\" title=\"4 hexo博客更新以及多机更新流程\"></a>4 hexo博客更新以及多机更新流程</h3><hr>\n<ul>\n<li><strong>Status1</strong> ：如果上一次更新时使用的就是当前的机器，那么只需要将新完成的Markdown文件放入<code>_post</code> 文件夹内，按照情况执行以下命令即可：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 本地预览时</div><div class=\"line\">hexo generate</div><div class=\"line\">hexo server</div><div class=\"line\"># 确定完成，需要推送&amp;发布</div><div class=\"line\">hexo clean # 清理一下减少推送的数据量</div><div class=\"line\">git add .</div><div class=\"line\">git commit -m &quot;注释&quot;</div><div class=\"line\">git push origin hexo-files</div><div class=\"line\">hexo g -d</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>Status2</strong> ：如果上一次更新时使用的不是当前机器，那么首先需要确定当前机器已经<a href=\"#create-githublink\">建立了Github与本地的连接</a> 并且已经安装了node.js和Git，之后根据情况执行以下命令：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 创建本地仓库</div><div class=\"line\">git clone git@github.com:&lt;your_githubname&gt;/&lt;your_githubname&gt;.github.io.git</div><div class=\"line\">cd &lt;your_githubname&gt;.github.io</div><div class=\"line\"># 若当前机器是第一次用于编写发布博客，则需要安装hexo</div><div class=\"line\">npm install -g hexo-cli</div><div class=\"line\"># 否则，从这里开始</div><div class=\"line\">npm install hexo </div><div class=\"line\">npm install</div><div class=\"line\">npm install hexo-deployer-git --save</div><div class=\"line\"># npm install hexo-renderer-less --save</div><div class=\"line\"># npm install hexo-renderer-jade --save</div><div class=\"line\"># 之后，就可以按照上述的 Status1 推送和发布博客了</div></pre></td></tr></table></figure>\n<h3 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5 总结\"></a>5 总结</h3><p>本文介绍了Hexo+Github Pages博客的建立方法和过程，以及如何实现多机更新Github博客的原理和方法。</p>\n<p>总的来说，如果是第一次搭建Github博客，要学习的东西还是蛮多的，如果不明白其中的道理，加上网上零零散散不完全的教程，经常会绕到死胡同里。其中，我认为掌握Github<strong>仓库</strong>和<strong>分支</strong>的概念是很重要的，当然这也是学习Github中很重要的两个知识点。</p>\n<p>在简单学习Github之后，我又萌生了将未完成的Markdown文件存储在Github远程仓库上的想法，这样未编写完成的Markdown文章就可以在不同机器上抓取并编写，然后推送共享，随时随地编写文章，直到完成。这对于我一个经常在实验室和宿舍两头跑的学生来说，是一件挺方便的事情。</p>\n<p>之后的工作……应该是系统地学习Github，了解Github上更多有趣的东西吧，先放个链接吧，<a href=\"https://www.zhihu.com/question/20070065\">如何使用Github</a> 以及<a href=\"https://www.zhihu.com/question/23498424\">Github上有趣的项目</a>。</p>\n"},{"title":"leetcode82 Remove Duplicates from Sorted List II","date":"2017-04-01T02:00:00.000Z","_content":"\n## leetcode#82 Remove Duplicates from Sorted List II\n\n>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only *distinct* numbers from the original list.\n>\n>For example,\n>Given `1->2->3->3->4->4->5`, return `1->2->5`.\n>Given `1->1->1->2->3`, return `2->3`.\n\n##### 解释：\n\n给定一个**排好序**的链表，要求将链表中的重复元素**全都删除**，只留下不重复的元素。\n\n##### 理解：\n\n本题与`leetcode#83` 都是针对有序链表删除重复元素，但是本题的要求稍微高一点，即不仅仅是删除重复多出的部分，而且不能留下出现了重复的元素。这样一来，就不能像`leetcode#83` 的三行解法一样，直接遍历到链表末尾再递归返回了，而需要将递归操作嵌套在一个**`while` 循环**的条件判断中，而且每一次的比较都需要至少涉及**相邻的三个元素**，以避免漏删重复元素，比如`3-4-4`的情况。\n\n##### 我的解法：\n\n同样，首先是边界的判断。\n\n然后每一次的递归都会给出两个局部变量`tmpMove` 和`tmpFix` ，分别用于**遍历**链表元素和**暂时性地标记**下一个不同的元素（因为重复之后可能还会出现重复，虽然两个重复之间是不同的，但不应该直接移动`head` ，比如`1,1,1,2,2,2` ，虽然`1 2`是不同的，但是这两者都是重复的，此时都不应该将`1 2` 加入到新链表中），只有当；\n\n同时还有一个标志变量`flag` ，用于标志**是否进行了递归赋值**（若没有进行递归赋值&&`tmpMove = null`跳出循环，则说明从上一个不同的元素开始，之后的元素全都是重复的，所以返回一个`null`即可）。\n\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head == null || head.next == null) return head;\n        ListNode tmpMove = head;\n        ListNode tmpFix = head;\n        int flag = 0; // 用于标识区分是否进到了递归赋值的那一步\n        while(tmpMove != null){\n            if(tmpFix.next == null) { return tmpFix; } \n            // 如果是最后一个元素且不同于前面的元素，则将其加入新链表\n            if(tmpMove.val == tmpFix.val) { tmpMove = tmpMove.next; }            \n            else if(tmpFix.val == tmpFix.next.val) { tmpFix = tmpMove; }\n            else {  \n                    head = tmpFix;\n                    head.next = deleteDuplicates(head.next);\n                    flag = 1;\n                    break;\n            }\n        }\n        if(flag == 1) { return head; }\n        else { return null; }\n    }\n}\n```\n\n##### 大神解法：\n\n同样将递归过程嵌套在了循环和条件中，不同的是：\n\n- 没有比较相邻的三个元素\n- 一出现不同就直接进行递归\n- 对于`2,3,3,3` 这种3与2不同，但是3是重复元素的情况，将3排除的做法是：一直循环寻找下一个与3不相同的元素，找到后跳出循环**`return deleteDuplicates(head.next);` **\n\n```\npublic ListNode deleteDuplicates(ListNode head) {\n    if (head == null) return null; \n    \n    if (head.next != null && head.val == head.next.val) {\n        while (head.next != null && head.val == head.next.val) {\n            head = head.next;\n        }\n        return deleteDuplicates(head.next);\n    } else {\n        head.next = deleteDuplicates(head.next);\n    }\n    return head;\n}\n```\n\n---\n\n### 总结：\n\n**`return deleteDuplicates(head.next);`** \n\n直接返回下一个元素的递归结果，一来可以避免链表开头就出现的重复元素，二来可以在遇到`3,4,4,4` 情况的时候，跳过重复的元素4，返回4之后的不同元素或者`null` 。","source":"_posts/leetcode82-RemoveDuplicatesfromSortedListII.md","raw":"title: leetcode82 Remove Duplicates from Sorted List II\n\ndate: 2017/04/01 10:00:00\n\ncategories:\n\n- Study\n\ntags:\n\n- leetcode\n- recursive algorithm\n- linkedlist\n\n---\n\n## leetcode#82 Remove Duplicates from Sorted List II\n\n>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only *distinct* numbers from the original list.\n>\n>For example,\n>Given `1->2->3->3->4->4->5`, return `1->2->5`.\n>Given `1->1->1->2->3`, return `2->3`.\n\n##### 解释：\n\n给定一个**排好序**的链表，要求将链表中的重复元素**全都删除**，只留下不重复的元素。\n\n##### 理解：\n\n本题与`leetcode#83` 都是针对有序链表删除重复元素，但是本题的要求稍微高一点，即不仅仅是删除重复多出的部分，而且不能留下出现了重复的元素。这样一来，就不能像`leetcode#83` 的三行解法一样，直接遍历到链表末尾再递归返回了，而需要将递归操作嵌套在一个**`while` 循环**的条件判断中，而且每一次的比较都需要至少涉及**相邻的三个元素**，以避免漏删重复元素，比如`3-4-4`的情况。\n\n##### 我的解法：\n\n同样，首先是边界的判断。\n\n然后每一次的递归都会给出两个局部变量`tmpMove` 和`tmpFix` ，分别用于**遍历**链表元素和**暂时性地标记**下一个不同的元素（因为重复之后可能还会出现重复，虽然两个重复之间是不同的，但不应该直接移动`head` ，比如`1,1,1,2,2,2` ，虽然`1 2`是不同的，但是这两者都是重复的，此时都不应该将`1 2` 加入到新链表中），只有当；\n\n同时还有一个标志变量`flag` ，用于标志**是否进行了递归赋值**（若没有进行递归赋值&&`tmpMove = null`跳出循环，则说明从上一个不同的元素开始，之后的元素全都是重复的，所以返回一个`null`即可）。\n\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head == null || head.next == null) return head;\n        ListNode tmpMove = head;\n        ListNode tmpFix = head;\n        int flag = 0; // 用于标识区分是否进到了递归赋值的那一步\n        while(tmpMove != null){\n            if(tmpFix.next == null) { return tmpFix; } \n            // 如果是最后一个元素且不同于前面的元素，则将其加入新链表\n            if(tmpMove.val == tmpFix.val) { tmpMove = tmpMove.next; }            \n            else if(tmpFix.val == tmpFix.next.val) { tmpFix = tmpMove; }\n            else {  \n                    head = tmpFix;\n                    head.next = deleteDuplicates(head.next);\n                    flag = 1;\n                    break;\n            }\n        }\n        if(flag == 1) { return head; }\n        else { return null; }\n    }\n}\n```\n\n##### 大神解法：\n\n同样将递归过程嵌套在了循环和条件中，不同的是：\n\n- 没有比较相邻的三个元素\n- 一出现不同就直接进行递归\n- 对于`2,3,3,3` 这种3与2不同，但是3是重复元素的情况，将3排除的做法是：一直循环寻找下一个与3不相同的元素，找到后跳出循环**`return deleteDuplicates(head.next);` **\n\n```\npublic ListNode deleteDuplicates(ListNode head) {\n    if (head == null) return null; \n    \n    if (head.next != null && head.val == head.next.val) {\n        while (head.next != null && head.val == head.next.val) {\n            head = head.next;\n        }\n        return deleteDuplicates(head.next);\n    } else {\n        head.next = deleteDuplicates(head.next);\n    }\n    return head;\n}\n```\n\n---\n\n### 总结：\n\n**`return deleteDuplicates(head.next);`** \n\n直接返回下一个元素的递归结果，一来可以避免链表开头就出现的重复元素，二来可以在遇到`3,4,4,4` 情况的时候，跳过重复的元素4，返回4之后的不同元素或者`null` 。","slug":"leetcode82-RemoveDuplicatesfromSortedListII","published":1,"updated":"2017-04-02T09:26:34.270Z","_id":"cj0yz01tk0000qwupv6tpz459","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"leetcode-82-Remove-Duplicates-from-Sorted-List-II\"><a href=\"#leetcode-82-Remove-Duplicates-from-Sorted-List-II\" class=\"headerlink\" title=\"leetcode#82 Remove Duplicates from Sorted List II\"></a>leetcode#82 Remove Duplicates from Sorted List II</h2><blockquote>\n<p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only <em>distinct</em> numbers from the original list.</p>\n<p>For example,<br>Given <code>1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</code>, return <code>1-&gt;2-&gt;5</code>.<br>Given <code>1-&gt;1-&gt;1-&gt;2-&gt;3</code>, return <code>2-&gt;3</code>.</p>\n</blockquote>\n<h5 id=\"解释：\"><a href=\"#解释：\" class=\"headerlink\" title=\"解释：\"></a>解释：</h5><p>给定一个<strong>排好序</strong>的链表，要求将链表中的重复元素<strong>全都删除</strong>，只留下不重复的元素。</p>\n<h5 id=\"理解：\"><a href=\"#理解：\" class=\"headerlink\" title=\"理解：\"></a>理解：</h5><p>本题与<code>leetcode#83</code> 都是针对有序链表删除重复元素，但是本题的要求稍微高一点，即不仅仅是删除重复多出的部分，而且不能留下出现了重复的元素。这样一来，就不能像<code>leetcode#83</code> 的三行解法一样，直接遍历到链表末尾再递归返回了，而需要将递归操作嵌套在一个<strong><code>while</code> 循环</strong>的条件判断中，而且每一次的比较都需要至少涉及<strong>相邻的三个元素</strong>，以避免漏删重复元素，比如<code>3-4-4</code>的情况。</p>\n<h5 id=\"我的解法：\"><a href=\"#我的解法：\" class=\"headerlink\" title=\"我的解法：\"></a>我的解法：</h5><p>同样，首先是边界的判断。</p>\n<p>然后每一次的递归都会给出两个局部变量<code>tmpMove</code> 和<code>tmpFix</code> ，分别用于<strong>遍历</strong>链表元素和<strong>暂时性地标记</strong>下一个不同的元素（因为重复之后可能还会出现重复，虽然两个重复之间是不同的，但不应该直接移动<code>head</code> ，比如<code>1,1,1,2,2,2</code> ，虽然<code>1 2</code>是不同的，但是这两者都是重复的，此时都不应该将<code>1 2</code> 加入到新链表中），只有当；</p>\n<p>同时还有一个标志变量<code>flag</code> ，用于标志<strong>是否进行了递归赋值</strong>（若没有进行递归赋值&amp;&amp;<code>tmpMove = null</code>跳出循环，则说明从上一个不同的元素开始，之后的元素全都是重复的，所以返回一个<code>null</code>即可）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Definition for singly-linked list.</div><div class=\"line\"> * public class ListNode &#123;</div><div class=\"line\"> *     int val;</div><div class=\"line\"> *     ListNode next;</div><div class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</div><div class=\"line\"> * &#125;</div><div class=\"line\"> */</div><div class=\"line\">public class Solution &#123;</div><div class=\"line\">    public ListNode deleteDuplicates(ListNode head) &#123;</div><div class=\"line\">        if(head == null || head.next == null) return head;</div><div class=\"line\">        ListNode tmpMove = head;</div><div class=\"line\">        ListNode tmpFix = head;</div><div class=\"line\">        int flag = 0; // 用于标识区分是否进到了递归赋值的那一步</div><div class=\"line\">        while(tmpMove != null)&#123;</div><div class=\"line\">            if(tmpFix.next == null) &#123; return tmpFix; &#125; </div><div class=\"line\">            // 如果是最后一个元素且不同于前面的元素，则将其加入新链表</div><div class=\"line\">            if(tmpMove.val == tmpFix.val) &#123; tmpMove = tmpMove.next; &#125;            </div><div class=\"line\">            else if(tmpFix.val == tmpFix.next.val) &#123; tmpFix = tmpMove; &#125;</div><div class=\"line\">            else &#123;  </div><div class=\"line\">                    head = tmpFix;</div><div class=\"line\">                    head.next = deleteDuplicates(head.next);</div><div class=\"line\">                    flag = 1;</div><div class=\"line\">                    break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if(flag == 1) &#123; return head; &#125;</div><div class=\"line\">        else &#123; return null; &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"大神解法：\"><a href=\"#大神解法：\" class=\"headerlink\" title=\"大神解法：\"></a>大神解法：</h5><p>同样将递归过程嵌套在了循环和条件中，不同的是：</p>\n<ul>\n<li>没有比较相邻的三个元素</li>\n<li>一出现不同就直接进行递归</li>\n<li>对于<code>2,3,3,3</code> 这种3与2不同，但是3是重复元素的情况，将3排除的做法是：一直循环寻找下一个与3不相同的元素，找到后跳出循环<strong><code>return deleteDuplicates(head.next);</code> </strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ListNode deleteDuplicates(ListNode head) &#123;</div><div class=\"line\">    if (head == null) return null; </div><div class=\"line\">    </div><div class=\"line\">    if (head.next != null &amp;&amp; head.val == head.next.val) &#123;</div><div class=\"line\">        while (head.next != null &amp;&amp; head.val == head.next.val) &#123;</div><div class=\"line\">            head = head.next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return deleteDuplicates(head.next);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        head.next = deleteDuplicates(head.next);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return head;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p><strong><code>return deleteDuplicates(head.next);</code></strong> </p>\n<p>直接返回下一个元素的递归结果，一来可以避免链表开头就出现的重复元素，二来可以在遇到<code>3,4,4,4</code> 情况的时候，跳过重复的元素4，返回4之后的不同元素或者<code>null</code> 。</p>\n","excerpt":"","more":"<h2 id=\"leetcode-82-Remove-Duplicates-from-Sorted-List-II\"><a href=\"#leetcode-82-Remove-Duplicates-from-Sorted-List-II\" class=\"headerlink\" title=\"leetcode#82 Remove Duplicates from Sorted List II\"></a>leetcode#82 Remove Duplicates from Sorted List II</h2><blockquote>\n<p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only <em>distinct</em> numbers from the original list.</p>\n<p>For example,<br>Given <code>1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</code>, return <code>1-&gt;2-&gt;5</code>.<br>Given <code>1-&gt;1-&gt;1-&gt;2-&gt;3</code>, return <code>2-&gt;3</code>.</p>\n</blockquote>\n<h5 id=\"解释：\"><a href=\"#解释：\" class=\"headerlink\" title=\"解释：\"></a>解释：</h5><p>给定一个<strong>排好序</strong>的链表，要求将链表中的重复元素<strong>全都删除</strong>，只留下不重复的元素。</p>\n<h5 id=\"理解：\"><a href=\"#理解：\" class=\"headerlink\" title=\"理解：\"></a>理解：</h5><p>本题与<code>leetcode#83</code> 都是针对有序链表删除重复元素，但是本题的要求稍微高一点，即不仅仅是删除重复多出的部分，而且不能留下出现了重复的元素。这样一来，就不能像<code>leetcode#83</code> 的三行解法一样，直接遍历到链表末尾再递归返回了，而需要将递归操作嵌套在一个<strong><code>while</code> 循环</strong>的条件判断中，而且每一次的比较都需要至少涉及<strong>相邻的三个元素</strong>，以避免漏删重复元素，比如<code>3-4-4</code>的情况。</p>\n<h5 id=\"我的解法：\"><a href=\"#我的解法：\" class=\"headerlink\" title=\"我的解法：\"></a>我的解法：</h5><p>同样，首先是边界的判断。</p>\n<p>然后每一次的递归都会给出两个局部变量<code>tmpMove</code> 和<code>tmpFix</code> ，分别用于<strong>遍历</strong>链表元素和<strong>暂时性地标记</strong>下一个不同的元素（因为重复之后可能还会出现重复，虽然两个重复之间是不同的，但不应该直接移动<code>head</code> ，比如<code>1,1,1,2,2,2</code> ，虽然<code>1 2</code>是不同的，但是这两者都是重复的，此时都不应该将<code>1 2</code> 加入到新链表中），只有当；</p>\n<p>同时还有一个标志变量<code>flag</code> ，用于标志<strong>是否进行了递归赋值</strong>（若没有进行递归赋值&amp;&amp;<code>tmpMove = null</code>跳出循环，则说明从上一个不同的元素开始，之后的元素全都是重复的，所以返回一个<code>null</code>即可）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Definition for singly-linked list.</div><div class=\"line\"> * public class ListNode &#123;</div><div class=\"line\"> *     int val;</div><div class=\"line\"> *     ListNode next;</div><div class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</div><div class=\"line\"> * &#125;</div><div class=\"line\"> */</div><div class=\"line\">public class Solution &#123;</div><div class=\"line\">    public ListNode deleteDuplicates(ListNode head) &#123;</div><div class=\"line\">        if(head == null || head.next == null) return head;</div><div class=\"line\">        ListNode tmpMove = head;</div><div class=\"line\">        ListNode tmpFix = head;</div><div class=\"line\">        int flag = 0; // 用于标识区分是否进到了递归赋值的那一步</div><div class=\"line\">        while(tmpMove != null)&#123;</div><div class=\"line\">            if(tmpFix.next == null) &#123; return tmpFix; &#125; </div><div class=\"line\">            // 如果是最后一个元素且不同于前面的元素，则将其加入新链表</div><div class=\"line\">            if(tmpMove.val == tmpFix.val) &#123; tmpMove = tmpMove.next; &#125;            </div><div class=\"line\">            else if(tmpFix.val == tmpFix.next.val) &#123; tmpFix = tmpMove; &#125;</div><div class=\"line\">            else &#123;  </div><div class=\"line\">                    head = tmpFix;</div><div class=\"line\">                    head.next = deleteDuplicates(head.next);</div><div class=\"line\">                    flag = 1;</div><div class=\"line\">                    break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if(flag == 1) &#123; return head; &#125;</div><div class=\"line\">        else &#123; return null; &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"大神解法：\"><a href=\"#大神解法：\" class=\"headerlink\" title=\"大神解法：\"></a>大神解法：</h5><p>同样将递归过程嵌套在了循环和条件中，不同的是：</p>\n<ul>\n<li>没有比较相邻的三个元素</li>\n<li>一出现不同就直接进行递归</li>\n<li>对于<code>2,3,3,3</code> 这种3与2不同，但是3是重复元素的情况，将3排除的做法是：一直循环寻找下一个与3不相同的元素，找到后跳出循环<strong><code>return deleteDuplicates(head.next);</code> </strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ListNode deleteDuplicates(ListNode head) &#123;</div><div class=\"line\">    if (head == null) return null; </div><div class=\"line\">    </div><div class=\"line\">    if (head.next != null &amp;&amp; head.val == head.next.val) &#123;</div><div class=\"line\">        while (head.next != null &amp;&amp; head.val == head.next.val) &#123;</div><div class=\"line\">            head = head.next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return deleteDuplicates(head.next);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        head.next = deleteDuplicates(head.next);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return head;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p><strong><code>return deleteDuplicates(head.next);</code></strong> </p>\n<p>直接返回下一个元素的递归结果，一来可以避免链表开头就出现的重复元素，二来可以在遇到<code>3,4,4,4</code> 情况的时候，跳过重复的元素4，返回4之后的不同元素或者<code>null</code> 。</p>\n"},{"title":"leetcode83  Remove Duplicates from Sorted List & VS leetcode#21","date":"2017-03-30T02:30:00.000Z","_content":"\n## leetcode#83  Remove Duplicates from Sorted List\n\n> Given a sorted linked list, delete all duplicates such that each element appear only *once*.\n>\n> For example,\n> Given `1->1->2`, return `1->2`.\n> Given `1->1->2->3->3`, return `1->2->3`.\n\n##### 解释：\n\n给定一个**排好序**的链表，要求删除链表中**重复**的元素，以达到链表中的元素只出现一次。\n\n##### 理解：\n\n由于链表已经排好序了（假设从左往右依次增大），所以只需要比较一下相邻元素的大小即可，如果符合大小排序，只需要移动标记指针（用于标记哪些元素被选进了新的链表中）即可，如果出现相邻元素相等（在排好序的链表里，只能出现这种情况了），则只移动遍历指针（用于遍历所有的元素）而不移动标记指针，直到出现符合排序的情况，再将标记指针指向该元素，从而将该元素加入链表。\n\n##### 我的解法（递归方式）：\n\n首先是边界判断（每一个程序都需要做的一步）；其次是循环和递归。\n\n我的解法中，**递归是镶嵌在循环过程的条件之中**的，也就是通过了条件的判断才能进行递归，确保了每一次递归的准确性、精准性。\n\n从另外一个角度来说，我在解题的时候，其实是想**从头到尾依次遍历**每一个元素，然后将符合条件的元素**依次摘取**出来，放到列表之中，所以出现了一个循环和条件判断的操作。\n\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        /*边界判断*/\n        if(head == null) {return null;}\n        if(head.next == null) {return head;}\n        /*循环找到不相等的元素，再使用递归将该元素作为当前节点.next，之后需要一个递归终结条件，即 break，以免从最后递归回来的时候，链表又再次向后遍历（无限循环）*/\n        ListNode newHead = head;\n        while(newHead.next != null) {\n            if(newHead.next.val > newHead.val) {\n                head.next = deleteDuplicates(head.next);\n                break;\n            }\n            else{\n                newHead = newHead.next;\n            }\n        }\n        return newHead;\n    }\n}\n```\n\n##### 大神解法（递归方式）：\n\n很简洁的语言表达，第一行边界判断，第二行执行递归，第三行根据元素值的比较结果选择或返回当前节点的下一个节点或返回当前节点本身。\n\n该解法的递归的过程中没有做任何的比较判断，**直接一次递归到最后一个元素**，然后**从最后一个元素递归返回**的过程中再一个一个进行比较：最后一个节点肯定会返回自己本身，之前的节点如果相等，则返回其身后的节点，如果不相等则返回当前节点，这样就实现了**从后到前递归联结而成的链表**了。\n\n```\npublic ListNode deleteDuplicates(ListNode head) {\n        if(head == null || head.next == null)return head;\n        head.next = deleteDuplicates(head.next);\n        return head.val == head.next.val ? head.next : head;\n}\n```\n\n##### 总结：\n\n采用递归方式解题，如果条件允许，尽量不要将递归嵌套在循环或者条件等结构体中，一次性递归到最后一个元素，递归返回的时候再进行条件的判断等步骤。\n\n链表的问题是一条链，如果涉及到树的的问题，有很多个树杈可能就会先判断再进入递归。\n\n---\n\n### **比较**：\n\n数组中也有这么一道删除有序数组中重复元素的题\n\n> leetcode#21 Remove Duplicates from Sorted Array\n>\n> Given a sorted array, remove the duplicates in place such that each element appear only *once* and return the new length.\n>\n> Do not allocate extra space for another array, you must do this in place with constant memory.\n>\n> For example,\n> Given input array *nums* = `[1,1,2]`,\n>\n> Your function should return length = `2`, with the first two elements of *nums* being `1` and `2` respectively. It doesn't matter what you leave beyond the new length.\n\n##### 解释：\n\n给定一个**排好序**的数组，将数组中重复的元素删除，并且返回**新数组的长度**。\n\n**不能额外地申请新的空间**。只需要返回新数组的长度，不管该长度之后是不是还有其他的元素。\n\n##### 理解：\n\n（1）排好序，意味着只有可能出现两种大小情况——前者小于后者（无重复，不动），前者等于后者（出现重复，需要删除后者）；\n\n（2）不能额外申请空间，即只能在原数组上进行删除或者移动；\n\n（3）返回新数组的长度，即只需要有一个标记指针指到新数组的末尾即可，不需要管后续还有其他几个元素。\n\n##### 我的解法：\n\n既然不能申请额外空间，那么只能在比较相邻元素遇到重复的时候，将数组的后半部分整体往前搬移一个元素的位置，将重复的元素覆盖，即采用了JAVA的数组复制方法`arraycopy()` ，让数组本身复制自己。这个方法的关键在于，要精确地计算应该将后续的多少个元素，移到前面的哪个位置，比较麻烦也比较容易出错。\n\n```\npublic class Solution {\n    public int removeDuplicates(int[] nums){\n        if(nums.length == 0){\n            return 0;\n        }\n        else{\n            int deleteNum = 0;\n            int currentP = 0;\n            while(deleteNum + currentP != nums.length-1){\n                if (nums[currentP] == nums[currentP + 1]){\n                    System.arraycopy(nums, currentP + 2, nums, currentP + 1, nums.length - (currentP + 2));\n                    deleteNum++;\n                }\n                else{\n                    currentP++;\n                }\n            }\n            return currentP+1;\n        }\n    }\n}\n```\n\n##### 大神解法：\n\n很简洁，第一行判断边界，然后一个`for` 循环，嵌套着条件判断语句：依次提出数组中的元素，与当前标记指针所指的元素比较，如果相等则不移动标记指针，若大于标记指针所指的元素，则将取出的元素加入标记指针所指位置，并将标记指针后移一位（因为是要返回数组长度=数组元素最大序号+1）。对于数组元素第一位，即`arr[0]` 采用直接覆盖。\n\n可以看到，这种方法是**从头开始覆盖数组元素**，然后把符合条件的元素**摘取**出来，放到标记指针所指的位置。\n\n```\npublic int removeDuplicates(int[] nums) {\n    int i = 0;\n    for (int n : nums)\n        if (i == 0 || n > nums[i-1])\n            nums[i++] = n;\n    return i;\n}\n```\n\n---\n\n### **链表VS数组**\n\n链表（特指题目所定义的链表结构），其结构需要之前有`next`指针相互关联，而数组则只需要用序号下标表示即可。\n\n所以链表无法用一个**循环**做到“摘取一个元素，放到当前元素之后”，因为当前的标记指针在循环里是不会类似于下标序号一样+1+1发生变化的，所以最好采用递归的方式，**从后往前**依次将元素添加到**某一次递归过程的标记指针**的`next`位置，然后**返回的结果作为一个整体**，再添加到上一级递归过程的标记指针的`next`指针位置，依次进行直到首位。\n\n---\n\nBy ZGJ.","source":"_posts/leetcode83-RemoveDuplicatesfromSortedList.md","raw":"title: leetcode83  Remove Duplicates from Sorted List & VS leetcode#21\n\ndate: 2017/03/30 10:30:00\n\ncategories:\n\n- Study\n\ntags:\n\n- leetcode\n- linkedlist\n- array\n- recursive algorithm\n\n---\n\n## leetcode#83  Remove Duplicates from Sorted List\n\n> Given a sorted linked list, delete all duplicates such that each element appear only *once*.\n>\n> For example,\n> Given `1->1->2`, return `1->2`.\n> Given `1->1->2->3->3`, return `1->2->3`.\n\n##### 解释：\n\n给定一个**排好序**的链表，要求删除链表中**重复**的元素，以达到链表中的元素只出现一次。\n\n##### 理解：\n\n由于链表已经排好序了（假设从左往右依次增大），所以只需要比较一下相邻元素的大小即可，如果符合大小排序，只需要移动标记指针（用于标记哪些元素被选进了新的链表中）即可，如果出现相邻元素相等（在排好序的链表里，只能出现这种情况了），则只移动遍历指针（用于遍历所有的元素）而不移动标记指针，直到出现符合排序的情况，再将标记指针指向该元素，从而将该元素加入链表。\n\n##### 我的解法（递归方式）：\n\n首先是边界判断（每一个程序都需要做的一步）；其次是循环和递归。\n\n我的解法中，**递归是镶嵌在循环过程的条件之中**的，也就是通过了条件的判断才能进行递归，确保了每一次递归的准确性、精准性。\n\n从另外一个角度来说，我在解题的时候，其实是想**从头到尾依次遍历**每一个元素，然后将符合条件的元素**依次摘取**出来，放到列表之中，所以出现了一个循环和条件判断的操作。\n\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        /*边界判断*/\n        if(head == null) {return null;}\n        if(head.next == null) {return head;}\n        /*循环找到不相等的元素，再使用递归将该元素作为当前节点.next，之后需要一个递归终结条件，即 break，以免从最后递归回来的时候，链表又再次向后遍历（无限循环）*/\n        ListNode newHead = head;\n        while(newHead.next != null) {\n            if(newHead.next.val > newHead.val) {\n                head.next = deleteDuplicates(head.next);\n                break;\n            }\n            else{\n                newHead = newHead.next;\n            }\n        }\n        return newHead;\n    }\n}\n```\n\n##### 大神解法（递归方式）：\n\n很简洁的语言表达，第一行边界判断，第二行执行递归，第三行根据元素值的比较结果选择或返回当前节点的下一个节点或返回当前节点本身。\n\n该解法的递归的过程中没有做任何的比较判断，**直接一次递归到最后一个元素**，然后**从最后一个元素递归返回**的过程中再一个一个进行比较：最后一个节点肯定会返回自己本身，之前的节点如果相等，则返回其身后的节点，如果不相等则返回当前节点，这样就实现了**从后到前递归联结而成的链表**了。\n\n```\npublic ListNode deleteDuplicates(ListNode head) {\n        if(head == null || head.next == null)return head;\n        head.next = deleteDuplicates(head.next);\n        return head.val == head.next.val ? head.next : head;\n}\n```\n\n##### 总结：\n\n采用递归方式解题，如果条件允许，尽量不要将递归嵌套在循环或者条件等结构体中，一次性递归到最后一个元素，递归返回的时候再进行条件的判断等步骤。\n\n链表的问题是一条链，如果涉及到树的的问题，有很多个树杈可能就会先判断再进入递归。\n\n---\n\n### **比较**：\n\n数组中也有这么一道删除有序数组中重复元素的题\n\n> leetcode#21 Remove Duplicates from Sorted Array\n>\n> Given a sorted array, remove the duplicates in place such that each element appear only *once* and return the new length.\n>\n> Do not allocate extra space for another array, you must do this in place with constant memory.\n>\n> For example,\n> Given input array *nums* = `[1,1,2]`,\n>\n> Your function should return length = `2`, with the first two elements of *nums* being `1` and `2` respectively. It doesn't matter what you leave beyond the new length.\n\n##### 解释：\n\n给定一个**排好序**的数组，将数组中重复的元素删除，并且返回**新数组的长度**。\n\n**不能额外地申请新的空间**。只需要返回新数组的长度，不管该长度之后是不是还有其他的元素。\n\n##### 理解：\n\n（1）排好序，意味着只有可能出现两种大小情况——前者小于后者（无重复，不动），前者等于后者（出现重复，需要删除后者）；\n\n（2）不能额外申请空间，即只能在原数组上进行删除或者移动；\n\n（3）返回新数组的长度，即只需要有一个标记指针指到新数组的末尾即可，不需要管后续还有其他几个元素。\n\n##### 我的解法：\n\n既然不能申请额外空间，那么只能在比较相邻元素遇到重复的时候，将数组的后半部分整体往前搬移一个元素的位置，将重复的元素覆盖，即采用了JAVA的数组复制方法`arraycopy()` ，让数组本身复制自己。这个方法的关键在于，要精确地计算应该将后续的多少个元素，移到前面的哪个位置，比较麻烦也比较容易出错。\n\n```\npublic class Solution {\n    public int removeDuplicates(int[] nums){\n        if(nums.length == 0){\n            return 0;\n        }\n        else{\n            int deleteNum = 0;\n            int currentP = 0;\n            while(deleteNum + currentP != nums.length-1){\n                if (nums[currentP] == nums[currentP + 1]){\n                    System.arraycopy(nums, currentP + 2, nums, currentP + 1, nums.length - (currentP + 2));\n                    deleteNum++;\n                }\n                else{\n                    currentP++;\n                }\n            }\n            return currentP+1;\n        }\n    }\n}\n```\n\n##### 大神解法：\n\n很简洁，第一行判断边界，然后一个`for` 循环，嵌套着条件判断语句：依次提出数组中的元素，与当前标记指针所指的元素比较，如果相等则不移动标记指针，若大于标记指针所指的元素，则将取出的元素加入标记指针所指位置，并将标记指针后移一位（因为是要返回数组长度=数组元素最大序号+1）。对于数组元素第一位，即`arr[0]` 采用直接覆盖。\n\n可以看到，这种方法是**从头开始覆盖数组元素**，然后把符合条件的元素**摘取**出来，放到标记指针所指的位置。\n\n```\npublic int removeDuplicates(int[] nums) {\n    int i = 0;\n    for (int n : nums)\n        if (i == 0 || n > nums[i-1])\n            nums[i++] = n;\n    return i;\n}\n```\n\n---\n\n### **链表VS数组**\n\n链表（特指题目所定义的链表结构），其结构需要之前有`next`指针相互关联，而数组则只需要用序号下标表示即可。\n\n所以链表无法用一个**循环**做到“摘取一个元素，放到当前元素之后”，因为当前的标记指针在循环里是不会类似于下标序号一样+1+1发生变化的，所以最好采用递归的方式，**从后往前**依次将元素添加到**某一次递归过程的标记指针**的`next`位置，然后**返回的结果作为一个整体**，再添加到上一级递归过程的标记指针的`next`指针位置，依次进行直到首位。\n\n---\n\nBy ZGJ.","slug":"leetcode83-RemoveDuplicatesfromSortedList","published":1,"updated":"2017-04-02T09:26:26.172Z","_id":"cj0yz01tk0004qwup2i45dgts","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"leetcode-83-Remove-Duplicates-from-Sorted-List\"><a href=\"#leetcode-83-Remove-Duplicates-from-Sorted-List\" class=\"headerlink\" title=\"leetcode#83  Remove Duplicates from Sorted List\"></a>leetcode#83  Remove Duplicates from Sorted List</h2><blockquote>\n<p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p>\n<p>For example,<br>Given <code>1-&gt;1-&gt;2</code>, return <code>1-&gt;2</code>.<br>Given <code>1-&gt;1-&gt;2-&gt;3-&gt;3</code>, return <code>1-&gt;2-&gt;3</code>.</p>\n</blockquote>\n<h5 id=\"解释：\"><a href=\"#解释：\" class=\"headerlink\" title=\"解释：\"></a>解释：</h5><p>给定一个<strong>排好序</strong>的链表，要求删除链表中<strong>重复</strong>的元素，以达到链表中的元素只出现一次。</p>\n<h5 id=\"理解：\"><a href=\"#理解：\" class=\"headerlink\" title=\"理解：\"></a>理解：</h5><p>由于链表已经排好序了（假设从左往右依次增大），所以只需要比较一下相邻元素的大小即可，如果符合大小排序，只需要移动标记指针（用于标记哪些元素被选进了新的链表中）即可，如果出现相邻元素相等（在排好序的链表里，只能出现这种情况了），则只移动遍历指针（用于遍历所有的元素）而不移动标记指针，直到出现符合排序的情况，再将标记指针指向该元素，从而将该元素加入链表。</p>\n<h5 id=\"我的解法（递归方式）：\"><a href=\"#我的解法（递归方式）：\" class=\"headerlink\" title=\"我的解法（递归方式）：\"></a>我的解法（递归方式）：</h5><p>首先是边界判断（每一个程序都需要做的一步）；其次是循环和递归。</p>\n<p>我的解法中，<strong>递归是镶嵌在循环过程的条件之中</strong>的，也就是通过了条件的判断才能进行递归，确保了每一次递归的准确性、精准性。</p>\n<p>从另外一个角度来说，我在解题的时候，其实是想<strong>从头到尾依次遍历</strong>每一个元素，然后将符合条件的元素<strong>依次摘取</strong>出来，放到列表之中，所以出现了一个循环和条件判断的操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Definition for singly-linked list.</div><div class=\"line\"> * public class ListNode &#123;</div><div class=\"line\"> *     int val;</div><div class=\"line\"> *     ListNode next;</div><div class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</div><div class=\"line\"> * &#125;</div><div class=\"line\"> */</div><div class=\"line\">public class Solution &#123;</div><div class=\"line\">    public ListNode deleteDuplicates(ListNode head) &#123;</div><div class=\"line\">        /*边界判断*/</div><div class=\"line\">        if(head == null) &#123;return null;&#125;</div><div class=\"line\">        if(head.next == null) &#123;return head;&#125;</div><div class=\"line\">        /*循环找到不相等的元素，再使用递归将该元素作为当前节点.next，之后需要一个递归终结条件，即 break，以免从最后递归回来的时候，链表又再次向后遍历（无限循环）*/</div><div class=\"line\">        ListNode newHead = head;</div><div class=\"line\">        while(newHead.next != null) &#123;</div><div class=\"line\">            if(newHead.next.val &gt; newHead.val) &#123;</div><div class=\"line\">                head.next = deleteDuplicates(head.next);</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            else&#123;</div><div class=\"line\">                newHead = newHead.next;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return newHead;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"大神解法（递归方式）：\"><a href=\"#大神解法（递归方式）：\" class=\"headerlink\" title=\"大神解法（递归方式）：\"></a>大神解法（递归方式）：</h5><p>很简洁的语言表达，第一行边界判断，第二行执行递归，第三行根据元素值的比较结果选择或返回当前节点的下一个节点或返回当前节点本身。</p>\n<p>该解法的递归的过程中没有做任何的比较判断，<strong>直接一次递归到最后一个元素</strong>，然后<strong>从最后一个元素递归返回</strong>的过程中再一个一个进行比较：最后一个节点肯定会返回自己本身，之前的节点如果相等，则返回其身后的节点，如果不相等则返回当前节点，这样就实现了<strong>从后到前递归联结而成的链表</strong>了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ListNode deleteDuplicates(ListNode head) &#123;</div><div class=\"line\">        if(head == null || head.next == null)return head;</div><div class=\"line\">        head.next = deleteDuplicates(head.next);</div><div class=\"line\">        return head.val == head.next.val ? head.next : head;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h5><p>采用递归方式解题，如果条件允许，尽量不要将递归嵌套在循环或者条件等结构体中，一次性递归到最后一个元素，递归返回的时候再进行条件的判断等步骤。</p>\n<p>链表的问题是一条链，如果涉及到树的的问题，有很多个树杈可能就会先判断再进入递归。</p>\n<hr>\n<h3 id=\"比较：\"><a href=\"#比较：\" class=\"headerlink\" title=\"比较：\"></a><strong>比较</strong>：</h3><p>数组中也有这么一道删除有序数组中重复元素的题</p>\n<blockquote>\n<p>leetcode#21 Remove Duplicates from Sorted Array</p>\n<p>Given a sorted array, remove the duplicates in place such that each element appear only <em>once</em> and return the new length.</p>\n<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>\n<p>For example,<br>Given input array <em>nums</em> = <code>[1,1,2]</code>,</p>\n<p>Your function should return length = <code>2</code>, with the first two elements of <em>nums</em> being <code>1</code> and <code>2</code> respectively. It doesn’t matter what you leave beyond the new length.</p>\n</blockquote>\n<h5 id=\"解释：-1\"><a href=\"#解释：-1\" class=\"headerlink\" title=\"解释：\"></a>解释：</h5><p>给定一个<strong>排好序</strong>的数组，将数组中重复的元素删除，并且返回<strong>新数组的长度</strong>。</p>\n<p><strong>不能额外地申请新的空间</strong>。只需要返回新数组的长度，不管该长度之后是不是还有其他的元素。</p>\n<h5 id=\"理解：-1\"><a href=\"#理解：-1\" class=\"headerlink\" title=\"理解：\"></a>理解：</h5><p>（1）排好序，意味着只有可能出现两种大小情况——前者小于后者（无重复，不动），前者等于后者（出现重复，需要删除后者）；</p>\n<p>（2）不能额外申请空间，即只能在原数组上进行删除或者移动；</p>\n<p>（3）返回新数组的长度，即只需要有一个标记指针指到新数组的末尾即可，不需要管后续还有其他几个元素。</p>\n<h5 id=\"我的解法：\"><a href=\"#我的解法：\" class=\"headerlink\" title=\"我的解法：\"></a>我的解法：</h5><p>既然不能申请额外空间，那么只能在比较相邻元素遇到重复的时候，将数组的后半部分整体往前搬移一个元素的位置，将重复的元素覆盖，即采用了JAVA的数组复制方法<code>arraycopy()</code> ，让数组本身复制自己。这个方法的关键在于，要精确地计算应该将后续的多少个元素，移到前面的哪个位置，比较麻烦也比较容易出错。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Solution &#123;</div><div class=\"line\">    public int removeDuplicates(int[] nums)&#123;</div><div class=\"line\">        if(nums.length == 0)&#123;</div><div class=\"line\">            return 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else&#123;</div><div class=\"line\">            int deleteNum = 0;</div><div class=\"line\">            int currentP = 0;</div><div class=\"line\">            while(deleteNum + currentP != nums.length-1)&#123;</div><div class=\"line\">                if (nums[currentP] == nums[currentP + 1])&#123;</div><div class=\"line\">                    System.arraycopy(nums, currentP + 2, nums, currentP + 1, nums.length - (currentP + 2));</div><div class=\"line\">                    deleteNum++;</div><div class=\"line\">                &#125;</div><div class=\"line\">                else&#123;</div><div class=\"line\">                    currentP++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return currentP+1;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"大神解法：\"><a href=\"#大神解法：\" class=\"headerlink\" title=\"大神解法：\"></a>大神解法：</h5><p>很简洁，第一行判断边界，然后一个<code>for</code> 循环，嵌套着条件判断语句：依次提出数组中的元素，与当前标记指针所指的元素比较，如果相等则不移动标记指针，若大于标记指针所指的元素，则将取出的元素加入标记指针所指位置，并将标记指针后移一位（因为是要返回数组长度=数组元素最大序号+1）。对于数组元素第一位，即<code>arr[0]</code> 采用直接覆盖。</p>\n<p>可以看到，这种方法是<strong>从头开始覆盖数组元素</strong>，然后把符合条件的元素<strong>摘取</strong>出来，放到标记指针所指的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public int removeDuplicates(int[] nums) &#123;</div><div class=\"line\">    int i = 0;</div><div class=\"line\">    for (int n : nums)</div><div class=\"line\">        if (i == 0 || n &gt; nums[i-1])</div><div class=\"line\">            nums[i++] = n;</div><div class=\"line\">    return i;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"链表VS数组\"><a href=\"#链表VS数组\" class=\"headerlink\" title=\"链表VS数组\"></a><strong>链表VS数组</strong></h3><p>链表（特指题目所定义的链表结构），其结构需要之前有<code>next</code>指针相互关联，而数组则只需要用序号下标表示即可。</p>\n<p>所以链表无法用一个<strong>循环</strong>做到“摘取一个元素，放到当前元素之后”，因为当前的标记指针在循环里是不会类似于下标序号一样+1+1发生变化的，所以最好采用递归的方式，<strong>从后往前</strong>依次将元素添加到<strong>某一次递归过程的标记指针</strong>的<code>next</code>位置，然后<strong>返回的结果作为一个整体</strong>，再添加到上一级递归过程的标记指针的<code>next</code>指针位置，依次进行直到首位。</p>\n<hr>\n<p>By ZGJ.</p>\n","excerpt":"","more":"<h2 id=\"leetcode-83-Remove-Duplicates-from-Sorted-List\"><a href=\"#leetcode-83-Remove-Duplicates-from-Sorted-List\" class=\"headerlink\" title=\"leetcode#83  Remove Duplicates from Sorted List\"></a>leetcode#83  Remove Duplicates from Sorted List</h2><blockquote>\n<p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p>\n<p>For example,<br>Given <code>1-&gt;1-&gt;2</code>, return <code>1-&gt;2</code>.<br>Given <code>1-&gt;1-&gt;2-&gt;3-&gt;3</code>, return <code>1-&gt;2-&gt;3</code>.</p>\n</blockquote>\n<h5 id=\"解释：\"><a href=\"#解释：\" class=\"headerlink\" title=\"解释：\"></a>解释：</h5><p>给定一个<strong>排好序</strong>的链表，要求删除链表中<strong>重复</strong>的元素，以达到链表中的元素只出现一次。</p>\n<h5 id=\"理解：\"><a href=\"#理解：\" class=\"headerlink\" title=\"理解：\"></a>理解：</h5><p>由于链表已经排好序了（假设从左往右依次增大），所以只需要比较一下相邻元素的大小即可，如果符合大小排序，只需要移动标记指针（用于标记哪些元素被选进了新的链表中）即可，如果出现相邻元素相等（在排好序的链表里，只能出现这种情况了），则只移动遍历指针（用于遍历所有的元素）而不移动标记指针，直到出现符合排序的情况，再将标记指针指向该元素，从而将该元素加入链表。</p>\n<h5 id=\"我的解法（递归方式）：\"><a href=\"#我的解法（递归方式）：\" class=\"headerlink\" title=\"我的解法（递归方式）：\"></a>我的解法（递归方式）：</h5><p>首先是边界判断（每一个程序都需要做的一步）；其次是循环和递归。</p>\n<p>我的解法中，<strong>递归是镶嵌在循环过程的条件之中</strong>的，也就是通过了条件的判断才能进行递归，确保了每一次递归的准确性、精准性。</p>\n<p>从另外一个角度来说，我在解题的时候，其实是想<strong>从头到尾依次遍历</strong>每一个元素，然后将符合条件的元素<strong>依次摘取</strong>出来，放到列表之中，所以出现了一个循环和条件判断的操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Definition for singly-linked list.</div><div class=\"line\"> * public class ListNode &#123;</div><div class=\"line\"> *     int val;</div><div class=\"line\"> *     ListNode next;</div><div class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</div><div class=\"line\"> * &#125;</div><div class=\"line\"> */</div><div class=\"line\">public class Solution &#123;</div><div class=\"line\">    public ListNode deleteDuplicates(ListNode head) &#123;</div><div class=\"line\">        /*边界判断*/</div><div class=\"line\">        if(head == null) &#123;return null;&#125;</div><div class=\"line\">        if(head.next == null) &#123;return head;&#125;</div><div class=\"line\">        /*循环找到不相等的元素，再使用递归将该元素作为当前节点.next，之后需要一个递归终结条件，即 break，以免从最后递归回来的时候，链表又再次向后遍历（无限循环）*/</div><div class=\"line\">        ListNode newHead = head;</div><div class=\"line\">        while(newHead.next != null) &#123;</div><div class=\"line\">            if(newHead.next.val &gt; newHead.val) &#123;</div><div class=\"line\">                head.next = deleteDuplicates(head.next);</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            else&#123;</div><div class=\"line\">                newHead = newHead.next;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return newHead;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"大神解法（递归方式）：\"><a href=\"#大神解法（递归方式）：\" class=\"headerlink\" title=\"大神解法（递归方式）：\"></a>大神解法（递归方式）：</h5><p>很简洁的语言表达，第一行边界判断，第二行执行递归，第三行根据元素值的比较结果选择或返回当前节点的下一个节点或返回当前节点本身。</p>\n<p>该解法的递归的过程中没有做任何的比较判断，<strong>直接一次递归到最后一个元素</strong>，然后<strong>从最后一个元素递归返回</strong>的过程中再一个一个进行比较：最后一个节点肯定会返回自己本身，之前的节点如果相等，则返回其身后的节点，如果不相等则返回当前节点，这样就实现了<strong>从后到前递归联结而成的链表</strong>了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ListNode deleteDuplicates(ListNode head) &#123;</div><div class=\"line\">        if(head == null || head.next == null)return head;</div><div class=\"line\">        head.next = deleteDuplicates(head.next);</div><div class=\"line\">        return head.val == head.next.val ? head.next : head;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h5><p>采用递归方式解题，如果条件允许，尽量不要将递归嵌套在循环或者条件等结构体中，一次性递归到最后一个元素，递归返回的时候再进行条件的判断等步骤。</p>\n<p>链表的问题是一条链，如果涉及到树的的问题，有很多个树杈可能就会先判断再进入递归。</p>\n<hr>\n<h3 id=\"比较：\"><a href=\"#比较：\" class=\"headerlink\" title=\"比较：\"></a><strong>比较</strong>：</h3><p>数组中也有这么一道删除有序数组中重复元素的题</p>\n<blockquote>\n<p>leetcode#21 Remove Duplicates from Sorted Array</p>\n<p>Given a sorted array, remove the duplicates in place such that each element appear only <em>once</em> and return the new length.</p>\n<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>\n<p>For example,<br>Given input array <em>nums</em> = <code>[1,1,2]</code>,</p>\n<p>Your function should return length = <code>2</code>, with the first two elements of <em>nums</em> being <code>1</code> and <code>2</code> respectively. It doesn’t matter what you leave beyond the new length.</p>\n</blockquote>\n<h5 id=\"解释：-1\"><a href=\"#解释：-1\" class=\"headerlink\" title=\"解释：\"></a>解释：</h5><p>给定一个<strong>排好序</strong>的数组，将数组中重复的元素删除，并且返回<strong>新数组的长度</strong>。</p>\n<p><strong>不能额外地申请新的空间</strong>。只需要返回新数组的长度，不管该长度之后是不是还有其他的元素。</p>\n<h5 id=\"理解：-1\"><a href=\"#理解：-1\" class=\"headerlink\" title=\"理解：\"></a>理解：</h5><p>（1）排好序，意味着只有可能出现两种大小情况——前者小于后者（无重复，不动），前者等于后者（出现重复，需要删除后者）；</p>\n<p>（2）不能额外申请空间，即只能在原数组上进行删除或者移动；</p>\n<p>（3）返回新数组的长度，即只需要有一个标记指针指到新数组的末尾即可，不需要管后续还有其他几个元素。</p>\n<h5 id=\"我的解法：\"><a href=\"#我的解法：\" class=\"headerlink\" title=\"我的解法：\"></a>我的解法：</h5><p>既然不能申请额外空间，那么只能在比较相邻元素遇到重复的时候，将数组的后半部分整体往前搬移一个元素的位置，将重复的元素覆盖，即采用了JAVA的数组复制方法<code>arraycopy()</code> ，让数组本身复制自己。这个方法的关键在于，要精确地计算应该将后续的多少个元素，移到前面的哪个位置，比较麻烦也比较容易出错。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Solution &#123;</div><div class=\"line\">    public int removeDuplicates(int[] nums)&#123;</div><div class=\"line\">        if(nums.length == 0)&#123;</div><div class=\"line\">            return 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else&#123;</div><div class=\"line\">            int deleteNum = 0;</div><div class=\"line\">            int currentP = 0;</div><div class=\"line\">            while(deleteNum + currentP != nums.length-1)&#123;</div><div class=\"line\">                if (nums[currentP] == nums[currentP + 1])&#123;</div><div class=\"line\">                    System.arraycopy(nums, currentP + 2, nums, currentP + 1, nums.length - (currentP + 2));</div><div class=\"line\">                    deleteNum++;</div><div class=\"line\">                &#125;</div><div class=\"line\">                else&#123;</div><div class=\"line\">                    currentP++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return currentP+1;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"大神解法：\"><a href=\"#大神解法：\" class=\"headerlink\" title=\"大神解法：\"></a>大神解法：</h5><p>很简洁，第一行判断边界，然后一个<code>for</code> 循环，嵌套着条件判断语句：依次提出数组中的元素，与当前标记指针所指的元素比较，如果相等则不移动标记指针，若大于标记指针所指的元素，则将取出的元素加入标记指针所指位置，并将标记指针后移一位（因为是要返回数组长度=数组元素最大序号+1）。对于数组元素第一位，即<code>arr[0]</code> 采用直接覆盖。</p>\n<p>可以看到，这种方法是<strong>从头开始覆盖数组元素</strong>，然后把符合条件的元素<strong>摘取</strong>出来，放到标记指针所指的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public int removeDuplicates(int[] nums) &#123;</div><div class=\"line\">    int i = 0;</div><div class=\"line\">    for (int n : nums)</div><div class=\"line\">        if (i == 0 || n &gt; nums[i-1])</div><div class=\"line\">            nums[i++] = n;</div><div class=\"line\">    return i;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"链表VS数组\"><a href=\"#链表VS数组\" class=\"headerlink\" title=\"链表VS数组\"></a><strong>链表VS数组</strong></h3><p>链表（特指题目所定义的链表结构），其结构需要之前有<code>next</code>指针相互关联，而数组则只需要用序号下标表示即可。</p>\n<p>所以链表无法用一个<strong>循环</strong>做到“摘取一个元素，放到当前元素之后”，因为当前的标记指针在循环里是不会类似于下标序号一样+1+1发生变化的，所以最好采用递归的方式，<strong>从后往前</strong>依次将元素添加到<strong>某一次递归过程的标记指针</strong>的<code>next</code>位置，然后<strong>返回的结果作为一个整体</strong>，再添加到上一级递归过程的标记指针的<code>next</code>指针位置，依次进行直到首位。</p>\n<hr>\n<p>By ZGJ.</p>\n"},{"title":"leetcode141 LinkedListCycle","_content":"\n## leetcode#141 Linked List Cycle \n\n>Given a linked list, determine if it has a cycle in it.\n>\n>solve it without using extra space.\n\n##### 解释：\n\n给定一个链表，判断链表是否有环。（最好不使用额外的存储空间）\n\n##### 理解：\n\n本题的链表中的每一个节点只有一个`next` ，即每一个节点连接的下一个节点是为唯一的，不会出现分支。只是不知道如果出现环路，环路的起止点是哪一个节点。\n\n##### 我的解法：\n\n既然是**单链表**，那么就设置两个指针`slow`和`fast` ，都用于遍历链表的所有节点，其中`slow` 每次移动一个节点的位置，`fast` 每次移动两个节点的位置，如果不存在环路，则`fast` 将在之后的遍历中永远不会与`slow` 相遇，并最后到达链表的末尾；如果存在环路，则两个不同遍历速度的指针肯定会在某一个时间相遇，即`slow = fast` 。\n\n```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        \n        while(fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if(slow == fast) {\n                break;\n            }\n        }\n        return (fast == null || fast.next == null)? false : true;\n    }\n}\n```\n\n##### 大神解法：\n\n基本思路都是相同的。\n\n```\npublic boolean hasCycle(ListNode head) {\n    if(head==null) return false;\n    ListNode walker = head;\n    ListNode runner = head;\n    while(runner.next!=null && runner.next.next!=null) {\n        walker = walker.next;\n        runner = runner.next.next;\n        if(walker==runner) return true;\n    }\n    return false;\n}\n```\n\n### 总结：\n\n本题可以形象地用**赛跑**来描述：如果跑直线，那么跑得慢的人将永远追不上跑得快的人，两人也就永远不会相遇；如果跑圈，那么跑的快的人将在某一时间追上跑得慢的人，两人将在未来的某一个时间点相遇。\n\n","source":"_posts/leetcode141-LinkedListCycle.md","raw":"title: leetcode141 LinkedListCycle\n\ncategories:\n\n- Study\n\ntags:\n\n- leetcode\n- linkedlist\n\n---\n\n## leetcode#141 Linked List Cycle \n\n>Given a linked list, determine if it has a cycle in it.\n>\n>solve it without using extra space.\n\n##### 解释：\n\n给定一个链表，判断链表是否有环。（最好不使用额外的存储空间）\n\n##### 理解：\n\n本题的链表中的每一个节点只有一个`next` ，即每一个节点连接的下一个节点是为唯一的，不会出现分支。只是不知道如果出现环路，环路的起止点是哪一个节点。\n\n##### 我的解法：\n\n既然是**单链表**，那么就设置两个指针`slow`和`fast` ，都用于遍历链表的所有节点，其中`slow` 每次移动一个节点的位置，`fast` 每次移动两个节点的位置，如果不存在环路，则`fast` 将在之后的遍历中永远不会与`slow` 相遇，并最后到达链表的末尾；如果存在环路，则两个不同遍历速度的指针肯定会在某一个时间相遇，即`slow = fast` 。\n\n```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        \n        while(fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if(slow == fast) {\n                break;\n            }\n        }\n        return (fast == null || fast.next == null)? false : true;\n    }\n}\n```\n\n##### 大神解法：\n\n基本思路都是相同的。\n\n```\npublic boolean hasCycle(ListNode head) {\n    if(head==null) return false;\n    ListNode walker = head;\n    ListNode runner = head;\n    while(runner.next!=null && runner.next.next!=null) {\n        walker = walker.next;\n        runner = runner.next.next;\n        if(walker==runner) return true;\n    }\n    return false;\n}\n```\n\n### 总结：\n\n本题可以形象地用**赛跑**来描述：如果跑直线，那么跑得慢的人将永远追不上跑得快的人，两人也就永远不会相遇；如果跑圈，那么跑的快的人将在某一时间追上跑得慢的人，两人将在未来的某一个时间点相遇。\n\n","slug":"leetcode141-LinkedListCycle","published":1,"date":"2017-04-01T09:07:56.153Z","updated":"2017-04-02T09:26:20.486Z","_id":"cj0z0ce5s0000m8up0nk8ud29","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"leetcode-141-Linked-List-Cycle\"><a href=\"#leetcode-141-Linked-List-Cycle\" class=\"headerlink\" title=\"leetcode#141 Linked List Cycle\"></a>leetcode#141 Linked List Cycle</h2><blockquote>\n<p>Given a linked list, determine if it has a cycle in it.</p>\n<p>solve it without using extra space.</p>\n</blockquote>\n<h5 id=\"解释：\"><a href=\"#解释：\" class=\"headerlink\" title=\"解释：\"></a>解释：</h5><p>给定一个链表，判断链表是否有环。（最好不使用额外的存储空间）</p>\n<h5 id=\"理解：\"><a href=\"#理解：\" class=\"headerlink\" title=\"理解：\"></a>理解：</h5><p>本题的链表中的每一个节点只有一个<code>next</code> ，即每一个节点连接的下一个节点是为唯一的，不会出现分支。只是不知道如果出现环路，环路的起止点是哪一个节点。</p>\n<h5 id=\"我的解法：\"><a href=\"#我的解法：\" class=\"headerlink\" title=\"我的解法：\"></a>我的解法：</h5><p>既然是<strong>单链表</strong>，那么就设置两个指针<code>slow</code>和<code>fast</code> ，都用于遍历链表的所有节点，其中<code>slow</code> 每次移动一个节点的位置，<code>fast</code> 每次移动两个节点的位置，如果不存在环路，则<code>fast</code> 将在之后的遍历中永远不会与<code>slow</code> 相遇，并最后到达链表的末尾；如果存在环路，则两个不同遍历速度的指针肯定会在某一个时间相遇，即<code>slow = fast</code> 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Definition for singly-linked list.</div><div class=\"line\"> * class ListNode &#123;</div><div class=\"line\"> *     int val;</div><div class=\"line\"> *     ListNode next;</div><div class=\"line\"> *     ListNode(int x) &#123;</div><div class=\"line\"> *         val = x;</div><div class=\"line\"> *         next = null;</div><div class=\"line\"> *     &#125;</div><div class=\"line\"> * &#125;</div><div class=\"line\"> */</div><div class=\"line\">public class Solution &#123;</div><div class=\"line\">    public boolean hasCycle(ListNode head) &#123;</div><div class=\"line\">        ListNode slow = head;</div><div class=\"line\">        ListNode fast = head;</div><div class=\"line\">        </div><div class=\"line\">        while(fast != null &amp;&amp; fast.next != null) &#123;</div><div class=\"line\">            slow = slow.next;</div><div class=\"line\">            fast = fast.next.next;</div><div class=\"line\">            if(slow == fast) &#123;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return (fast == null || fast.next == null)? false : true;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"大神解法：\"><a href=\"#大神解法：\" class=\"headerlink\" title=\"大神解法：\"></a>大神解法：</h5><p>基本思路都是相同的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean hasCycle(ListNode head) &#123;</div><div class=\"line\">    if(head==null) return false;</div><div class=\"line\">    ListNode walker = head;</div><div class=\"line\">    ListNode runner = head;</div><div class=\"line\">    while(runner.next!=null &amp;&amp; runner.next.next!=null) &#123;</div><div class=\"line\">        walker = walker.next;</div><div class=\"line\">        runner = runner.next.next;</div><div class=\"line\">        if(walker==runner) return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>本题可以形象地用<strong>赛跑</strong>来描述：如果跑直线，那么跑得慢的人将永远追不上跑得快的人，两人也就永远不会相遇；如果跑圈，那么跑的快的人将在某一时间追上跑得慢的人，两人将在未来的某一个时间点相遇。</p>\n","excerpt":"","more":"<h2 id=\"leetcode-141-Linked-List-Cycle\"><a href=\"#leetcode-141-Linked-List-Cycle\" class=\"headerlink\" title=\"leetcode#141 Linked List Cycle\"></a>leetcode#141 Linked List Cycle</h2><blockquote>\n<p>Given a linked list, determine if it has a cycle in it.</p>\n<p>solve it without using extra space.</p>\n</blockquote>\n<h5 id=\"解释：\"><a href=\"#解释：\" class=\"headerlink\" title=\"解释：\"></a>解释：</h5><p>给定一个链表，判断链表是否有环。（最好不使用额外的存储空间）</p>\n<h5 id=\"理解：\"><a href=\"#理解：\" class=\"headerlink\" title=\"理解：\"></a>理解：</h5><p>本题的链表中的每一个节点只有一个<code>next</code> ，即每一个节点连接的下一个节点是为唯一的，不会出现分支。只是不知道如果出现环路，环路的起止点是哪一个节点。</p>\n<h5 id=\"我的解法：\"><a href=\"#我的解法：\" class=\"headerlink\" title=\"我的解法：\"></a>我的解法：</h5><p>既然是<strong>单链表</strong>，那么就设置两个指针<code>slow</code>和<code>fast</code> ，都用于遍历链表的所有节点，其中<code>slow</code> 每次移动一个节点的位置，<code>fast</code> 每次移动两个节点的位置，如果不存在环路，则<code>fast</code> 将在之后的遍历中永远不会与<code>slow</code> 相遇，并最后到达链表的末尾；如果存在环路，则两个不同遍历速度的指针肯定会在某一个时间相遇，即<code>slow = fast</code> 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Definition for singly-linked list.</div><div class=\"line\"> * class ListNode &#123;</div><div class=\"line\"> *     int val;</div><div class=\"line\"> *     ListNode next;</div><div class=\"line\"> *     ListNode(int x) &#123;</div><div class=\"line\"> *         val = x;</div><div class=\"line\"> *         next = null;</div><div class=\"line\"> *     &#125;</div><div class=\"line\"> * &#125;</div><div class=\"line\"> */</div><div class=\"line\">public class Solution &#123;</div><div class=\"line\">    public boolean hasCycle(ListNode head) &#123;</div><div class=\"line\">        ListNode slow = head;</div><div class=\"line\">        ListNode fast = head;</div><div class=\"line\">        </div><div class=\"line\">        while(fast != null &amp;&amp; fast.next != null) &#123;</div><div class=\"line\">            slow = slow.next;</div><div class=\"line\">            fast = fast.next.next;</div><div class=\"line\">            if(slow == fast) &#123;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return (fast == null || fast.next == null)? false : true;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"大神解法：\"><a href=\"#大神解法：\" class=\"headerlink\" title=\"大神解法：\"></a>大神解法：</h5><p>基本思路都是相同的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean hasCycle(ListNode head) &#123;</div><div class=\"line\">    if(head==null) return false;</div><div class=\"line\">    ListNode walker = head;</div><div class=\"line\">    ListNode runner = head;</div><div class=\"line\">    while(runner.next!=null &amp;&amp; runner.next.next!=null) &#123;</div><div class=\"line\">        walker = walker.next;</div><div class=\"line\">        runner = runner.next.next;</div><div class=\"line\">        if(walker==runner) return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>本题可以形象地用<strong>赛跑</strong>来描述：如果跑直线，那么跑得慢的人将永远追不上跑得快的人，两人也就永远不会相遇；如果跑圈，那么跑的快的人将在某一时间追上跑得慢的人，两人将在未来的某一个时间点相遇。</p>\n"},{"title":"leetcode142 Linked List Cycle II","date":"2017-04-02T09:00:00.000Z","_content":"\n## leetcode#142 Linked List Cycle II \n\n>Given a linked list, return the node where the cycle begins. If there is no cycle, return `null`.\n>\n>Solve it without using extra space.\n\n##### 解释：\n\n给定一个**单链表**，如果单链表中存在环路，则返回**环路起始的节点**；如果没有环路，则返回`null`。\n\n##### 理解：\n\n这个题可以借鉴leetcode#141的思路，并接着扩展代码即可。在leetcode#141判断的基础上，如果存在环路，则判断`head`和`slow`是否相同，若相同，则`head`所指的节点就是环路起始的节点，若不同，则将`head`移动到下一个节点，同时让`slow`在环路中跑一圈，看看`head`会不会与`slow`相遇。\n\n##### 我的解法：\n\n```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        \n        while(fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if(slow == fast) {\n                break;\n            }\n        }\n        if(fast == null || fast.next == null) { return null; }\n        else {\n            while(head != slow) {\n                if(head != slow && slow != fast) { slow = slow.next; }\n                else if(head != slow && slow == fast) {\n                    slow = slow.next;\n                    head = head.next;\n                }\n                else { break; }\n            }\n            return head;\n        }\n    }\n}\n```\n\n##### 大神解法：\n\n这道题中蕴含着一个**数学关系**，即`fast`走过的路程是`slow`的两倍。\n\n设`head`距离环路起始节点的路程是A，`slow`在走过路程A之前是不会与`fast`相遇的；`slow`离开环路起始节点B路程时，与走完一圈环路的`fast` 相遇；环路的总长度是N。\n\n所以：\n\n`slow`走过的路程是：A+B\n\n`fast`走过的路程是：2(A+B)\n\n环路总长度是：N = 2(A+B)-(A+B) = A+B\n\n此时，做出一张**距离关系图**之后就会发现，从当前`slow`和`fast`相遇的节点开始，再走A路程，就可以到达环路起始节点位置，而从`head`节点到环路起始位置的路程正好是A。所以，只需要再用一个指针`slow2`从`head`出发，与`slow`同步行走同样的路程，必然会在环路起始的节点相遇。\n\n```\npublic class Solution {\n            public ListNode detectCycle(ListNode head) {\n                ListNode slow = head;\n                ListNode fast = head;\n\n                while (fast!=null && fast.next!=null){\n                    fast = fast.next.next;\n                    slow = slow.next;\n                    \n                    if (fast == slow){\n                        ListNode slow2 = head; \n                        while (slow2 != slow){\n                            slow = slow.next;\n                            slow2 = slow2.next;\n                        }\n                        return slow;\n                    }\n                }\n                return null;\n            }\n        }\n```\n\n### 总结\n\n两种方法都是在leetcode#141原有的基础上进行扩展，但是我的解法没有发现其中蕴含的简单数学关系，而是采取了暴力解法，实在是不应该。\n\n复杂的问题十有八九都会蕴含一定的数学关系或者数学规律，找出这些关系和规律，解题方法将大幅度优化。\n\n","source":"_posts/leetcode142-LinkedListCycleII.md","raw":"title: leetcode142 Linked List Cycle II\n\ndate: 2017/04/02 17:00:00\n\ncategories:\n\n- Study\n\ntags:\n\n- leetcode\n- linkedlist\n\n---\n\n## leetcode#142 Linked List Cycle II \n\n>Given a linked list, return the node where the cycle begins. If there is no cycle, return `null`.\n>\n>Solve it without using extra space.\n\n##### 解释：\n\n给定一个**单链表**，如果单链表中存在环路，则返回**环路起始的节点**；如果没有环路，则返回`null`。\n\n##### 理解：\n\n这个题可以借鉴leetcode#141的思路，并接着扩展代码即可。在leetcode#141判断的基础上，如果存在环路，则判断`head`和`slow`是否相同，若相同，则`head`所指的节点就是环路起始的节点，若不同，则将`head`移动到下一个节点，同时让`slow`在环路中跑一圈，看看`head`会不会与`slow`相遇。\n\n##### 我的解法：\n\n```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        \n        while(fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if(slow == fast) {\n                break;\n            }\n        }\n        if(fast == null || fast.next == null) { return null; }\n        else {\n            while(head != slow) {\n                if(head != slow && slow != fast) { slow = slow.next; }\n                else if(head != slow && slow == fast) {\n                    slow = slow.next;\n                    head = head.next;\n                }\n                else { break; }\n            }\n            return head;\n        }\n    }\n}\n```\n\n##### 大神解法：\n\n这道题中蕴含着一个**数学关系**，即`fast`走过的路程是`slow`的两倍。\n\n设`head`距离环路起始节点的路程是A，`slow`在走过路程A之前是不会与`fast`相遇的；`slow`离开环路起始节点B路程时，与走完一圈环路的`fast` 相遇；环路的总长度是N。\n\n所以：\n\n`slow`走过的路程是：A+B\n\n`fast`走过的路程是：2(A+B)\n\n环路总长度是：N = 2(A+B)-(A+B) = A+B\n\n此时，做出一张**距离关系图**之后就会发现，从当前`slow`和`fast`相遇的节点开始，再走A路程，就可以到达环路起始节点位置，而从`head`节点到环路起始位置的路程正好是A。所以，只需要再用一个指针`slow2`从`head`出发，与`slow`同步行走同样的路程，必然会在环路起始的节点相遇。\n\n```\npublic class Solution {\n            public ListNode detectCycle(ListNode head) {\n                ListNode slow = head;\n                ListNode fast = head;\n\n                while (fast!=null && fast.next!=null){\n                    fast = fast.next.next;\n                    slow = slow.next;\n                    \n                    if (fast == slow){\n                        ListNode slow2 = head; \n                        while (slow2 != slow){\n                            slow = slow.next;\n                            slow2 = slow2.next;\n                        }\n                        return slow;\n                    }\n                }\n                return null;\n            }\n        }\n```\n\n### 总结\n\n两种方法都是在leetcode#141原有的基础上进行扩展，但是我的解法没有发现其中蕴含的简单数学关系，而是采取了暴力解法，实在是不应该。\n\n复杂的问题十有八九都会蕴含一定的数学关系或者数学规律，找出这些关系和规律，解题方法将大幅度优化。\n\n","slug":"leetcode142-LinkedListCycleII","published":1,"updated":"2017-04-02T09:25:58.376Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj10hihax00006kup0go1cyyi","content":"<h2 id=\"leetcode-142-Linked-List-Cycle-II\"><a href=\"#leetcode-142-Linked-List-Cycle-II\" class=\"headerlink\" title=\"leetcode#142 Linked List Cycle II\"></a>leetcode#142 Linked List Cycle II</h2><blockquote>\n<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p>\n<p>Solve it without using extra space.</p>\n</blockquote>\n<h5 id=\"解释：\"><a href=\"#解释：\" class=\"headerlink\" title=\"解释：\"></a>解释：</h5><p>给定一个<strong>单链表</strong>，如果单链表中存在环路，则返回<strong>环路起始的节点</strong>；如果没有环路，则返回<code>null</code>。</p>\n<h5 id=\"理解：\"><a href=\"#理解：\" class=\"headerlink\" title=\"理解：\"></a>理解：</h5><p>这个题可以借鉴leetcode#141的思路，并接着扩展代码即可。在leetcode#141判断的基础上，如果存在环路，则判断<code>head</code>和<code>slow</code>是否相同，若相同，则<code>head</code>所指的节点就是环路起始的节点，若不同，则将<code>head</code>移动到下一个节点，同时让<code>slow</code>在环路中跑一圈，看看<code>head</code>会不会与<code>slow</code>相遇。</p>\n<h5 id=\"我的解法：\"><a href=\"#我的解法：\" class=\"headerlink\" title=\"我的解法：\"></a>我的解法：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Definition for singly-linked list.</div><div class=\"line\"> * class ListNode &#123;</div><div class=\"line\"> *     int val;</div><div class=\"line\"> *     ListNode next;</div><div class=\"line\"> *     ListNode(int x) &#123;</div><div class=\"line\"> *         val = x;</div><div class=\"line\"> *         next = null;</div><div class=\"line\"> *     &#125;</div><div class=\"line\"> * &#125;</div><div class=\"line\"> */</div><div class=\"line\">public class Solution &#123;</div><div class=\"line\">    public ListNode detectCycle(ListNode head) &#123;</div><div class=\"line\">        ListNode slow = head;</div><div class=\"line\">        ListNode fast = head;</div><div class=\"line\">        </div><div class=\"line\">        while(fast != null &amp;&amp; fast.next != null) &#123;</div><div class=\"line\">            slow = slow.next;</div><div class=\"line\">            fast = fast.next.next;</div><div class=\"line\">            if(slow == fast) &#123;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if(fast == null || fast.next == null) &#123; return null; &#125;</div><div class=\"line\">        else &#123;</div><div class=\"line\">            while(head != slow) &#123;</div><div class=\"line\">                if(head != slow &amp;&amp; slow != fast) &#123; slow = slow.next; &#125;</div><div class=\"line\">                else if(head != slow &amp;&amp; slow == fast) &#123;</div><div class=\"line\">                    slow = slow.next;</div><div class=\"line\">                    head = head.next;</div><div class=\"line\">                &#125;</div><div class=\"line\">                else &#123; break; &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return head;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"大神解法：\"><a href=\"#大神解法：\" class=\"headerlink\" title=\"大神解法：\"></a>大神解法：</h5><p>这道题中蕴含着一个<strong>数学关系</strong>，即<code>fast</code>走过的路程是<code>slow</code>的两倍。</p>\n<p>设<code>head</code>距离环路起始节点的路程是A，<code>slow</code>在走过路程A之前是不会与<code>fast</code>相遇的；<code>slow</code>离开环路起始节点B路程时，与走完一圈环路的<code>fast</code> 相遇；环路的总长度是N。</p>\n<p>所以：</p>\n<p><code>slow</code>走过的路程是：A+B</p>\n<p><code>fast</code>走过的路程是：2(A+B)</p>\n<p>环路总长度是：N = 2(A+B)-(A+B) = A+B</p>\n<p>此时，做出一张<strong>距离关系图</strong>之后就会发现，从当前<code>slow</code>和<code>fast</code>相遇的节点开始，再走A路程，就可以到达环路起始节点位置，而从<code>head</code>节点到环路起始位置的路程正好是A。所以，只需要再用一个指针<code>slow2</code>从<code>head</code>出发，与<code>slow</code>同步行走同样的路程，必然会在环路起始的节点相遇。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Solution &#123;</div><div class=\"line\">            public ListNode detectCycle(ListNode head) &#123;</div><div class=\"line\">                ListNode slow = head;</div><div class=\"line\">                ListNode fast = head;</div><div class=\"line\"></div><div class=\"line\">                while (fast!=null &amp;&amp; fast.next!=null)&#123;</div><div class=\"line\">                    fast = fast.next.next;</div><div class=\"line\">                    slow = slow.next;</div><div class=\"line\">                    </div><div class=\"line\">                    if (fast == slow)&#123;</div><div class=\"line\">                        ListNode slow2 = head; </div><div class=\"line\">                        while (slow2 != slow)&#123;</div><div class=\"line\">                            slow = slow.next;</div><div class=\"line\">                            slow2 = slow2.next;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        return slow;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                return null;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>两种方法都是在leetcode#141原有的基础上进行扩展，但是我的解法没有发现其中蕴含的简单数学关系，而是采取了暴力解法，实在是不应该。</p>\n<p>复杂的问题十有八九都会蕴含一定的数学关系或者数学规律，找出这些关系和规律，解题方法将大幅度优化。</p>\n","excerpt":"","more":"<h2 id=\"leetcode-142-Linked-List-Cycle-II\"><a href=\"#leetcode-142-Linked-List-Cycle-II\" class=\"headerlink\" title=\"leetcode#142 Linked List Cycle II\"></a>leetcode#142 Linked List Cycle II</h2><blockquote>\n<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p>\n<p>Solve it without using extra space.</p>\n</blockquote>\n<h5 id=\"解释：\"><a href=\"#解释：\" class=\"headerlink\" title=\"解释：\"></a>解释：</h5><p>给定一个<strong>单链表</strong>，如果单链表中存在环路，则返回<strong>环路起始的节点</strong>；如果没有环路，则返回<code>null</code>。</p>\n<h5 id=\"理解：\"><a href=\"#理解：\" class=\"headerlink\" title=\"理解：\"></a>理解：</h5><p>这个题可以借鉴leetcode#141的思路，并接着扩展代码即可。在leetcode#141判断的基础上，如果存在环路，则判断<code>head</code>和<code>slow</code>是否相同，若相同，则<code>head</code>所指的节点就是环路起始的节点，若不同，则将<code>head</code>移动到下一个节点，同时让<code>slow</code>在环路中跑一圈，看看<code>head</code>会不会与<code>slow</code>相遇。</p>\n<h5 id=\"我的解法：\"><a href=\"#我的解法：\" class=\"headerlink\" title=\"我的解法：\"></a>我的解法：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Definition for singly-linked list.</div><div class=\"line\"> * class ListNode &#123;</div><div class=\"line\"> *     int val;</div><div class=\"line\"> *     ListNode next;</div><div class=\"line\"> *     ListNode(int x) &#123;</div><div class=\"line\"> *         val = x;</div><div class=\"line\"> *         next = null;</div><div class=\"line\"> *     &#125;</div><div class=\"line\"> * &#125;</div><div class=\"line\"> */</div><div class=\"line\">public class Solution &#123;</div><div class=\"line\">    public ListNode detectCycle(ListNode head) &#123;</div><div class=\"line\">        ListNode slow = head;</div><div class=\"line\">        ListNode fast = head;</div><div class=\"line\">        </div><div class=\"line\">        while(fast != null &amp;&amp; fast.next != null) &#123;</div><div class=\"line\">            slow = slow.next;</div><div class=\"line\">            fast = fast.next.next;</div><div class=\"line\">            if(slow == fast) &#123;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if(fast == null || fast.next == null) &#123; return null; &#125;</div><div class=\"line\">        else &#123;</div><div class=\"line\">            while(head != slow) &#123;</div><div class=\"line\">                if(head != slow &amp;&amp; slow != fast) &#123; slow = slow.next; &#125;</div><div class=\"line\">                else if(head != slow &amp;&amp; slow == fast) &#123;</div><div class=\"line\">                    slow = slow.next;</div><div class=\"line\">                    head = head.next;</div><div class=\"line\">                &#125;</div><div class=\"line\">                else &#123; break; &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return head;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"大神解法：\"><a href=\"#大神解法：\" class=\"headerlink\" title=\"大神解法：\"></a>大神解法：</h5><p>这道题中蕴含着一个<strong>数学关系</strong>，即<code>fast</code>走过的路程是<code>slow</code>的两倍。</p>\n<p>设<code>head</code>距离环路起始节点的路程是A，<code>slow</code>在走过路程A之前是不会与<code>fast</code>相遇的；<code>slow</code>离开环路起始节点B路程时，与走完一圈环路的<code>fast</code> 相遇；环路的总长度是N。</p>\n<p>所以：</p>\n<p><code>slow</code>走过的路程是：A+B</p>\n<p><code>fast</code>走过的路程是：2(A+B)</p>\n<p>环路总长度是：N = 2(A+B)-(A+B) = A+B</p>\n<p>此时，做出一张<strong>距离关系图</strong>之后就会发现，从当前<code>slow</code>和<code>fast</code>相遇的节点开始，再走A路程，就可以到达环路起始节点位置，而从<code>head</code>节点到环路起始位置的路程正好是A。所以，只需要再用一个指针<code>slow2</code>从<code>head</code>出发，与<code>slow</code>同步行走同样的路程，必然会在环路起始的节点相遇。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Solution &#123;</div><div class=\"line\">            public ListNode detectCycle(ListNode head) &#123;</div><div class=\"line\">                ListNode slow = head;</div><div class=\"line\">                ListNode fast = head;</div><div class=\"line\"></div><div class=\"line\">                while (fast!=null &amp;&amp; fast.next!=null)&#123;</div><div class=\"line\">                    fast = fast.next.next;</div><div class=\"line\">                    slow = slow.next;</div><div class=\"line\">                    </div><div class=\"line\">                    if (fast == slow)&#123;</div><div class=\"line\">                        ListNode slow2 = head; </div><div class=\"line\">                        while (slow2 != slow)&#123;</div><div class=\"line\">                            slow = slow.next;</div><div class=\"line\">                            slow2 = slow2.next;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        return slow;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                return null;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>两种方法都是在leetcode#141原有的基础上进行扩展，但是我的解法没有发现其中蕴含的简单数学关系，而是采取了暴力解法，实在是不应该。</p>\n<p>复杂的问题十有八九都会蕴含一定的数学关系或者数学规律，找出这些关系和规律，解题方法将大幅度优化。</p>\n"},{"title":"leetcode160 IntersectionofTwoLinkedLists","date":"2017-04-05T09:00:00.000Z","_content":"\n## leetcode#160 Intersection of Two Linked Lists   \n\n>Write a program to find the node at which the intersection of two singly linked lists begins.\n>\n>For example, the following two linked lists:\n>\n>```\n>A:          a1 → a2\n>                   ↘\n>                     c1 → c2 → c3\n>                   ↗            \n>B:     b1 → b2 → b3\n>\n>```\n>\n>begin to intersect at node c1.\n>\n>**Notes:**\n>\n>- If the two linked lists have no intersection at all, return `null`.\n>- The linked lists must retain their original structure after the function returns.\n>- You may assume there are no cycles anywhere in the entire linked structure.\n>- Your code should preferably run in O(n) time and use only O(1) memory.\n\n##### 解释：\n\n找出两个单链表相交的节点（第一个相交的节点）。\n\n注意：\n\n- 如果两个单链表没有相交的节点，返回`null`\n- 在返回之后，两个单链表必须保持原有的结构状态\n- 本题可以假设没有环路\n- 时间复杂度要求`O(n)`，空间复杂度要求`O(1)` \n\n##### 理解：\n\n- 可能两条链表没有交点，所以必须遍历到链表的最后\n- 返回后保持链表的原有结构，那么递归方式就不太好使用\n- 没有环路，意味着可以一次遍历到链表的末尾\n- 时间复杂度`O(n)`限制了循环最多是所有链表节点，不能有两层及以上的遍历链表出现；空间复杂度`O(1)`限制了不能构造另外的数据结构，用于暂存链表节点，只能在原有的链表结构上操作\n\n要求越多，题目的解决方式就会更清晰。\n\n根据上述情况的描述，可以从两条链表节点数的不同入手。在相交节点之后，两条链表的节点是相同的，所以节点数的不同只会出现在相交节点之前的部分。\n\n如果两个链表都从距离相交节点相同路程的节点出发，以相同的遍历速度往前走，则一定会在相交节点相遇，此时返回当前节点即可。\n\n至于如何确定两个链表遍历的起始位置，可以先分别遍历一次，得到两个链表各自的节点数目，比较，较多的一方先向前移动差值的路程，最后再开始一起向后遍历。\n\n##### 我的解法：\n\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode tmpA = headA;\n        ListNode tmpB = headB;\n        int countA = 0;\n        int countB = 0;\n        \n        if(headA == null || headB == null) { return null; }\n        \n        while(tmpA != null) {\n            countA++;\n            tmpA = tmpA.next;\n        }\n        while(tmpB != null) {\n            countB++;\n            tmpB = tmpB.next;\n        }\n        \n        tmpA = headA;\n        tmpB = headB;\n        if(countA > countB) {\n            for(int i = 0;i<(countA - countB);i++) { tmpA = tmpA.next; }\n        }\n        else {\n            for(int i = 0;i<(countB - countA);i++) { tmpB = tmpB.next; }\n        }\n        \n        while(tmpA != tmpB) {\n            if(tmpA == null || tmpB == null) { return null; }\n            else {\n                tmpA = tmpA.next;\n                tmpB = tmpB.next;\n            }\n        }\n        return tmpA;\n    }\n}\n```\n\n##### 大神的解法：\n\n很巧妙，考虑到了路程的关系。\n\n假设`headA`到相交节点的距离是A，`headB`到相交节点的距离是B，从相交节点到末尾的距离是C，则可以不用事先判断两条链表的节点数之差，只需要走一圈肯定会相遇与相交节点，因为`A+B+C = B+A+C`，即分别从头开始分别遍历两条链表，遇到末尾时跳转到另外一条链表的首部继续遍历，如果存在相交节点，走完一圈肯定会相遇，否则肯定没有相交节点。\n\n```\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n    if(headA == null || headB == null) return null;\n    \n    ListNode a = headA;\n    ListNode b = headB;\n \n    while( a != b){\n    \t//for the end of first iteration, we just reset the pointer to the head of another linkedlist\n        a = a == null? headB : a.next;\n        b = b == null? headA : b.next;    \n    }\n    return a;\n}\n```\n\n### 总结：\n\n好的算法都是精致的数学关系。\n\n有时候你只考虑到了一个层面的数学关系，把眼界放宽，放远一点，也许就能看到下一层面的、更精致的数学关系。","source":"_posts/leetcode160-IntersectionofTwoLinkedLists.md","raw":"title: leetcode160 IntersectionofTwoLinkedLists\n\ndate: 2017/04/05 17:00:00\n\ncategories:\n\n- Study\n\ntags:\n\n- leetcode\n- linkedlist\n\n---\n\n## leetcode#160 Intersection of Two Linked Lists   \n\n>Write a program to find the node at which the intersection of two singly linked lists begins.\n>\n>For example, the following two linked lists:\n>\n>```\n>A:          a1 → a2\n>                   ↘\n>                     c1 → c2 → c3\n>                   ↗            \n>B:     b1 → b2 → b3\n>\n>```\n>\n>begin to intersect at node c1.\n>\n>**Notes:**\n>\n>- If the two linked lists have no intersection at all, return `null`.\n>- The linked lists must retain their original structure after the function returns.\n>- You may assume there are no cycles anywhere in the entire linked structure.\n>- Your code should preferably run in O(n) time and use only O(1) memory.\n\n##### 解释：\n\n找出两个单链表相交的节点（第一个相交的节点）。\n\n注意：\n\n- 如果两个单链表没有相交的节点，返回`null`\n- 在返回之后，两个单链表必须保持原有的结构状态\n- 本题可以假设没有环路\n- 时间复杂度要求`O(n)`，空间复杂度要求`O(1)` \n\n##### 理解：\n\n- 可能两条链表没有交点，所以必须遍历到链表的最后\n- 返回后保持链表的原有结构，那么递归方式就不太好使用\n- 没有环路，意味着可以一次遍历到链表的末尾\n- 时间复杂度`O(n)`限制了循环最多是所有链表节点，不能有两层及以上的遍历链表出现；空间复杂度`O(1)`限制了不能构造另外的数据结构，用于暂存链表节点，只能在原有的链表结构上操作\n\n要求越多，题目的解决方式就会更清晰。\n\n根据上述情况的描述，可以从两条链表节点数的不同入手。在相交节点之后，两条链表的节点是相同的，所以节点数的不同只会出现在相交节点之前的部分。\n\n如果两个链表都从距离相交节点相同路程的节点出发，以相同的遍历速度往前走，则一定会在相交节点相遇，此时返回当前节点即可。\n\n至于如何确定两个链表遍历的起始位置，可以先分别遍历一次，得到两个链表各自的节点数目，比较，较多的一方先向前移动差值的路程，最后再开始一起向后遍历。\n\n##### 我的解法：\n\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode tmpA = headA;\n        ListNode tmpB = headB;\n        int countA = 0;\n        int countB = 0;\n        \n        if(headA == null || headB == null) { return null; }\n        \n        while(tmpA != null) {\n            countA++;\n            tmpA = tmpA.next;\n        }\n        while(tmpB != null) {\n            countB++;\n            tmpB = tmpB.next;\n        }\n        \n        tmpA = headA;\n        tmpB = headB;\n        if(countA > countB) {\n            for(int i = 0;i<(countA - countB);i++) { tmpA = tmpA.next; }\n        }\n        else {\n            for(int i = 0;i<(countB - countA);i++) { tmpB = tmpB.next; }\n        }\n        \n        while(tmpA != tmpB) {\n            if(tmpA == null || tmpB == null) { return null; }\n            else {\n                tmpA = tmpA.next;\n                tmpB = tmpB.next;\n            }\n        }\n        return tmpA;\n    }\n}\n```\n\n##### 大神的解法：\n\n很巧妙，考虑到了路程的关系。\n\n假设`headA`到相交节点的距离是A，`headB`到相交节点的距离是B，从相交节点到末尾的距离是C，则可以不用事先判断两条链表的节点数之差，只需要走一圈肯定会相遇与相交节点，因为`A+B+C = B+A+C`，即分别从头开始分别遍历两条链表，遇到末尾时跳转到另外一条链表的首部继续遍历，如果存在相交节点，走完一圈肯定会相遇，否则肯定没有相交节点。\n\n```\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n    if(headA == null || headB == null) return null;\n    \n    ListNode a = headA;\n    ListNode b = headB;\n \n    while( a != b){\n    \t//for the end of first iteration, we just reset the pointer to the head of another linkedlist\n        a = a == null? headB : a.next;\n        b = b == null? headA : b.next;    \n    }\n    return a;\n}\n```\n\n### 总结：\n\n好的算法都是精致的数学关系。\n\n有时候你只考虑到了一个层面的数学关系，把眼界放宽，放远一点，也许就能看到下一层面的、更精致的数学关系。","slug":"leetcode160-IntersectionofTwoLinkedLists","published":1,"updated":"2017-04-05T09:43:58.161Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj14sfspg00008kup526gkiqu","content":"<h2 id=\"leetcode-160-Intersection-of-Two-Linked-Lists\"><a href=\"#leetcode-160-Intersection-of-Two-Linked-Lists\" class=\"headerlink\" title=\"leetcode#160 Intersection of Two Linked Lists\"></a>leetcode#160 Intersection of Two Linked Lists</h2><blockquote>\n<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>\n<p>For example, the following two linked lists:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;A:          a1 → a2</div><div class=\"line\">&gt;                   ↘</div><div class=\"line\">&gt;                     c1 → c2 → c3</div><div class=\"line\">&gt;                   ↗            </div><div class=\"line\">&gt;B:     b1 → b2 → b3</div><div class=\"line\">&gt;</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>begin to intersect at node c1.</p>\n<p><strong>Notes:</strong></p>\n<ul>\n<li>If the two linked lists have no intersection at all, return <code>null</code>.</li>\n<li>The linked lists must retain their original structure after the function returns.</li>\n<li>You may assume there are no cycles anywhere in the entire linked structure.</li>\n<li>Your code should preferably run in O(n) time and use only O(1) memory.</li>\n</ul>\n</blockquote>\n<h5 id=\"解释：\"><a href=\"#解释：\" class=\"headerlink\" title=\"解释：\"></a>解释：</h5><p>找出两个单链表相交的节点（第一个相交的节点）。</p>\n<p>注意：</p>\n<ul>\n<li>如果两个单链表没有相交的节点，返回<code>null</code></li>\n<li>在返回之后，两个单链表必须保持原有的结构状态</li>\n<li>本题可以假设没有环路</li>\n<li>时间复杂度要求<code>O(n)</code>，空间复杂度要求<code>O(1)</code> </li>\n</ul>\n<h5 id=\"理解：\"><a href=\"#理解：\" class=\"headerlink\" title=\"理解：\"></a>理解：</h5><ul>\n<li>可能两条链表没有交点，所以必须遍历到链表的最后</li>\n<li>返回后保持链表的原有结构，那么递归方式就不太好使用</li>\n<li>没有环路，意味着可以一次遍历到链表的末尾</li>\n<li>时间复杂度<code>O(n)</code>限制了循环最多是所有链表节点，不能有两层及以上的遍历链表出现；空间复杂度<code>O(1)</code>限制了不能构造另外的数据结构，用于暂存链表节点，只能在原有的链表结构上操作</li>\n</ul>\n<p>要求越多，题目的解决方式就会更清晰。</p>\n<p>根据上述情况的描述，可以从两条链表节点数的不同入手。在相交节点之后，两条链表的节点是相同的，所以节点数的不同只会出现在相交节点之前的部分。</p>\n<p>如果两个链表都从距离相交节点相同路程的节点出发，以相同的遍历速度往前走，则一定会在相交节点相遇，此时返回当前节点即可。</p>\n<p>至于如何确定两个链表遍历的起始位置，可以先分别遍历一次，得到两个链表各自的节点数目，比较，较多的一方先向前移动差值的路程，最后再开始一起向后遍历。</p>\n<h5 id=\"我的解法：\"><a href=\"#我的解法：\" class=\"headerlink\" title=\"我的解法：\"></a>我的解法：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Definition for singly-linked list.</div><div class=\"line\"> * public class ListNode &#123;</div><div class=\"line\"> *     int val;</div><div class=\"line\"> *     ListNode next;</div><div class=\"line\"> *     ListNode(int x) &#123;</div><div class=\"line\"> *         val = x;</div><div class=\"line\"> *         next = null;</div><div class=\"line\"> *     &#125;</div><div class=\"line\"> * &#125;</div><div class=\"line\"> */</div><div class=\"line\">public class Solution &#123;</div><div class=\"line\">    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</div><div class=\"line\">        ListNode tmpA = headA;</div><div class=\"line\">        ListNode tmpB = headB;</div><div class=\"line\">        int countA = 0;</div><div class=\"line\">        int countB = 0;</div><div class=\"line\">        </div><div class=\"line\">        if(headA == null || headB == null) &#123; return null; &#125;</div><div class=\"line\">        </div><div class=\"line\">        while(tmpA != null) &#123;</div><div class=\"line\">            countA++;</div><div class=\"line\">            tmpA = tmpA.next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        while(tmpB != null) &#123;</div><div class=\"line\">            countB++;</div><div class=\"line\">            tmpB = tmpB.next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        tmpA = headA;</div><div class=\"line\">        tmpB = headB;</div><div class=\"line\">        if(countA &gt; countB) &#123;</div><div class=\"line\">            for(int i = 0;i&lt;(countA - countB);i++) &#123; tmpA = tmpA.next; &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else &#123;</div><div class=\"line\">            for(int i = 0;i&lt;(countB - countA);i++) &#123; tmpB = tmpB.next; &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        while(tmpA != tmpB) &#123;</div><div class=\"line\">            if(tmpA == null || tmpB == null) &#123; return null; &#125;</div><div class=\"line\">            else &#123;</div><div class=\"line\">                tmpA = tmpA.next;</div><div class=\"line\">                tmpB = tmpB.next;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return tmpA;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"大神的解法：\"><a href=\"#大神的解法：\" class=\"headerlink\" title=\"大神的解法：\"></a>大神的解法：</h5><p>很巧妙，考虑到了路程的关系。</p>\n<p>假设<code>headA</code>到相交节点的距离是A，<code>headB</code>到相交节点的距离是B，从相交节点到末尾的距离是C，则可以不用事先判断两条链表的节点数之差，只需要走一圈肯定会相遇与相交节点，因为<code>A+B+C = B+A+C</code>，即分别从头开始分别遍历两条链表，遇到末尾时跳转到另外一条链表的首部继续遍历，如果存在相交节点，走完一圈肯定会相遇，否则肯定没有相交节点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</div><div class=\"line\">    if(headA == null || headB == null) return null;</div><div class=\"line\">    </div><div class=\"line\">    ListNode a = headA;</div><div class=\"line\">    ListNode b = headB;</div><div class=\"line\"> </div><div class=\"line\">    while( a != b)&#123;</div><div class=\"line\">    \t//for the end of first iteration, we just reset the pointer to the head of another linkedlist</div><div class=\"line\">        a = a == null? headB : a.next;</div><div class=\"line\">        b = b == null? headA : b.next;    </div><div class=\"line\">    &#125;</div><div class=\"line\">    return a;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>好的算法都是精致的数学关系。</p>\n<p>有时候你只考虑到了一个层面的数学关系，把眼界放宽，放远一点，也许就能看到下一层面的、更精致的数学关系。</p>\n","excerpt":"","more":"<h2 id=\"leetcode-160-Intersection-of-Two-Linked-Lists\"><a href=\"#leetcode-160-Intersection-of-Two-Linked-Lists\" class=\"headerlink\" title=\"leetcode#160 Intersection of Two Linked Lists\"></a>leetcode#160 Intersection of Two Linked Lists</h2><blockquote>\n<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>\n<p>For example, the following two linked lists:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;A:          a1 → a2</div><div class=\"line\">&gt;                   ↘</div><div class=\"line\">&gt;                     c1 → c2 → c3</div><div class=\"line\">&gt;                   ↗            </div><div class=\"line\">&gt;B:     b1 → b2 → b3</div><div class=\"line\">&gt;</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>begin to intersect at node c1.</p>\n<p><strong>Notes:</strong></p>\n<ul>\n<li>If the two linked lists have no intersection at all, return <code>null</code>.</li>\n<li>The linked lists must retain their original structure after the function returns.</li>\n<li>You may assume there are no cycles anywhere in the entire linked structure.</li>\n<li>Your code should preferably run in O(n) time and use only O(1) memory.</li>\n</ul>\n</blockquote>\n<h5 id=\"解释：\"><a href=\"#解释：\" class=\"headerlink\" title=\"解释：\"></a>解释：</h5><p>找出两个单链表相交的节点（第一个相交的节点）。</p>\n<p>注意：</p>\n<ul>\n<li>如果两个单链表没有相交的节点，返回<code>null</code></li>\n<li>在返回之后，两个单链表必须保持原有的结构状态</li>\n<li>本题可以假设没有环路</li>\n<li>时间复杂度要求<code>O(n)</code>，空间复杂度要求<code>O(1)</code> </li>\n</ul>\n<h5 id=\"理解：\"><a href=\"#理解：\" class=\"headerlink\" title=\"理解：\"></a>理解：</h5><ul>\n<li>可能两条链表没有交点，所以必须遍历到链表的最后</li>\n<li>返回后保持链表的原有结构，那么递归方式就不太好使用</li>\n<li>没有环路，意味着可以一次遍历到链表的末尾</li>\n<li>时间复杂度<code>O(n)</code>限制了循环最多是所有链表节点，不能有两层及以上的遍历链表出现；空间复杂度<code>O(1)</code>限制了不能构造另外的数据结构，用于暂存链表节点，只能在原有的链表结构上操作</li>\n</ul>\n<p>要求越多，题目的解决方式就会更清晰。</p>\n<p>根据上述情况的描述，可以从两条链表节点数的不同入手。在相交节点之后，两条链表的节点是相同的，所以节点数的不同只会出现在相交节点之前的部分。</p>\n<p>如果两个链表都从距离相交节点相同路程的节点出发，以相同的遍历速度往前走，则一定会在相交节点相遇，此时返回当前节点即可。</p>\n<p>至于如何确定两个链表遍历的起始位置，可以先分别遍历一次，得到两个链表各自的节点数目，比较，较多的一方先向前移动差值的路程，最后再开始一起向后遍历。</p>\n<h5 id=\"我的解法：\"><a href=\"#我的解法：\" class=\"headerlink\" title=\"我的解法：\"></a>我的解法：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Definition for singly-linked list.</div><div class=\"line\"> * public class ListNode &#123;</div><div class=\"line\"> *     int val;</div><div class=\"line\"> *     ListNode next;</div><div class=\"line\"> *     ListNode(int x) &#123;</div><div class=\"line\"> *         val = x;</div><div class=\"line\"> *         next = null;</div><div class=\"line\"> *     &#125;</div><div class=\"line\"> * &#125;</div><div class=\"line\"> */</div><div class=\"line\">public class Solution &#123;</div><div class=\"line\">    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</div><div class=\"line\">        ListNode tmpA = headA;</div><div class=\"line\">        ListNode tmpB = headB;</div><div class=\"line\">        int countA = 0;</div><div class=\"line\">        int countB = 0;</div><div class=\"line\">        </div><div class=\"line\">        if(headA == null || headB == null) &#123; return null; &#125;</div><div class=\"line\">        </div><div class=\"line\">        while(tmpA != null) &#123;</div><div class=\"line\">            countA++;</div><div class=\"line\">            tmpA = tmpA.next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        while(tmpB != null) &#123;</div><div class=\"line\">            countB++;</div><div class=\"line\">            tmpB = tmpB.next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        tmpA = headA;</div><div class=\"line\">        tmpB = headB;</div><div class=\"line\">        if(countA &gt; countB) &#123;</div><div class=\"line\">            for(int i = 0;i&lt;(countA - countB);i++) &#123; tmpA = tmpA.next; &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else &#123;</div><div class=\"line\">            for(int i = 0;i&lt;(countB - countA);i++) &#123; tmpB = tmpB.next; &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        while(tmpA != tmpB) &#123;</div><div class=\"line\">            if(tmpA == null || tmpB == null) &#123; return null; &#125;</div><div class=\"line\">            else &#123;</div><div class=\"line\">                tmpA = tmpA.next;</div><div class=\"line\">                tmpB = tmpB.next;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return tmpA;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"大神的解法：\"><a href=\"#大神的解法：\" class=\"headerlink\" title=\"大神的解法：\"></a>大神的解法：</h5><p>很巧妙，考虑到了路程的关系。</p>\n<p>假设<code>headA</code>到相交节点的距离是A，<code>headB</code>到相交节点的距离是B，从相交节点到末尾的距离是C，则可以不用事先判断两条链表的节点数之差，只需要走一圈肯定会相遇与相交节点，因为<code>A+B+C = B+A+C</code>，即分别从头开始分别遍历两条链表，遇到末尾时跳转到另外一条链表的首部继续遍历，如果存在相交节点，走完一圈肯定会相遇，否则肯定没有相交节点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</div><div class=\"line\">    if(headA == null || headB == null) return null;</div><div class=\"line\">    </div><div class=\"line\">    ListNode a = headA;</div><div class=\"line\">    ListNode b = headB;</div><div class=\"line\"> </div><div class=\"line\">    while( a != b)&#123;</div><div class=\"line\">    \t//for the end of first iteration, we just reset the pointer to the head of another linkedlist</div><div class=\"line\">        a = a == null? headB : a.next;</div><div class=\"line\">        b = b == null? headA : b.next;    </div><div class=\"line\">    &#125;</div><div class=\"line\">    return a;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>好的算法都是精致的数学关系。</p>\n<p>有时候你只考虑到了一个层面的数学关系，把眼界放宽，放远一点，也许就能看到下一层面的、更精致的数学关系。</p>\n"},{"title":"leetcode206 ReverseLinkedList","date":"2017-04-06T14:00:00.000Z","_content":"\n## leetcode#206 Reverse Linked List \n\n>Reverse a singly linked list.\n>\n>A linked list can be reversed either iteratively or recursively. \n\n##### 解释：\n\n单链表反转。\n\n可以使用递归和非递归方法。\n\n##### 理解：\n\n单链表反转，需要在头指针`head`的基础上，多使用两个指针实现链表`next`指向的变更，`head`指针用于向后探索以及链表`next`指向变化之后将临时指针切换到`head`位置。\n\n##### 我的解法（非递归）：\n\n除了边界判断之外，如果头指针`head`的下一个节点不为空，则在中间部分`tmp1`、`tmp2`和`head`三个指针将依次从前往后排序，这时首先将中间节点的`next`指针反向，指向之前的节点，然后将前一个节点的指针`tmp1`移动到中间的节点，最后将中间节点的指针`tmp2`移动到`head`位置。一直重复直到`head`之后没有节点，这时只需要改变`head`所指节点的`next`指针，指向之前的节点即可。\n\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode reverseList(ListNode head) {\n        if(head == null || head.next == null) { return head; }\n        ListNode tmp1 = head;\n        head = head.next;\n        ListNode tmp2 = head;\n        tmp1.next = null;\n        \n        while(head.next != null) {\n            head = head.next;\n            tmp2.next = tmp1;\n            tmp1 = tmp2;\n            tmp2 = head;\n        }\n        head.next = tmp1;\n        return head;\n    }\n}\n```\n\n##### 大神的解法：\n\n- 非递归方法：思路一致，不过他的解法更为简洁，直接让循环从两个指针开始，在循环内部再**动态生成**第三个指针；\n- 递归方法：由于leetcode中给的方法只有一个形参，所以另写了一个含有两个形参的私有方法，该方法**每次传入两个相邻的节点**，在方法内动态生成一个指向后续第三个节点的指针，然后中间的节点改变`next`的指向，指向前一个节点，然后再将中间和第三个节点的指针当做参数进行后续的递归。\n\n```\npublic ListNode reverseList(ListNode head) {\n    /* iterative solution && non-recursive solution */\n    ListNode newHead = null;\n    while (head != null) {\n        ListNode next = head.next;\n        head.next = newHead;\n        newHead = head;\n        head = next;\n    }\n    return newHead;\n}\n\n\npublic ListNode reverseList(ListNode head) {\n    /* recursive solution */\n    return reverseListInt(head, null);\n}\nprivate ListNode reverseListInt(ListNode head, ListNode newHead) {\n    if (head == null)\n        return newHead;\n    ListNode next = head.next;\n    head.next = newHead;\n    return reverseListInt(next, head);\n}\n```\n\n### 总结：\n\n递归一般来说是遍历到末尾，再依次从末尾返回到起始位置，但是在本题的递归解法中，**递归是从头往后解题**——每一步递归其实都已经在构造最后的反向链表，最后返回的只是构造完成之后的新链表的头结点。\n\n","source":"_posts/leetcode206-ReverseLinkedList.md","raw":"title: leetcode206 ReverseLinkedList\n\ndate: 2017/04/06 22:00:00\n\ncategories:\n\n- Study\n\ntags:\n\n- leetcode\n- linkedlist\n\n---\n\n## leetcode#206 Reverse Linked List \n\n>Reverse a singly linked list.\n>\n>A linked list can be reversed either iteratively or recursively. \n\n##### 解释：\n\n单链表反转。\n\n可以使用递归和非递归方法。\n\n##### 理解：\n\n单链表反转，需要在头指针`head`的基础上，多使用两个指针实现链表`next`指向的变更，`head`指针用于向后探索以及链表`next`指向变化之后将临时指针切换到`head`位置。\n\n##### 我的解法（非递归）：\n\n除了边界判断之外，如果头指针`head`的下一个节点不为空，则在中间部分`tmp1`、`tmp2`和`head`三个指针将依次从前往后排序，这时首先将中间节点的`next`指针反向，指向之前的节点，然后将前一个节点的指针`tmp1`移动到中间的节点，最后将中间节点的指针`tmp2`移动到`head`位置。一直重复直到`head`之后没有节点，这时只需要改变`head`所指节点的`next`指针，指向之前的节点即可。\n\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode reverseList(ListNode head) {\n        if(head == null || head.next == null) { return head; }\n        ListNode tmp1 = head;\n        head = head.next;\n        ListNode tmp2 = head;\n        tmp1.next = null;\n        \n        while(head.next != null) {\n            head = head.next;\n            tmp2.next = tmp1;\n            tmp1 = tmp2;\n            tmp2 = head;\n        }\n        head.next = tmp1;\n        return head;\n    }\n}\n```\n\n##### 大神的解法：\n\n- 非递归方法：思路一致，不过他的解法更为简洁，直接让循环从两个指针开始，在循环内部再**动态生成**第三个指针；\n- 递归方法：由于leetcode中给的方法只有一个形参，所以另写了一个含有两个形参的私有方法，该方法**每次传入两个相邻的节点**，在方法内动态生成一个指向后续第三个节点的指针，然后中间的节点改变`next`的指向，指向前一个节点，然后再将中间和第三个节点的指针当做参数进行后续的递归。\n\n```\npublic ListNode reverseList(ListNode head) {\n    /* iterative solution && non-recursive solution */\n    ListNode newHead = null;\n    while (head != null) {\n        ListNode next = head.next;\n        head.next = newHead;\n        newHead = head;\n        head = next;\n    }\n    return newHead;\n}\n\n\npublic ListNode reverseList(ListNode head) {\n    /* recursive solution */\n    return reverseListInt(head, null);\n}\nprivate ListNode reverseListInt(ListNode head, ListNode newHead) {\n    if (head == null)\n        return newHead;\n    ListNode next = head.next;\n    head.next = newHead;\n    return reverseListInt(next, head);\n}\n```\n\n### 总结：\n\n递归一般来说是遍历到末尾，再依次从末尾返回到起始位置，但是在本题的递归解法中，**递归是从头往后解题**——每一步递归其实都已经在构造最后的反向链表，最后返回的只是构造完成之后的新链表的头结点。\n\n","slug":"leetcode206-ReverseLinkedList","published":1,"updated":"2017-04-06T15:08:14.871Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj16k96by0000bsup53qu7y1r","content":"<h2 id=\"leetcode-206-Reverse-Linked-List\"><a href=\"#leetcode-206-Reverse-Linked-List\" class=\"headerlink\" title=\"leetcode#206 Reverse Linked List\"></a>leetcode#206 Reverse Linked List</h2><blockquote>\n<p>Reverse a singly linked list.</p>\n<p>A linked list can be reversed either iteratively or recursively. </p>\n</blockquote>\n<h5 id=\"解释：\"><a href=\"#解释：\" class=\"headerlink\" title=\"解释：\"></a>解释：</h5><p>单链表反转。</p>\n<p>可以使用递归和非递归方法。</p>\n<h5 id=\"理解：\"><a href=\"#理解：\" class=\"headerlink\" title=\"理解：\"></a>理解：</h5><p>单链表反转，需要在头指针<code>head</code>的基础上，多使用两个指针实现链表<code>next</code>指向的变更，<code>head</code>指针用于向后探索以及链表<code>next</code>指向变化之后将临时指针切换到<code>head</code>位置。</p>\n<h5 id=\"我的解法（非递归）：\"><a href=\"#我的解法（非递归）：\" class=\"headerlink\" title=\"我的解法（非递归）：\"></a>我的解法（非递归）：</h5><p>除了边界判断之外，如果头指针<code>head</code>的下一个节点不为空，则在中间部分<code>tmp1</code>、<code>tmp2</code>和<code>head</code>三个指针将依次从前往后排序，这时首先将中间节点的<code>next</code>指针反向，指向之前的节点，然后将前一个节点的指针<code>tmp1</code>移动到中间的节点，最后将中间节点的指针<code>tmp2</code>移动到<code>head</code>位置。一直重复直到<code>head</code>之后没有节点，这时只需要改变<code>head</code>所指节点的<code>next</code>指针，指向之前的节点即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Definition for singly-linked list.</div><div class=\"line\"> * public class ListNode &#123;</div><div class=\"line\"> *     int val;</div><div class=\"line\"> *     ListNode next;</div><div class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</div><div class=\"line\"> * &#125;</div><div class=\"line\"> */</div><div class=\"line\">public class Solution &#123;</div><div class=\"line\">    public ListNode reverseList(ListNode head) &#123;</div><div class=\"line\">        if(head == null || head.next == null) &#123; return head; &#125;</div><div class=\"line\">        ListNode tmp1 = head;</div><div class=\"line\">        head = head.next;</div><div class=\"line\">        ListNode tmp2 = head;</div><div class=\"line\">        tmp1.next = null;</div><div class=\"line\">        </div><div class=\"line\">        while(head.next != null) &#123;</div><div class=\"line\">            head = head.next;</div><div class=\"line\">            tmp2.next = tmp1;</div><div class=\"line\">            tmp1 = tmp2;</div><div class=\"line\">            tmp2 = head;</div><div class=\"line\">        &#125;</div><div class=\"line\">        head.next = tmp1;</div><div class=\"line\">        return head;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"大神的解法：\"><a href=\"#大神的解法：\" class=\"headerlink\" title=\"大神的解法：\"></a>大神的解法：</h5><ul>\n<li>非递归方法：思路一致，不过他的解法更为简洁，直接让循环从两个指针开始，在循环内部再<strong>动态生成</strong>第三个指针；</li>\n<li>递归方法：由于leetcode中给的方法只有一个形参，所以另写了一个含有两个形参的私有方法，该方法<strong>每次传入两个相邻的节点</strong>，在方法内动态生成一个指向后续第三个节点的指针，然后中间的节点改变<code>next</code>的指向，指向前一个节点，然后再将中间和第三个节点的指针当做参数进行后续的递归。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ListNode reverseList(ListNode head) &#123;</div><div class=\"line\">    /* iterative solution &amp;&amp; non-recursive solution */</div><div class=\"line\">    ListNode newHead = null;</div><div class=\"line\">    while (head != null) &#123;</div><div class=\"line\">        ListNode next = head.next;</div><div class=\"line\">        head.next = newHead;</div><div class=\"line\">        newHead = head;</div><div class=\"line\">        head = next;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return newHead;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">public ListNode reverseList(ListNode head) &#123;</div><div class=\"line\">    /* recursive solution */</div><div class=\"line\">    return reverseListInt(head, null);</div><div class=\"line\">&#125;</div><div class=\"line\">private ListNode reverseListInt(ListNode head, ListNode newHead) &#123;</div><div class=\"line\">    if (head == null)</div><div class=\"line\">        return newHead;</div><div class=\"line\">    ListNode next = head.next;</div><div class=\"line\">    head.next = newHead;</div><div class=\"line\">    return reverseListInt(next, head);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>递归一般来说是遍历到末尾，再依次从末尾返回到起始位置，但是在本题的递归解法中，<strong>递归是从头往后解题</strong>——每一步递归其实都已经在构造最后的反向链表，最后返回的只是构造完成之后的新链表的头结点。</p>\n","excerpt":"","more":"<h2 id=\"leetcode-206-Reverse-Linked-List\"><a href=\"#leetcode-206-Reverse-Linked-List\" class=\"headerlink\" title=\"leetcode#206 Reverse Linked List\"></a>leetcode#206 Reverse Linked List</h2><blockquote>\n<p>Reverse a singly linked list.</p>\n<p>A linked list can be reversed either iteratively or recursively. </p>\n</blockquote>\n<h5 id=\"解释：\"><a href=\"#解释：\" class=\"headerlink\" title=\"解释：\"></a>解释：</h5><p>单链表反转。</p>\n<p>可以使用递归和非递归方法。</p>\n<h5 id=\"理解：\"><a href=\"#理解：\" class=\"headerlink\" title=\"理解：\"></a>理解：</h5><p>单链表反转，需要在头指针<code>head</code>的基础上，多使用两个指针实现链表<code>next</code>指向的变更，<code>head</code>指针用于向后探索以及链表<code>next</code>指向变化之后将临时指针切换到<code>head</code>位置。</p>\n<h5 id=\"我的解法（非递归）：\"><a href=\"#我的解法（非递归）：\" class=\"headerlink\" title=\"我的解法（非递归）：\"></a>我的解法（非递归）：</h5><p>除了边界判断之外，如果头指针<code>head</code>的下一个节点不为空，则在中间部分<code>tmp1</code>、<code>tmp2</code>和<code>head</code>三个指针将依次从前往后排序，这时首先将中间节点的<code>next</code>指针反向，指向之前的节点，然后将前一个节点的指针<code>tmp1</code>移动到中间的节点，最后将中间节点的指针<code>tmp2</code>移动到<code>head</code>位置。一直重复直到<code>head</code>之后没有节点，这时只需要改变<code>head</code>所指节点的<code>next</code>指针，指向之前的节点即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Definition for singly-linked list.</div><div class=\"line\"> * public class ListNode &#123;</div><div class=\"line\"> *     int val;</div><div class=\"line\"> *     ListNode next;</div><div class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</div><div class=\"line\"> * &#125;</div><div class=\"line\"> */</div><div class=\"line\">public class Solution &#123;</div><div class=\"line\">    public ListNode reverseList(ListNode head) &#123;</div><div class=\"line\">        if(head == null || head.next == null) &#123; return head; &#125;</div><div class=\"line\">        ListNode tmp1 = head;</div><div class=\"line\">        head = head.next;</div><div class=\"line\">        ListNode tmp2 = head;</div><div class=\"line\">        tmp1.next = null;</div><div class=\"line\">        </div><div class=\"line\">        while(head.next != null) &#123;</div><div class=\"line\">            head = head.next;</div><div class=\"line\">            tmp2.next = tmp1;</div><div class=\"line\">            tmp1 = tmp2;</div><div class=\"line\">            tmp2 = head;</div><div class=\"line\">        &#125;</div><div class=\"line\">        head.next = tmp1;</div><div class=\"line\">        return head;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"大神的解法：\"><a href=\"#大神的解法：\" class=\"headerlink\" title=\"大神的解法：\"></a>大神的解法：</h5><ul>\n<li>非递归方法：思路一致，不过他的解法更为简洁，直接让循环从两个指针开始，在循环内部再<strong>动态生成</strong>第三个指针；</li>\n<li>递归方法：由于leetcode中给的方法只有一个形参，所以另写了一个含有两个形参的私有方法，该方法<strong>每次传入两个相邻的节点</strong>，在方法内动态生成一个指向后续第三个节点的指针，然后中间的节点改变<code>next</code>的指向，指向前一个节点，然后再将中间和第三个节点的指针当做参数进行后续的递归。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ListNode reverseList(ListNode head) &#123;</div><div class=\"line\">    /* iterative solution &amp;&amp; non-recursive solution */</div><div class=\"line\">    ListNode newHead = null;</div><div class=\"line\">    while (head != null) &#123;</div><div class=\"line\">        ListNode next = head.next;</div><div class=\"line\">        head.next = newHead;</div><div class=\"line\">        newHead = head;</div><div class=\"line\">        head = next;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return newHead;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">public ListNode reverseList(ListNode head) &#123;</div><div class=\"line\">    /* recursive solution */</div><div class=\"line\">    return reverseListInt(head, null);</div><div class=\"line\">&#125;</div><div class=\"line\">private ListNode reverseListInt(ListNode head, ListNode newHead) &#123;</div><div class=\"line\">    if (head == null)</div><div class=\"line\">        return newHead;</div><div class=\"line\">    ListNode next = head.next;</div><div class=\"line\">    head.next = newHead;</div><div class=\"line\">    return reverseListInt(next, head);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>递归一般来说是遍历到末尾，再依次从末尾返回到起始位置，但是在本题的递归解法中，<strong>递归是从头往后解题</strong>——每一步递归其实都已经在构造最后的反向链表，最后返回的只是构造完成之后的新链表的头结点。</p>\n"},{"title":"leetcode203 RemoveLinkedListElements","date":"2017-04-07T02:00:00.000Z","_content":"\n## leetcode#203 Remove Linked List Elements \n\n>Remove all elements from a linked list of integers that have value **val**.\n>\n>**Example**\n>**Given:** 1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6, **val** = 6\n>**Return:** 1 --> 2 --> 3 --> 4 --> 5\n\n##### 解释：\n\n给定一个单链表和一个值，若链表节点的值等于给定值，则将该节点删除。\n\n##### 理解：\n\n这道题可以递归也可以非递归。\n\n递归，除了边界判断，就直接遍历到链表的最末尾，然后依次往前返回，每一次返回的时候都比较一下当前节点值是否与给定值相同，若相同，则**返回当前节点的后一个节点**，即跳过当前节点；若不同，则返回当前节点。\n\n非递归，除了边界判断，则另外需要两个指针`tmp1`和`tmp2`，`tmp2`作为走在前面的探索指针，将会比较当前所指节点的值是否与给定值相同，若相同，则移动到下一个节点，若不同，则`tmp1`将会把所指节点的`next`指向`tmp2`所在的节点，然后`tmp1`将会移动到`tmp2`的位置。\n\n##### 我的解法：\n\n非递归方法：\n\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        if(head == null) return null;\n        while(head.val == val) {\n            head = head.next;\n            if(head == null) return null;\n        }\n        ListNode tmp1 = head;\n        ListNode tmp2 = tmp1.next;\n        while(tmp2 != null) {\n            if(tmp2.val == val) { tmp2 = tmp2.next; }\n            else {\n                tmp1.next = tmp2;\n                tmp1 = tmp2;\n                tmp2 = tmp2.next;\n            }\n        }\n        tmp1.next = null;\n        return head;\n    }\n}\n```\n\n##### 大神解法：\n\n非递归方法：\n\n只用了额外的一个指针`curr`，在循环的时候，每次都让`curr`下一个节点的值与给定值比较，**若相同，则改变`curr`所指节点`next`的指向**，指向后续的节点，这样一来循环条件就可以保持不变，变化的只是`curr.next`所指的节点。\n\n```\npublic class Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        while (head != null && head.val == val) head = head.next;\n        ListNode curr = head;\n        while (curr != null && curr.next != null)\n            if (curr.next.val == val) curr.next = curr.next.next;\n            else curr = curr.next;\n        return head;\n    }\n}\n```\n\n递归方法：\n\n```\npublic ListNode removeElements(ListNode head, int val) {\n        if (head == null) return null;\n        head.next = removeElements(head.next, val);\n        return head.val == val ? head.next : head;\n}\n```\n\n### 总结：\n\n本题比较简单，基本的单链表`next`指针指向的改变，注意改变的顺序就可以了。","source":"_posts/leetcode203-RemoveLinkedListElements.md","raw":"title: leetcode203 RemoveLinkedListElements\n\ndate: 2017/04/07 10:00:00\n\ncategories:\n\n- Study\n\ntags:\n\n- leetcode\n- linkedlist\n\n---\n\n## leetcode#203 Remove Linked List Elements \n\n>Remove all elements from a linked list of integers that have value **val**.\n>\n>**Example**\n>**Given:** 1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6, **val** = 6\n>**Return:** 1 --> 2 --> 3 --> 4 --> 5\n\n##### 解释：\n\n给定一个单链表和一个值，若链表节点的值等于给定值，则将该节点删除。\n\n##### 理解：\n\n这道题可以递归也可以非递归。\n\n递归，除了边界判断，就直接遍历到链表的最末尾，然后依次往前返回，每一次返回的时候都比较一下当前节点值是否与给定值相同，若相同，则**返回当前节点的后一个节点**，即跳过当前节点；若不同，则返回当前节点。\n\n非递归，除了边界判断，则另外需要两个指针`tmp1`和`tmp2`，`tmp2`作为走在前面的探索指针，将会比较当前所指节点的值是否与给定值相同，若相同，则移动到下一个节点，若不同，则`tmp1`将会把所指节点的`next`指向`tmp2`所在的节点，然后`tmp1`将会移动到`tmp2`的位置。\n\n##### 我的解法：\n\n非递归方法：\n\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        if(head == null) return null;\n        while(head.val == val) {\n            head = head.next;\n            if(head == null) return null;\n        }\n        ListNode tmp1 = head;\n        ListNode tmp2 = tmp1.next;\n        while(tmp2 != null) {\n            if(tmp2.val == val) { tmp2 = tmp2.next; }\n            else {\n                tmp1.next = tmp2;\n                tmp1 = tmp2;\n                tmp2 = tmp2.next;\n            }\n        }\n        tmp1.next = null;\n        return head;\n    }\n}\n```\n\n##### 大神解法：\n\n非递归方法：\n\n只用了额外的一个指针`curr`，在循环的时候，每次都让`curr`下一个节点的值与给定值比较，**若相同，则改变`curr`所指节点`next`的指向**，指向后续的节点，这样一来循环条件就可以保持不变，变化的只是`curr.next`所指的节点。\n\n```\npublic class Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        while (head != null && head.val == val) head = head.next;\n        ListNode curr = head;\n        while (curr != null && curr.next != null)\n            if (curr.next.val == val) curr.next = curr.next.next;\n            else curr = curr.next;\n        return head;\n    }\n}\n```\n\n递归方法：\n\n```\npublic ListNode removeElements(ListNode head, int val) {\n        if (head == null) return null;\n        head.next = removeElements(head.next, val);\n        return head.val == val ? head.next : head;\n}\n```\n\n### 总结：\n\n本题比较简单，基本的单链表`next`指针指向的改变，注意改变的顺序就可以了。","slug":"leetcode203-RemoveLinkedListElements","published":1,"updated":"2017-04-07T01:59:16.566Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj176pg6x000000up4aj4mq1a","content":"<h2 id=\"leetcode-203-Remove-Linked-List-Elements\"><a href=\"#leetcode-203-Remove-Linked-List-Elements\" class=\"headerlink\" title=\"leetcode#203 Remove Linked List Elements\"></a>leetcode#203 Remove Linked List Elements</h2><blockquote>\n<p>Remove all elements from a linked list of integers that have value <strong>val</strong>.</p>\n<p><strong>Example</strong><br><strong>Given:</strong> 1 –&gt; 2 –&gt; 6 –&gt; 3 –&gt; 4 –&gt; 5 –&gt; 6, <strong>val</strong> = 6<br><strong>Return:</strong> 1 –&gt; 2 –&gt; 3 –&gt; 4 –&gt; 5</p>\n</blockquote>\n<h5 id=\"解释：\"><a href=\"#解释：\" class=\"headerlink\" title=\"解释：\"></a>解释：</h5><p>给定一个单链表和一个值，若链表节点的值等于给定值，则将该节点删除。</p>\n<h5 id=\"理解：\"><a href=\"#理解：\" class=\"headerlink\" title=\"理解：\"></a>理解：</h5><p>这道题可以递归也可以非递归。</p>\n<p>递归，除了边界判断，就直接遍历到链表的最末尾，然后依次往前返回，每一次返回的时候都比较一下当前节点值是否与给定值相同，若相同，则<strong>返回当前节点的后一个节点</strong>，即跳过当前节点；若不同，则返回当前节点。</p>\n<p>非递归，除了边界判断，则另外需要两个指针<code>tmp1</code>和<code>tmp2</code>，<code>tmp2</code>作为走在前面的探索指针，将会比较当前所指节点的值是否与给定值相同，若相同，则移动到下一个节点，若不同，则<code>tmp1</code>将会把所指节点的<code>next</code>指向<code>tmp2</code>所在的节点，然后<code>tmp1</code>将会移动到<code>tmp2</code>的位置。</p>\n<h5 id=\"我的解法：\"><a href=\"#我的解法：\" class=\"headerlink\" title=\"我的解法：\"></a>我的解法：</h5><p>非递归方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Definition for singly-linked list.</div><div class=\"line\"> * public class ListNode &#123;</div><div class=\"line\"> *     int val;</div><div class=\"line\"> *     ListNode next;</div><div class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</div><div class=\"line\"> * &#125;</div><div class=\"line\"> */</div><div class=\"line\">public class Solution &#123;</div><div class=\"line\">    public ListNode removeElements(ListNode head, int val) &#123;</div><div class=\"line\">        if(head == null) return null;</div><div class=\"line\">        while(head.val == val) &#123;</div><div class=\"line\">            head = head.next;</div><div class=\"line\">            if(head == null) return null;</div><div class=\"line\">        &#125;</div><div class=\"line\">        ListNode tmp1 = head;</div><div class=\"line\">        ListNode tmp2 = tmp1.next;</div><div class=\"line\">        while(tmp2 != null) &#123;</div><div class=\"line\">            if(tmp2.val == val) &#123; tmp2 = tmp2.next; &#125;</div><div class=\"line\">            else &#123;</div><div class=\"line\">                tmp1.next = tmp2;</div><div class=\"line\">                tmp1 = tmp2;</div><div class=\"line\">                tmp2 = tmp2.next;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        tmp1.next = null;</div><div class=\"line\">        return head;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"大神解法：\"><a href=\"#大神解法：\" class=\"headerlink\" title=\"大神解法：\"></a>大神解法：</h5><p>非递归方法：</p>\n<p>只用了额外的一个指针<code>curr</code>，在循环的时候，每次都让<code>curr</code>下一个节点的值与给定值比较，<strong>若相同，则改变<code>curr</code>所指节点<code>next</code>的指向</strong>，指向后续的节点，这样一来循环条件就可以保持不变，变化的只是<code>curr.next</code>所指的节点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Solution &#123;</div><div class=\"line\">    public ListNode removeElements(ListNode head, int val) &#123;</div><div class=\"line\">        while (head != null &amp;&amp; head.val == val) head = head.next;</div><div class=\"line\">        ListNode curr = head;</div><div class=\"line\">        while (curr != null &amp;&amp; curr.next != null)</div><div class=\"line\">            if (curr.next.val == val) curr.next = curr.next.next;</div><div class=\"line\">            else curr = curr.next;</div><div class=\"line\">        return head;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>递归方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ListNode removeElements(ListNode head, int val) &#123;</div><div class=\"line\">        if (head == null) return null;</div><div class=\"line\">        head.next = removeElements(head.next, val);</div><div class=\"line\">        return head.val == val ? head.next : head;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>本题比较简单，基本的单链表<code>next</code>指针指向的改变，注意改变的顺序就可以了。</p>\n","excerpt":"","more":"<h2 id=\"leetcode-203-Remove-Linked-List-Elements\"><a href=\"#leetcode-203-Remove-Linked-List-Elements\" class=\"headerlink\" title=\"leetcode#203 Remove Linked List Elements\"></a>leetcode#203 Remove Linked List Elements</h2><blockquote>\n<p>Remove all elements from a linked list of integers that have value <strong>val</strong>.</p>\n<p><strong>Example</strong><br><strong>Given:</strong> 1 –&gt; 2 –&gt; 6 –&gt; 3 –&gt; 4 –&gt; 5 –&gt; 6, <strong>val</strong> = 6<br><strong>Return:</strong> 1 –&gt; 2 –&gt; 3 –&gt; 4 –&gt; 5</p>\n</blockquote>\n<h5 id=\"解释：\"><a href=\"#解释：\" class=\"headerlink\" title=\"解释：\"></a>解释：</h5><p>给定一个单链表和一个值，若链表节点的值等于给定值，则将该节点删除。</p>\n<h5 id=\"理解：\"><a href=\"#理解：\" class=\"headerlink\" title=\"理解：\"></a>理解：</h5><p>这道题可以递归也可以非递归。</p>\n<p>递归，除了边界判断，就直接遍历到链表的最末尾，然后依次往前返回，每一次返回的时候都比较一下当前节点值是否与给定值相同，若相同，则<strong>返回当前节点的后一个节点</strong>，即跳过当前节点；若不同，则返回当前节点。</p>\n<p>非递归，除了边界判断，则另外需要两个指针<code>tmp1</code>和<code>tmp2</code>，<code>tmp2</code>作为走在前面的探索指针，将会比较当前所指节点的值是否与给定值相同，若相同，则移动到下一个节点，若不同，则<code>tmp1</code>将会把所指节点的<code>next</code>指向<code>tmp2</code>所在的节点，然后<code>tmp1</code>将会移动到<code>tmp2</code>的位置。</p>\n<h5 id=\"我的解法：\"><a href=\"#我的解法：\" class=\"headerlink\" title=\"我的解法：\"></a>我的解法：</h5><p>非递归方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Definition for singly-linked list.</div><div class=\"line\"> * public class ListNode &#123;</div><div class=\"line\"> *     int val;</div><div class=\"line\"> *     ListNode next;</div><div class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</div><div class=\"line\"> * &#125;</div><div class=\"line\"> */</div><div class=\"line\">public class Solution &#123;</div><div class=\"line\">    public ListNode removeElements(ListNode head, int val) &#123;</div><div class=\"line\">        if(head == null) return null;</div><div class=\"line\">        while(head.val == val) &#123;</div><div class=\"line\">            head = head.next;</div><div class=\"line\">            if(head == null) return null;</div><div class=\"line\">        &#125;</div><div class=\"line\">        ListNode tmp1 = head;</div><div class=\"line\">        ListNode tmp2 = tmp1.next;</div><div class=\"line\">        while(tmp2 != null) &#123;</div><div class=\"line\">            if(tmp2.val == val) &#123; tmp2 = tmp2.next; &#125;</div><div class=\"line\">            else &#123;</div><div class=\"line\">                tmp1.next = tmp2;</div><div class=\"line\">                tmp1 = tmp2;</div><div class=\"line\">                tmp2 = tmp2.next;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        tmp1.next = null;</div><div class=\"line\">        return head;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"大神解法：\"><a href=\"#大神解法：\" class=\"headerlink\" title=\"大神解法：\"></a>大神解法：</h5><p>非递归方法：</p>\n<p>只用了额外的一个指针<code>curr</code>，在循环的时候，每次都让<code>curr</code>下一个节点的值与给定值比较，<strong>若相同，则改变<code>curr</code>所指节点<code>next</code>的指向</strong>，指向后续的节点，这样一来循环条件就可以保持不变，变化的只是<code>curr.next</code>所指的节点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Solution &#123;</div><div class=\"line\">    public ListNode removeElements(ListNode head, int val) &#123;</div><div class=\"line\">        while (head != null &amp;&amp; head.val == val) head = head.next;</div><div class=\"line\">        ListNode curr = head;</div><div class=\"line\">        while (curr != null &amp;&amp; curr.next != null)</div><div class=\"line\">            if (curr.next.val == val) curr.next = curr.next.next;</div><div class=\"line\">            else curr = curr.next;</div><div class=\"line\">        return head;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>递归方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ListNode removeElements(ListNode head, int val) &#123;</div><div class=\"line\">        if (head == null) return null;</div><div class=\"line\">        head.next = removeElements(head.next, val);</div><div class=\"line\">        return head.val == val ? head.next : head;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>本题比较简单，基本的单链表<code>next</code>指针指向的改变，注意改变的顺序就可以了。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cj0x6gzdu0000kkupp98e1j9t","category_id":"cj0x6gzdz0003kkupqhpeaqtr","_id":"cj0x6gze70009kkup2a0dnqmd"},{"post_id":"cj10hihax00006kup0go1cyyi","category_id":"cj0x6gzdz0003kkupqhpeaqtr","_id":"cj10hihb300026kuptlabk7ek"},{"post_id":"cj0x6gze10005kkupar21ksrk","category_id":"cj0x6gzdz0003kkupqhpeaqtr","_id":"cj10hihbc00046kup59605ifk"},{"post_id":"cj0x6gze30006kkup735oxhbj","category_id":"cj0x6gzdz0003kkupqhpeaqtr","_id":"cj10hihbg00056kupnt1yyef8"},{"post_id":"cj0z0ce5s0000m8up0nk8ud29","category_id":"cj0x6gzdz0003kkupqhpeaqtr","_id":"cj10hihbh00066kuphgz4vxwr"},{"post_id":"cj0yz01tk0004qwup2i45dgts","category_id":"cj0x6gzdz0003kkupqhpeaqtr","_id":"cj10hihbi00076kupqxkbg1o9"},{"post_id":"cj0yz01tk0000qwupv6tpz459","category_id":"cj0x6gzdz0003kkupqhpeaqtr","_id":"cj10hihbj00086kupi19wk232"},{"post_id":"cj14sfspg00008kup526gkiqu","category_id":"cj0x6gzdz0003kkupqhpeaqtr","_id":"cj14sfspl00028kuptzran06w"},{"post_id":"cj16k96by0000bsup53qu7y1r","category_id":"cj0x6gzdz0003kkupqhpeaqtr","_id":"cj16k96c30002bsupqoey2snq"},{"post_id":"cj176pg6x000000up4aj4mq1a","category_id":"cj0x6gzdz0003kkupqhpeaqtr","_id":"cj176pg70000200upnk69ut9t"}],"PostTag":[{"post_id":"cj0x6gzdu0000kkupp98e1j9t","tag_id":"cj0x6gze00004kkup84zjiehp","_id":"cj0x6gze7000bkkup8userely"},{"post_id":"cj0x6gzdu0000kkupp98e1j9t","tag_id":"cj0x6gze40008kkupet2ybfdr","_id":"cj0x6gze7000ckkupawazjpz0"},{"post_id":"cj0x6gze10005kkupar21ksrk","tag_id":"cj0x6gze7000akkupw28sy60b","_id":"cj0x6gzea000fkkupqd6x9oi6"},{"post_id":"cj0x6gze10005kkupar21ksrk","tag_id":"cj0x6gze8000dkkup4lz5nbla","_id":"cj0x6gzea000gkkuph2n6jk9z"},{"post_id":"cj0x6gze30006kkup735oxhbj","tag_id":"cj0x6gze00004kkup84zjiehp","_id":"cj0x6gzeb000jkkupml3heq6l"},{"post_id":"cj0x6gze30006kkup735oxhbj","tag_id":"cj0x6gze8000dkkup4lz5nbla","_id":"cj0x6gzeb000kkkupdkp9pbv0"},{"post_id":"cj0x6gze30006kkup735oxhbj","tag_id":"cj0x6gzea000hkkupiew2tnl7","_id":"cj0x6gzec000mkkupiavxjuwl"},{"post_id":"cj0yz01tk0000qwupv6tpz459","tag_id":"cj0x6gzea000ikkup5ose205q","_id":"cj0yz01tk0001qwupfkshisii"},{"post_id":"cj0yz01tk0000qwupv6tpz459","tag_id":"cj0x6gzed000okkupn2a4wx2o","_id":"cj0yz01tk0002qwupdjtsiloe"},{"post_id":"cj0yz01tk0000qwupv6tpz459","tag_id":"cj0x6gzec000lkkups5gxf4hq","_id":"cj0yz01tk0003qwup9mfeoypp"},{"post_id":"cj0yz01tk0004qwup2i45dgts","tag_id":"cj0x6gzea000ikkup5ose205q","_id":"cj0yz01tk0005qwup436ji4dy"},{"post_id":"cj0yz01tk0004qwup2i45dgts","tag_id":"cj0x6gzec000lkkups5gxf4hq","_id":"cj0yz01tk0006qwup49n5abui"},{"post_id":"cj0yz01tk0004qwup2i45dgts","tag_id":"cj0x6gzec000nkkupq3c60ue9","_id":"cj0yz01tk0007qwupzzkfilla"},{"post_id":"cj0yz01tk0004qwup2i45dgts","tag_id":"cj0x6gzed000okkupn2a4wx2o","_id":"cj0yz01tk0008qwupzyhvvp4f"},{"post_id":"cj0z0ce5s0000m8up0nk8ud29","tag_id":"cj0x6gzea000ikkup5ose205q","_id":"cj0z0ce5x0001m8upsek3p6ax"},{"post_id":"cj0z0ce5s0000m8up0nk8ud29","tag_id":"cj0x6gzec000lkkups5gxf4hq","_id":"cj0z0ce5y0002m8upy4ngu2qq"},{"post_id":"cj10hihax00006kup0go1cyyi","tag_id":"cj0x6gzea000ikkup5ose205q","_id":"cj10hihb200016kup85i8nczd"},{"post_id":"cj10hihax00006kup0go1cyyi","tag_id":"cj0x6gzec000lkkups5gxf4hq","_id":"cj10hihb300036kupzsz2xq67"},{"post_id":"cj14sfspg00008kup526gkiqu","tag_id":"cj0x6gzea000ikkup5ose205q","_id":"cj14sfspk00018kupjuj4n5vw"},{"post_id":"cj14sfspg00008kup526gkiqu","tag_id":"cj0x6gzec000lkkups5gxf4hq","_id":"cj14sfspl00038kupx25n989q"},{"post_id":"cj16k96by0000bsup53qu7y1r","tag_id":"cj0x6gzea000ikkup5ose205q","_id":"cj16k96c20001bsupc3jt5ncv"},{"post_id":"cj16k96by0000bsup53qu7y1r","tag_id":"cj0x6gzec000lkkups5gxf4hq","_id":"cj16k96c30003bsupsi00gthv"},{"post_id":"cj176pg6x000000up4aj4mq1a","tag_id":"cj0x6gzea000ikkup5ose205q","_id":"cj176pg70000100upp8y5mzm6"},{"post_id":"cj176pg6x000000up4aj4mq1a","tag_id":"cj0x6gzec000lkkups5gxf4hq","_id":"cj176pg72000300up7xkq0mi0"}],"Tag":[{"name":"BlogTools","_id":"cj0x6gze00004kkup84zjiehp"},{"name":"Markdown","_id":"cj0x6gze40008kkupet2ybfdr"},{"name":"Git","_id":"cj0x6gze7000akkupw28sy60b"},{"name":"Github","_id":"cj0x6gze8000dkkup4lz5nbla"},{"name":"hexo","_id":"cj0x6gzea000hkkupiew2tnl7"},{"name":"leetcode","_id":"cj0x6gzea000ikkup5ose205q"},{"name":"linkedlist","_id":"cj0x6gzec000lkkups5gxf4hq"},{"name":"array","_id":"cj0x6gzec000nkkupq3c60ue9"},{"name":"recursive algorithm","_id":"cj0x6gzed000okkupn2a4wx2o"},{"name":"recursive algorithms","_id":"cj0yy39jt00068sup6r2zh4n0"}]}}