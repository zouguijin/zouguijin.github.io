{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/noise/source/css/font.less","path":"css/font.less","modified":0,"renderable":1},{"_id":"themes/noise/source/css/highlight.less","path":"css/highlight.less","modified":0,"renderable":1},{"_id":"themes/noise/source/css/noise.less","path":"css/noise.less","modified":0,"renderable":1},{"_id":"themes/noise/source/css/normalize.css","path":"css/normalize.css","modified":0,"renderable":1}],"Cache":[{"_id":"themes/noise/.travis.yml","hash":"9195328ae9f1b8c5089f2c898e1b9bf019980164","modified":1487581801893},{"_id":"themes/noise/LICENSE","hash":"86c2c15a2d0c891e5c0912e31ff7a12ef694ce3f","modified":1487581801893},{"_id":"themes/noise/README.md","hash":"f933e665385bafbee34f6ae95307e767bbe05b62","modified":1487581801893},{"_id":"themes/noise/_config.yml","hash":"32d63000d3d8aa5711fe56f56299aeb4ed392ee3","modified":1487581945862},{"_id":"source/_posts/hello-world.md","hash":"029f91fccbe8f87c0f3ea10c4042300d2fa7edc0","modified":1487581657362},{"_id":"source/_posts/git-study.md","hash":"a6cf7782f7b8cd6a505a75acfd6cdbdcd3af827f","modified":1487898521678},{"_id":"themes/noise/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1487581801877},{"_id":"themes/noise/.git/config","hash":"1bff9b6eaf288cbd3cca2c31c4e14b203f29d71d","modified":1487581801893},{"_id":"source/about/index.md","hash":"90adfc7f8d092ef87ff3d05e0d78e8b3ffff81b9","modified":1487582015140},{"_id":"themes/noise/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1487581798183},{"_id":"themes/noise/.git/index","hash":"c4f75e88d064e96965beea8fc3cc1a9d7fb1805d","modified":1487581801893},{"_id":"themes/noise/.git/packed-refs","hash":"6c16071509a9073452c8999c0a63cc23a55d7b54","modified":1487581801877},{"_id":"themes/noise/layout/archive.jade","hash":"633384e3627380c91a7ed1f23a82a448cb4a6161","modified":1487581801893},{"_id":"themes/noise/layout/base.jade","hash":"8f075c5dfa7a380934bcae29875b9ae85751bcfa","modified":1487581801893},{"_id":"themes/noise/layout/index.jade","hash":"cb0e954c2848a46618757c3c20e88ef49385df47","modified":1487581801893},{"_id":"themes/noise/layout/page.jade","hash":"acf65a9f678a3b278a4ac20de8754bc9ab0c8f37","modified":1487581801893},{"_id":"themes/noise/layout/post.jade","hash":"64c91e9eda4ca9e77607cf253694e1a9a10c7383","modified":1487581801893},{"_id":"themes/noise/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1487581798183},{"_id":"themes/noise/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1487581798183},{"_id":"themes/noise/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1487581798183},{"_id":"themes/noise/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1487581798183},{"_id":"themes/noise/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1487581798183},{"_id":"themes/noise/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1487581798183},{"_id":"themes/noise/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1487581798183},{"_id":"themes/noise/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1487581798183},{"_id":"themes/noise/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1487581798183},{"_id":"themes/noise/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1487581798183},{"_id":"themes/noise/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1487581798183},{"_id":"themes/noise/.git/logs/HEAD","hash":"2d00eb247a7a649d40054fcdb5c8e10570db7ab4","modified":1487581801877},{"_id":"themes/noise/source/css/_variables.less","hash":"488149b5a7c2953396b859074fa58e4d80dd0442","modified":1487581801893},{"_id":"themes/noise/source/css/font.less","hash":"ff469bbb929ad07d8fa9a8881129ea225adeeb73","modified":1487581801893},{"_id":"themes/noise/source/css/highlight.less","hash":"6a00e35295f5b890a3a6daa6f6656af50d918721","modified":1487581801893},{"_id":"themes/noise/source/css/noise.less","hash":"c2bb7170d4b8f5b8e4956e5ffe8c4f1c4069c74a","modified":1487581801893},{"_id":"themes/noise/source/css/normalize.css","hash":"46844f2fc407f66636c6e783ddaeed2a684c2f8f","modified":1487581801893},{"_id":"themes/noise/layout/_partial/comments.jade","hash":"f97607b36dafaa9ef3dc109d7b8393aef5cef19e","modified":1487581801893},{"_id":"themes/noise/layout/_partial/paginator.jade","hash":"484f0850cdc8d8a954c0ac7131ebfd067047c5e5","modified":1487581801893},{"_id":"themes/noise/layout/_partial/helpers.jade","hash":"f87b4f41e2ddbd3db10fb2ebaa342954c4d8d9a0","modified":1487581801893},{"_id":"themes/noise/.git/objects/pack/pack-fdb83ccd805a304799dafda5e6e40c21b321adb2.idx","hash":"5e1ff6ccdda82473dccf8ce2f0652b179982d789","modified":1487581801768},{"_id":"themes/noise/.git/refs/heads/master","hash":"44343f89297925bc1cd6ea4b4c3da6f18a18179c","modified":1487581801877},{"_id":"themes/noise/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1487581801877},{"_id":"themes/noise/.git/logs/refs/heads/master","hash":"2d00eb247a7a649d40054fcdb5c8e10570db7ab4","modified":1487581801877},{"_id":"themes/noise/.git/logs/refs/remotes/origin/HEAD","hash":"2d00eb247a7a649d40054fcdb5c8e10570db7ab4","modified":1487581801877},{"_id":"themes/noise/.git/objects/pack/pack-fdb83ccd805a304799dafda5e6e40c21b321adb2.pack","hash":"b5b7654e1bfee65e8ccb56fb6d102d6936c3f787","modified":1487581801784},{"_id":"public/about/index.html","hash":"2effff024c78bae15fe72e188c256f73de6c29eb","modified":1487904869931},{"_id":"public/2017/02/24/hello-world/index.html","hash":"7cee61b639fa59c48a0a0a96f185e33d6917ee19","modified":1487904869931},{"_id":"public/index.html","hash":"b0ce3818667038f2953c62ff8acc54e2f6d2d08b","modified":1487904869931},{"_id":"public/archives/index.html","hash":"c62806ed840f31558f3c531b737d548f49b41fd2","modified":1487904869931},{"_id":"public/archives/2017/index.html","hash":"c62806ed840f31558f3c531b737d548f49b41fd2","modified":1487904869931},{"_id":"public/archives/2017/02/index.html","hash":"c62806ed840f31558f3c531b737d548f49b41fd2","modified":1487904869931},{"_id":"public/2017/02/24/git-study/index.html","hash":"10ac37c1fd29d9c9e053d1668a5b9bc204f54351","modified":1487904869931},{"_id":"public/css/normalize.css","hash":"d0fbef3dd405f26a5fdc896ca1f7875901782c6f","modified":1487904869978},{"_id":"public/css/font.css","hash":"675361046170c7a4e8c11c774f64b3d1a631b900","modified":1487904869978},{"_id":"public/css/highlight.css","hash":"061dc4e4c8f818a08c7f23aab625345b2d677d5f","modified":1487904870009},{"_id":"public/css/noise.css","hash":"56092b4a16cfcdcad32c5b6136fd5cb3c14989df","modified":1487904870009}],"Category":[],"Data":[],"Page":[{"title":"About Me","_content":"# About\n\n","source":"about/index.md","raw":"---\ntitle: About Me\n---\n# About\n\n","date":"2017-02-20T09:16:11.302Z","updated":"2017-02-20T09:13:35.140Z","path":"about/index.html","comments":1,"layout":"page","_id":"cizj854z90001y8upq26m3qce","content":"<h1 id=\"About\"><a href=\"#About\" class=\"headerlink\" title=\"About\"></a>About</h1>","excerpt":"","more":"<h1 id=\"About\"><a href=\"#About\" class=\"headerlink\" title=\"About\"></a>About</h1>"}],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2017-02-24T02:40:00.739Z","updated":"2017-02-20T09:07:37.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizj854z90000y8up2lof7a5a","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n"},{"title":"Git Study","_content":"\n# Git Study\n### Git Introduction\n\nGit是一种开源的分布式版本管理系统。\n\n每台安装了Git的机器上都会维持一个Git的本地仓库。\n\n### 本地版本库的创建与管理\n\n#### 创建与文件提交\n\n- 初始化一个Git仓库：`git init`；\n- 添加文件到Git仓库（[背后的原理](#gitadd-principle)）:\n  1. `git add <file>` ，可以使用多次，添加多个文件；\n  2. `git commit -m \"提交说明文字\"` ，完成一次提交。\n\n#### 查看仓库状态\n\n- `git status` ，查看本地仓库的[工作区](#workplace)状态，命令会告诉我们，当前有哪些文件被修改了，现在的状态是”没有添加任何文件“OR”已添加待提交“，此外还会对后续操作提示相应的命令；\n- `git diff` ， 如果有文件被修改了，可以用该命令查看具体的修改内容（有\"-\"号的一行说明有删减，有“+”的一行说明有增加）。\n\n#### 版本回退与回退的撤销\n\n- `git log` ，查看提交的历史记录，以便确定回退到哪一个版本，精简输出可以使用`git log --pretty=oneline`；<span id=\"versionback\"></span>\n\n- `git reflog` ，查看命令的历史记录，可以用于确定版本回退之前的最新版本号`commit_id` ；\n\n- `git reset --hard <commit_id>` ，`commit_id` 是版本号，是SHA1计算得出的十六进制数字，每提交一次就会新生成一个`commit_id` ，版本号没有必要每次都输入完整，保证前几位不同就可以。此外，`HEAD` 表示当前版本号，`HEAD^` 表示上一个版本号，以此类推，`HEAD~100` 表示上100个版本号。\n\n  **注意** ：对于只有一个版本的版本库是无法再回退到上一个状态（即最初初始化的状态）\n\n#### 工作区与暂存区\n\n- <span id=\"workplace\">工作区（Working Directory）</span>\n\n  也就是当时使用`git init` 初始化的本地仓库的目录/文件夹。\n\n- 版本库（Repository）\n\n  工作区内的隐藏目录`.git` ，这个目录不算工作区，而是属于版本库。版本库中最重要的部分是暂存区（stage/index）这也是Git与SVN不同之处，同时还有Git自动创建的第一个[分支](#branch)`master` 和指向`master` 的[指针`HEAD`](#pointer-HEAD) 。\n\n- 工作区与暂存区的关系\n\n  这里通过`git add <file>` 的<span id=\"gitadd-principle\">工作原理</span>来解释一下工作区与暂存区之间的关系。\n\n  1. `git add` 添加的时候，实际上是将文件或者文件的修改添加到暂存区中；\n\n  2. `git commit` 提交文件或文件修改，实际上是将暂存区的所有内容提交到当前分支中。\n\n     **注意**：\n\n     - 提交之后，工作区就没有任何新的修改，暂存区也没有任何内容，同时产生了新的版本。\n\n     - 提交的时候，Git只负责将已经加入暂存区的修改内容提交到分支中，即若`git add` 之后再对文件进行修改，那么此时修改的内容是不会提交到分支中的。\n\n       `git diff HEAD -- <file>` ，可以用于查看工作区与版本库中最新版本之间的区别。\n\n#### 管理与修改、删除\n\nGit跟踪并管理的是**文件的修改部分** ,而非整个文件。\n\n所以，如果修改没有从工作区添加到暂存区，那么这些修改就无法被提交到版本库的最新版本中。\n\n- `git checkout -- <file>` ，直接放弃对工作区的所有修改，这比一行一行的恢复更省力气，有时候对于不知道修改了哪部分内容的情况也很有用。\n\n- `git rm --cached <file>` ，将添加到暂存区的修改撤销（unstage），并将修改重新放回工作区，如果此时仍想撤销所有的修改，则执行命令`git checkout -- <file>` ；\n\n- 如果已经向本地版本库提交了不合适的修改并想要撤销时，需要[版本回退](#versionback)操作，前提是还没有推送到远程仓库。\n\n- 若要删除一个文件，需要在工作区和版本库中同时删除该文件 `git rm <file>` ，并在删除完成后重新提交`git commit -m <file> ` 一次：\n\n- 若在工作区错删了文件，则可以借助版本库，将该文件恢复到最新一次提交的状态：`git checkout -- <file>` *（当然，如果回收站还没清空的话，也可以去回收站看看）*；\n\n- **注** ：`git checkout` 的原理是，利用版本库中的最新版本替换工作区的版本。\n\n\n### 远程仓库\n\n可以自己搭建Git服务器作为远程仓库，也可以使用Github的免费仓库（但是是公开的所有人可见的）。\n\n一台电脑上也可以建立多个版本库，只要不在同一目录中即可。\n\nGit支持SSH协议。\n\n#### 添加远程库与推送Push\n\n在完成Github注册和SSH Key添加之后，就可以在Github上创建一个新的Git仓库，然后根据相应的提示，将本地仓库的文件推送（Push）到远程仓库中。\n\n- `git remote add origin <仓库地址>` ，在本地仓库目录下执行，将本地仓库与远程仓库进行关联，同时为远程仓库定义了新的名字`origin` ，当然也可以使用别的名字；\n- `git push -u origin master` ，将本地仓库的内容推送到远成仓库，实际上是将当前分支`master` 的内容推送到远程仓库的`master` 分支，由于刚开始远程仓库是空的，所以第一次推送的时候，需要参数`-u` ，这样在推送的同时，还会建立起本地分支`master` 和远程仓库中`master` 分支的联系，以后推送和拉取内容就可以简化命令，即`git push origin master` 和\n\n#### 从远程库克隆Clone\n\n- `git clone https://github.com/zouguijin/docSync.git` \n\n- `git clone git@github.com:zouguijin/docSync.git` \n\n  Git支持多种协议，默认的git（所使用的是ssh协议），此外还可以使用https协议（但是https协议有时候比较慢，而且每次推送都需要输入口令，使用ssh就不需要输入口令，`get clone` 的时候都要口令...）。\n\n### 分支（Branch）\n\n创建属于自己的分支，其他人是看不到的，一个未完成的项目可以在分支上不断更新，直到完成之后再一次提交到`master` 主分支上。\n\n#### 创建与合并\n\n- 原理：\n\n  一个分支就是一条时间线，随着不断地提交逐渐变长。最初只有主分支即`master` 分支，同时有一个`master` 指针指向主分支的最新提交，之前说的指针`HEAD` 指向的是指针`master` ，而不是指向最新提交。即：\n\n  > `HEAD` -> `master` -> `最新提交` \n\n  每次提交之后，`master` 分支都会向前延长，同时指针`master` 都会指向最新的提交，指针`HEAD` 的指向不变。\n\n  创建新的分支，例如`branch` 时，即创建新的指针`branch` ，指向与`master` 相同的提交，此时若将指针`HEAD` 指向`branch` ，则表示切换当前分支，由主分支切换到`branch` 分支。\n\n  > `master` ->`最新提交` <- `branch` <- `HEAD`  \n\n  如果在`branch` 分支下提交新的修改，那么`branch` 分支就会向前延长，指针`branch` 指向最新提交，但此时指针`master` 保持切换前的指向位置不变。\n\n  合并分支，也就是将主分支的`master` 指针指向`branch` 指针所指向的最新提交即可，合并分支后，一般都会将工作时使用的新分支`branch` 删除，即删除`branch` 指针。\n\n  **注** ：可见，所谓创建分支，只是创建了一个指针，切换、合并分支，只是改变了指针的指向，删除分支，只是将对应的指针删除，所有的操作都不涉及内容的改变。\n\n- 命令操作\n\n  - `git branch` ，查看分支情况，当前分支前会用`*` 标记；\n  - `git branch <name>` ，创建分支；\n  - `git checkout <name>` ，切换分支，由当前分支切换到指定命名分支；\n  - `git checkout -b <name>` ，创建&切换分支；\n  - `git merge <name>` ，合并分支，将指定命名分支合并到当前分支上；（默认使用`Fast Forward` 模式，该模式下删除分支后，分支信息也随之删除，即看不到历史合并信息；若希望能看到历史合并信息，就需要禁用FF模式，并最好添加注释信息，即`git merge --no-ff -m \"注释信息\" <name>`）\n  - `git branch -d <name>` ，删除指定命名分支。\n\n- 合并冲突<span id=\"conflict-solve\"></span>\n\n  如果两个需要合并的分支各自都有新的提交，而且两者的提交在同一位置有不同的表述，在合并的时候就会出现冲突，即不能简单地删除、添加或者替换。\n\n  冲突出现的时候，在显示分支的括号中会多出`|MERGING` 字样，表示此时必须解决合并冲突，分支切换操作被禁止，这时需要利用`git diff` 查看文件内容，并手动修改冲突的内容，然后重新添加和提交即可。（Git会用`<<<<<<<`，`=======`，`>>>>>>>`标记出不同分支的内容）\n\n  `git log --graph` 可以看到分支的合并情况，或者简化版`git log --graph --pretty=oneline --abbrev-commit` 。\n\n- 分支管理策略\n\n  - 保证主分支`master` 是稳定的，仅仅用于发布公开的、可以使用的新版本；\n  - 如果团队合作的话，需要新建一个团队开发提交的分支，例如`dev` 分支，平时的提交与合并都在该分支上完成，一个完整的版本完成之后再将`dev` 分支合并到主分支上。\n\n#### Bug分支\n\n当遇到Bug的时候，可以切换到需要修复Bug的分支上，在该分支上创建临时的Bug分支，在临时分支上修复Bug，然后合并原分支上，最后删除临时分支即可。\n\n此时，如果手头上的工作没有做完（工作区有正在修改的内容，如果将Bug修复完成之后就添加、提交，那么之前正在处理但未处理完成的工作就会和修复的Bug一起添加并提交上去，这是我们不想看见的），那么这时候就需要将未完成的工作**先拿出工作区并暂存**起来：\n\n> `git stash` \n\n此时，利用`git status` 查看工作区，会看见工作区是干净的。\n\n完成Bug修复之后，可以再将之前的工作取出来放进工作区继续完成：\n\n- `git stash list` ，若有多个工作，可以先查看列表，再决定需要恢复哪个工作；\n- `git stash apply` ，恢复工作之后，暂存的内容并不会自动删除，需要使用`git stash drop` 将相应的内容删除；\n- `git stash pop` ，推荐使用，恢复工作的同时，可以将暂存的内容也删除；\n- 若要指定恢复或者删除哪一条`stash` ，可以添加后续命令`stash@{x}` ，`x` 可以从`stash` 列表中选取。\n\n#### Feature分支\n\n为项目开发一个新的功能时，最好在项目分支上新建一个分支，功能完成之后再将新功能的代码合并到项目分支中。\n\n如果在合并之前，需要放弃该功能分支，则需要通过强行删除的操作完成：\n\n> `git branch -D <name>`\n\n#### 推送与抓取\n\n- `git remote -v` ，查看远程库的信息，会给出本地可以抓取和推送的远程库的地址以及远程库的命名（默认是`origin`）；\n\n- `git push origin <name> ` ，推送分支，即将指定分支上的所有本地内容推送到远程仓库中的**相对应**的分支上，可以推送本地`master` 分支内容，也可以推送其他分支的内容；\n\n- `git clone <git/https>` ，其他用户从远程库克隆的时候，默认情况下只能看到`master` 分支（当然其他分支也随之克隆下来了，只是不稍微调整是看不到的），前面说了，一般不会直接向`master` 分支推送修改，所以需要在本地创建远程仓库`origin` 的分支`branch` （这里的`branch` 需要与远程仓库的`branch` 同名）：\n\n  > `git checkout -b branch origin/branch` \n\n  只有这样，才能建立本地与远成仓库的联系，之后的抓取`git pull` 和推送`git push origin branch ` 才可以进行。\n\n- `git pull` ，抓取分支，首先需要建立本地分支与远程仓库相应分支之间的链接：\n\n  > `git branch --set-upstream branch origin/branch` \n\n  在之前建立本地分支与远程库分支的基础上，可以将最新的提交从远程库相应的分支上抓取下来：\n\n  > `git pull` \n\n  如果`git pull` 的时候出现冲突，则需要[解决冲突](#conflict-solve) 。\n\n- 本地分支，若不推送到远程，只有本地可见。\n\n### 标签（Tag）\n\n版本发布的时候，为了今后方便查找，一般会使用标签的方式，采用有意义的文字标记当前版本，即可以将标签当作版本库的一个快照，本质上标签就是一个指向某一次`commit` 的指针，类似于分支指针（但是分支指针可以移动，标签指针不可以移动）。\n\n- `git tag` ，查看所有标签；\n- `git tag <name>` ，为当前分支生成一个标签，标签默认标记在最新的提交上；\n- `git tag <name> <commit_id>` ，若想为历史的某一次提交生成标签，则找到该提交的`commit_id` 即可；\n- `git tag -a <tagname> -m \"注释信息\" <commit_id>` ，创建标签并生成注释；\n- `git show <tagname>` ，查看相应的标签信息；\n\n**注** ：标签是按照字母顺序排序的，而不是按照时间排序。\n\n- `git tag -d <tagname>` ，删除本地标签；\n\n- `git push origin <tagname>` ，将标签推送到远程仓库中；\n\n- `git push origin --tags` ，一次性地将本地标签全部推送到远程库中；\n\n- 若想要删除的标签已经被推送到了远程库中，那么需要两步才能删除标签：\n\n  >`git tag -d <tagname>` #首先，本地删除\n  >\n  >`git push origin :refs/tags/<tagname>` #然后，远程删除库中的标签\n\n### Github\n\n如果要参与开源项目，首先将开源项目`Fork` 到自己的仓库中，然后**从自己的仓库中`Clone` **，只有这样才能在本地修改之后，再次推送到Github上，若希望开源项目的官方接受自己的修改，则需要在Github上发起`Pull Request` 。\n\n### .gitignore\n\n.gitignore文件中的文件名将会在提交的时候被忽略，.gitignore文件需要放在版本库中。\n\n.gitignore文件不需要从头开始编写，可以参照[官方文档](https://github.com/github/gitignore '.gitignore-doc')并进行相应的组合即可。\n\n- `git add -f <file>` ，有时候.gitignore文件中禁止提交的文件类型中，有你希望提交的一份文件，则可以通过上述命令强行添加并提交；\n- `git check-ignore -v <file>` ，当发现一个文件无法添加和提交时，需要检查.gitignore文件中哪一条规则写错了，可以使用上述命令进行检查。\n\n### Git配置\n\n- 当前仓库的配置文档存放在`.git/config` 文件中；\n- 当前用户的配置文档存放在用户主目录下的隐藏文件`.gitignore` 中；\n- `git config --global alias. <short-command> <origin-command>` ，配置别名，简化使用。\n\n### Git服务器搭建\n\n服务器系统采用Linux，推荐Ubuntu或者Debian，以下操作需要sudo权限。\n\n1. 安装Git:\n\n   `sudo apt-get install git` \n\n2. 创建Git用户，用于运行Git服务：\n\n   `sudo adduser git` \n\n3.  添加公钥，保证用户的登录：\n\n   收集所有需要登录服务器的用户的公钥，即`id_rsa.pub` 文件的内容，将公钥添加进服务器的`/home/git/.ssh/authorized_keys` 文件中，一行一个。\n\n4. 初始化Git仓库：\n\n   选定一个目录作为Git仓库，例如`/git/git-server.git` ，在目录`/git` 下执行命令：\n\n   `sudo git init --bare git-server.git` \n\n   创建的是裸仓库，即没有工作区，服务器的目的是为了共享，而不允许用户登录到服务器上去修改，然后将Git仓库的所有者更改为之前添加的用户git：\n\n   `sudo chown -R git:git git-server.git` \n\n5. 禁用shell登录：\n\n   即禁止之前创建的用户git登录shell，可以通过编辑`/etc/passwd` 文件完成，将以下一行\n\n   `git:x:1001:1001:,,,:/home/git:/bin/bash` \n\n   改为\n\n   `git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell` \n\n   意思就是，用户`git` 每次一登录shell就会自动退出，即无法登录shell进行其他操作，这么做的目的是，让`git` 用户可以正常通过ssh使用git，但禁止其登录shell。\n\n6. 远程Git仓库已经建立好了，其他客户端用户可以使用`git clone` 将服务器上的内容克隆到本地进行修改：\n\n   `git clone git@server:/git/git-server.git` \n\n   修改完成之后，就是推送与共享了。","source":"_posts/git-study.md","raw":"title: Git Study\n\n---\n\n# Git Study\n### Git Introduction\n\nGit是一种开源的分布式版本管理系统。\n\n每台安装了Git的机器上都会维持一个Git的本地仓库。\n\n### 本地版本库的创建与管理\n\n#### 创建与文件提交\n\n- 初始化一个Git仓库：`git init`；\n- 添加文件到Git仓库（[背后的原理](#gitadd-principle)）:\n  1. `git add <file>` ，可以使用多次，添加多个文件；\n  2. `git commit -m \"提交说明文字\"` ，完成一次提交。\n\n#### 查看仓库状态\n\n- `git status` ，查看本地仓库的[工作区](#workplace)状态，命令会告诉我们，当前有哪些文件被修改了，现在的状态是”没有添加任何文件“OR”已添加待提交“，此外还会对后续操作提示相应的命令；\n- `git diff` ， 如果有文件被修改了，可以用该命令查看具体的修改内容（有\"-\"号的一行说明有删减，有“+”的一行说明有增加）。\n\n#### 版本回退与回退的撤销\n\n- `git log` ，查看提交的历史记录，以便确定回退到哪一个版本，精简输出可以使用`git log --pretty=oneline`；<span id=\"versionback\"></span>\n\n- `git reflog` ，查看命令的历史记录，可以用于确定版本回退之前的最新版本号`commit_id` ；\n\n- `git reset --hard <commit_id>` ，`commit_id` 是版本号，是SHA1计算得出的十六进制数字，每提交一次就会新生成一个`commit_id` ，版本号没有必要每次都输入完整，保证前几位不同就可以。此外，`HEAD` 表示当前版本号，`HEAD^` 表示上一个版本号，以此类推，`HEAD~100` 表示上100个版本号。\n\n  **注意** ：对于只有一个版本的版本库是无法再回退到上一个状态（即最初初始化的状态）\n\n#### 工作区与暂存区\n\n- <span id=\"workplace\">工作区（Working Directory）</span>\n\n  也就是当时使用`git init` 初始化的本地仓库的目录/文件夹。\n\n- 版本库（Repository）\n\n  工作区内的隐藏目录`.git` ，这个目录不算工作区，而是属于版本库。版本库中最重要的部分是暂存区（stage/index）这也是Git与SVN不同之处，同时还有Git自动创建的第一个[分支](#branch)`master` 和指向`master` 的[指针`HEAD`](#pointer-HEAD) 。\n\n- 工作区与暂存区的关系\n\n  这里通过`git add <file>` 的<span id=\"gitadd-principle\">工作原理</span>来解释一下工作区与暂存区之间的关系。\n\n  1. `git add` 添加的时候，实际上是将文件或者文件的修改添加到暂存区中；\n\n  2. `git commit` 提交文件或文件修改，实际上是将暂存区的所有内容提交到当前分支中。\n\n     **注意**：\n\n     - 提交之后，工作区就没有任何新的修改，暂存区也没有任何内容，同时产生了新的版本。\n\n     - 提交的时候，Git只负责将已经加入暂存区的修改内容提交到分支中，即若`git add` 之后再对文件进行修改，那么此时修改的内容是不会提交到分支中的。\n\n       `git diff HEAD -- <file>` ，可以用于查看工作区与版本库中最新版本之间的区别。\n\n#### 管理与修改、删除\n\nGit跟踪并管理的是**文件的修改部分** ,而非整个文件。\n\n所以，如果修改没有从工作区添加到暂存区，那么这些修改就无法被提交到版本库的最新版本中。\n\n- `git checkout -- <file>` ，直接放弃对工作区的所有修改，这比一行一行的恢复更省力气，有时候对于不知道修改了哪部分内容的情况也很有用。\n\n- `git rm --cached <file>` ，将添加到暂存区的修改撤销（unstage），并将修改重新放回工作区，如果此时仍想撤销所有的修改，则执行命令`git checkout -- <file>` ；\n\n- 如果已经向本地版本库提交了不合适的修改并想要撤销时，需要[版本回退](#versionback)操作，前提是还没有推送到远程仓库。\n\n- 若要删除一个文件，需要在工作区和版本库中同时删除该文件 `git rm <file>` ，并在删除完成后重新提交`git commit -m <file> ` 一次：\n\n- 若在工作区错删了文件，则可以借助版本库，将该文件恢复到最新一次提交的状态：`git checkout -- <file>` *（当然，如果回收站还没清空的话，也可以去回收站看看）*；\n\n- **注** ：`git checkout` 的原理是，利用版本库中的最新版本替换工作区的版本。\n\n\n### 远程仓库\n\n可以自己搭建Git服务器作为远程仓库，也可以使用Github的免费仓库（但是是公开的所有人可见的）。\n\n一台电脑上也可以建立多个版本库，只要不在同一目录中即可。\n\nGit支持SSH协议。\n\n#### 添加远程库与推送Push\n\n在完成Github注册和SSH Key添加之后，就可以在Github上创建一个新的Git仓库，然后根据相应的提示，将本地仓库的文件推送（Push）到远程仓库中。\n\n- `git remote add origin <仓库地址>` ，在本地仓库目录下执行，将本地仓库与远程仓库进行关联，同时为远程仓库定义了新的名字`origin` ，当然也可以使用别的名字；\n- `git push -u origin master` ，将本地仓库的内容推送到远成仓库，实际上是将当前分支`master` 的内容推送到远程仓库的`master` 分支，由于刚开始远程仓库是空的，所以第一次推送的时候，需要参数`-u` ，这样在推送的同时，还会建立起本地分支`master` 和远程仓库中`master` 分支的联系，以后推送和拉取内容就可以简化命令，即`git push origin master` 和\n\n#### 从远程库克隆Clone\n\n- `git clone https://github.com/zouguijin/docSync.git` \n\n- `git clone git@github.com:zouguijin/docSync.git` \n\n  Git支持多种协议，默认的git（所使用的是ssh协议），此外还可以使用https协议（但是https协议有时候比较慢，而且每次推送都需要输入口令，使用ssh就不需要输入口令，`get clone` 的时候都要口令...）。\n\n### 分支（Branch）\n\n创建属于自己的分支，其他人是看不到的，一个未完成的项目可以在分支上不断更新，直到完成之后再一次提交到`master` 主分支上。\n\n#### 创建与合并\n\n- 原理：\n\n  一个分支就是一条时间线，随着不断地提交逐渐变长。最初只有主分支即`master` 分支，同时有一个`master` 指针指向主分支的最新提交，之前说的指针`HEAD` 指向的是指针`master` ，而不是指向最新提交。即：\n\n  > `HEAD` -> `master` -> `最新提交` \n\n  每次提交之后，`master` 分支都会向前延长，同时指针`master` 都会指向最新的提交，指针`HEAD` 的指向不变。\n\n  创建新的分支，例如`branch` 时，即创建新的指针`branch` ，指向与`master` 相同的提交，此时若将指针`HEAD` 指向`branch` ，则表示切换当前分支，由主分支切换到`branch` 分支。\n\n  > `master` ->`最新提交` <- `branch` <- `HEAD`  \n\n  如果在`branch` 分支下提交新的修改，那么`branch` 分支就会向前延长，指针`branch` 指向最新提交，但此时指针`master` 保持切换前的指向位置不变。\n\n  合并分支，也就是将主分支的`master` 指针指向`branch` 指针所指向的最新提交即可，合并分支后，一般都会将工作时使用的新分支`branch` 删除，即删除`branch` 指针。\n\n  **注** ：可见，所谓创建分支，只是创建了一个指针，切换、合并分支，只是改变了指针的指向，删除分支，只是将对应的指针删除，所有的操作都不涉及内容的改变。\n\n- 命令操作\n\n  - `git branch` ，查看分支情况，当前分支前会用`*` 标记；\n  - `git branch <name>` ，创建分支；\n  - `git checkout <name>` ，切换分支，由当前分支切换到指定命名分支；\n  - `git checkout -b <name>` ，创建&切换分支；\n  - `git merge <name>` ，合并分支，将指定命名分支合并到当前分支上；（默认使用`Fast Forward` 模式，该模式下删除分支后，分支信息也随之删除，即看不到历史合并信息；若希望能看到历史合并信息，就需要禁用FF模式，并最好添加注释信息，即`git merge --no-ff -m \"注释信息\" <name>`）\n  - `git branch -d <name>` ，删除指定命名分支。\n\n- 合并冲突<span id=\"conflict-solve\"></span>\n\n  如果两个需要合并的分支各自都有新的提交，而且两者的提交在同一位置有不同的表述，在合并的时候就会出现冲突，即不能简单地删除、添加或者替换。\n\n  冲突出现的时候，在显示分支的括号中会多出`|MERGING` 字样，表示此时必须解决合并冲突，分支切换操作被禁止，这时需要利用`git diff` 查看文件内容，并手动修改冲突的内容，然后重新添加和提交即可。（Git会用`<<<<<<<`，`=======`，`>>>>>>>`标记出不同分支的内容）\n\n  `git log --graph` 可以看到分支的合并情况，或者简化版`git log --graph --pretty=oneline --abbrev-commit` 。\n\n- 分支管理策略\n\n  - 保证主分支`master` 是稳定的，仅仅用于发布公开的、可以使用的新版本；\n  - 如果团队合作的话，需要新建一个团队开发提交的分支，例如`dev` 分支，平时的提交与合并都在该分支上完成，一个完整的版本完成之后再将`dev` 分支合并到主分支上。\n\n#### Bug分支\n\n当遇到Bug的时候，可以切换到需要修复Bug的分支上，在该分支上创建临时的Bug分支，在临时分支上修复Bug，然后合并原分支上，最后删除临时分支即可。\n\n此时，如果手头上的工作没有做完（工作区有正在修改的内容，如果将Bug修复完成之后就添加、提交，那么之前正在处理但未处理完成的工作就会和修复的Bug一起添加并提交上去，这是我们不想看见的），那么这时候就需要将未完成的工作**先拿出工作区并暂存**起来：\n\n> `git stash` \n\n此时，利用`git status` 查看工作区，会看见工作区是干净的。\n\n完成Bug修复之后，可以再将之前的工作取出来放进工作区继续完成：\n\n- `git stash list` ，若有多个工作，可以先查看列表，再决定需要恢复哪个工作；\n- `git stash apply` ，恢复工作之后，暂存的内容并不会自动删除，需要使用`git stash drop` 将相应的内容删除；\n- `git stash pop` ，推荐使用，恢复工作的同时，可以将暂存的内容也删除；\n- 若要指定恢复或者删除哪一条`stash` ，可以添加后续命令`stash@{x}` ，`x` 可以从`stash` 列表中选取。\n\n#### Feature分支\n\n为项目开发一个新的功能时，最好在项目分支上新建一个分支，功能完成之后再将新功能的代码合并到项目分支中。\n\n如果在合并之前，需要放弃该功能分支，则需要通过强行删除的操作完成：\n\n> `git branch -D <name>`\n\n#### 推送与抓取\n\n- `git remote -v` ，查看远程库的信息，会给出本地可以抓取和推送的远程库的地址以及远程库的命名（默认是`origin`）；\n\n- `git push origin <name> ` ，推送分支，即将指定分支上的所有本地内容推送到远程仓库中的**相对应**的分支上，可以推送本地`master` 分支内容，也可以推送其他分支的内容；\n\n- `git clone <git/https>` ，其他用户从远程库克隆的时候，默认情况下只能看到`master` 分支（当然其他分支也随之克隆下来了，只是不稍微调整是看不到的），前面说了，一般不会直接向`master` 分支推送修改，所以需要在本地创建远程仓库`origin` 的分支`branch` （这里的`branch` 需要与远程仓库的`branch` 同名）：\n\n  > `git checkout -b branch origin/branch` \n\n  只有这样，才能建立本地与远成仓库的联系，之后的抓取`git pull` 和推送`git push origin branch ` 才可以进行。\n\n- `git pull` ，抓取分支，首先需要建立本地分支与远程仓库相应分支之间的链接：\n\n  > `git branch --set-upstream branch origin/branch` \n\n  在之前建立本地分支与远程库分支的基础上，可以将最新的提交从远程库相应的分支上抓取下来：\n\n  > `git pull` \n\n  如果`git pull` 的时候出现冲突，则需要[解决冲突](#conflict-solve) 。\n\n- 本地分支，若不推送到远程，只有本地可见。\n\n### 标签（Tag）\n\n版本发布的时候，为了今后方便查找，一般会使用标签的方式，采用有意义的文字标记当前版本，即可以将标签当作版本库的一个快照，本质上标签就是一个指向某一次`commit` 的指针，类似于分支指针（但是分支指针可以移动，标签指针不可以移动）。\n\n- `git tag` ，查看所有标签；\n- `git tag <name>` ，为当前分支生成一个标签，标签默认标记在最新的提交上；\n- `git tag <name> <commit_id>` ，若想为历史的某一次提交生成标签，则找到该提交的`commit_id` 即可；\n- `git tag -a <tagname> -m \"注释信息\" <commit_id>` ，创建标签并生成注释；\n- `git show <tagname>` ，查看相应的标签信息；\n\n**注** ：标签是按照字母顺序排序的，而不是按照时间排序。\n\n- `git tag -d <tagname>` ，删除本地标签；\n\n- `git push origin <tagname>` ，将标签推送到远程仓库中；\n\n- `git push origin --tags` ，一次性地将本地标签全部推送到远程库中；\n\n- 若想要删除的标签已经被推送到了远程库中，那么需要两步才能删除标签：\n\n  >`git tag -d <tagname>` #首先，本地删除\n  >\n  >`git push origin :refs/tags/<tagname>` #然后，远程删除库中的标签\n\n### Github\n\n如果要参与开源项目，首先将开源项目`Fork` 到自己的仓库中，然后**从自己的仓库中`Clone` **，只有这样才能在本地修改之后，再次推送到Github上，若希望开源项目的官方接受自己的修改，则需要在Github上发起`Pull Request` 。\n\n### .gitignore\n\n.gitignore文件中的文件名将会在提交的时候被忽略，.gitignore文件需要放在版本库中。\n\n.gitignore文件不需要从头开始编写，可以参照[官方文档](https://github.com/github/gitignore '.gitignore-doc')并进行相应的组合即可。\n\n- `git add -f <file>` ，有时候.gitignore文件中禁止提交的文件类型中，有你希望提交的一份文件，则可以通过上述命令强行添加并提交；\n- `git check-ignore -v <file>` ，当发现一个文件无法添加和提交时，需要检查.gitignore文件中哪一条规则写错了，可以使用上述命令进行检查。\n\n### Git配置\n\n- 当前仓库的配置文档存放在`.git/config` 文件中；\n- 当前用户的配置文档存放在用户主目录下的隐藏文件`.gitignore` 中；\n- `git config --global alias. <short-command> <origin-command>` ，配置别名，简化使用。\n\n### Git服务器搭建\n\n服务器系统采用Linux，推荐Ubuntu或者Debian，以下操作需要sudo权限。\n\n1. 安装Git:\n\n   `sudo apt-get install git` \n\n2. 创建Git用户，用于运行Git服务：\n\n   `sudo adduser git` \n\n3.  添加公钥，保证用户的登录：\n\n   收集所有需要登录服务器的用户的公钥，即`id_rsa.pub` 文件的内容，将公钥添加进服务器的`/home/git/.ssh/authorized_keys` 文件中，一行一个。\n\n4. 初始化Git仓库：\n\n   选定一个目录作为Git仓库，例如`/git/git-server.git` ，在目录`/git` 下执行命令：\n\n   `sudo git init --bare git-server.git` \n\n   创建的是裸仓库，即没有工作区，服务器的目的是为了共享，而不允许用户登录到服务器上去修改，然后将Git仓库的所有者更改为之前添加的用户git：\n\n   `sudo chown -R git:git git-server.git` \n\n5. 禁用shell登录：\n\n   即禁止之前创建的用户git登录shell，可以通过编辑`/etc/passwd` 文件完成，将以下一行\n\n   `git:x:1001:1001:,,,:/home/git:/bin/bash` \n\n   改为\n\n   `git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell` \n\n   意思就是，用户`git` 每次一登录shell就会自动退出，即无法登录shell进行其他操作，这么做的目的是，让`git` 用户可以正常通过ssh使用git，但禁止其登录shell。\n\n6. 远程Git仓库已经建立好了，其他客户端用户可以使用`git clone` 将服务器上的内容克隆到本地进行修改：\n\n   `git clone git@server:/git/git-server.git` \n\n   修改完成之后，就是推送与共享了。","slug":"git-study","published":1,"date":"2017-02-24T02:51:01.826Z","updated":"2017-02-24T01:08:41.678Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizj854z90002y8up2hx0h50t","content":"<h1 id=\"Git-Study\"><a href=\"#Git-Study\" class=\"headerlink\" title=\"Git Study\"></a>Git Study</h1><h3 id=\"Git-Introduction\"><a href=\"#Git-Introduction\" class=\"headerlink\" title=\"Git Introduction\"></a>Git Introduction</h3><p>Git是一种开源的分布式版本管理系统。</p>\n<p>每台安装了Git的机器上都会维持一个Git的本地仓库。</p>\n<h3 id=\"本地版本库的创建与管理\"><a href=\"#本地版本库的创建与管理\" class=\"headerlink\" title=\"本地版本库的创建与管理\"></a>本地版本库的创建与管理</h3><h4 id=\"创建与文件提交\"><a href=\"#创建与文件提交\" class=\"headerlink\" title=\"创建与文件提交\"></a>创建与文件提交</h4><ul>\n<li>初始化一个Git仓库：<code>git init</code>；</li>\n<li>添加文件到Git仓库（<a href=\"#gitadd-principle\">背后的原理</a>）:<ol>\n<li><code>git add &lt;file&gt;</code> ，可以使用多次，添加多个文件；</li>\n<li><code>git commit -m &quot;提交说明文字&quot;</code> ，完成一次提交。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"查看仓库状态\"><a href=\"#查看仓库状态\" class=\"headerlink\" title=\"查看仓库状态\"></a>查看仓库状态</h4><ul>\n<li><code>git status</code> ，查看本地仓库的<a href=\"#workplace\">工作区</a>状态，命令会告诉我们，当前有哪些文件被修改了，现在的状态是”没有添加任何文件“OR”已添加待提交“，此外还会对后续操作提示相应的命令；</li>\n<li><code>git diff</code> ， 如果有文件被修改了，可以用该命令查看具体的修改内容（有”-“号的一行说明有删减，有“+”的一行说明有增加）。</li>\n</ul>\n<h4 id=\"版本回退与回退的撤销\"><a href=\"#版本回退与回退的撤销\" class=\"headerlink\" title=\"版本回退与回退的撤销\"></a>版本回退与回退的撤销</h4><ul>\n<li><p><code>git log</code> ，查看提交的历史记录，以便确定回退到哪一个版本，精简输出可以使用<code>git log --pretty=oneline</code>；<span id=\"versionback\"></span></p>\n</li>\n<li><p><code>git reflog</code> ，查看命令的历史记录，可以用于确定版本回退之前的最新版本号<code>commit_id</code> ；</p>\n</li>\n<li><p><code>git reset --hard &lt;commit_id&gt;</code> ，<code>commit_id</code> 是版本号，是SHA1计算得出的十六进制数字，每提交一次就会新生成一个<code>commit_id</code> ，版本号没有必要每次都输入完整，保证前几位不同就可以。此外，<code>HEAD</code> 表示当前版本号，<code>HEAD^</code> 表示上一个版本号，以此类推，<code>HEAD~100</code> 表示上100个版本号。</p>\n<p><strong>注意</strong> ：对于只有一个版本的版本库是无法再回退到上一个状态（即最初初始化的状态）</p>\n</li>\n</ul>\n<h4 id=\"工作区与暂存区\"><a href=\"#工作区与暂存区\" class=\"headerlink\" title=\"工作区与暂存区\"></a>工作区与暂存区</h4><ul>\n<li><p><span id=\"workplace\">工作区（Working Directory）</span></p>\n<p>也就是当时使用<code>git init</code> 初始化的本地仓库的目录/文件夹。</p>\n</li>\n<li><p>版本库（Repository）</p>\n<p>工作区内的隐藏目录<code>.git</code> ，这个目录不算工作区，而是属于版本库。版本库中最重要的部分是暂存区（stage/index）这也是Git与SVN不同之处，同时还有Git自动创建的第一个<a href=\"#branch\">分支</a><code>master</code> 和指向<code>master</code> 的<a href=\"#pointer-HEAD\">指针<code>HEAD</code></a> 。</p>\n</li>\n<li><p>工作区与暂存区的关系</p>\n<p>这里通过<code>git add &lt;file&gt;</code> 的<span id=\"gitadd-principle\">工作原理</span>来解释一下工作区与暂存区之间的关系。</p>\n<ol>\n<li><p><code>git add</code> 添加的时候，实际上是将文件或者文件的修改添加到暂存区中；</p>\n</li>\n<li><p><code>git commit</code> 提交文件或文件修改，实际上是将暂存区的所有内容提交到当前分支中。</p>\n<p><strong>注意</strong>：</p>\n<ul>\n<li><p>提交之后，工作区就没有任何新的修改，暂存区也没有任何内容，同时产生了新的版本。</p>\n</li>\n<li><p>提交的时候，Git只负责将已经加入暂存区的修改内容提交到分支中，即若<code>git add</code> 之后再对文件进行修改，那么此时修改的内容是不会提交到分支中的。</p>\n<p><code>git diff HEAD -- &lt;file&gt;</code> ，可以用于查看工作区与版本库中最新版本之间的区别。</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"管理与修改、删除\"><a href=\"#管理与修改、删除\" class=\"headerlink\" title=\"管理与修改、删除\"></a>管理与修改、删除</h4><p>Git跟踪并管理的是<strong>文件的修改部分</strong> ,而非整个文件。</p>\n<p>所以，如果修改没有从工作区添加到暂存区，那么这些修改就无法被提交到版本库的最新版本中。</p>\n<ul>\n<li><p><code>git checkout -- &lt;file&gt;</code> ，直接放弃对工作区的所有修改，这比一行一行的恢复更省力气，有时候对于不知道修改了哪部分内容的情况也很有用。</p>\n</li>\n<li><p><code>git rm --cached &lt;file&gt;</code> ，将添加到暂存区的修改撤销（unstage），并将修改重新放回工作区，如果此时仍想撤销所有的修改，则执行命令<code>git checkout -- &lt;file&gt;</code> ；</p>\n</li>\n<li><p>如果已经向本地版本库提交了不合适的修改并想要撤销时，需要<a href=\"#versionback\">版本回退</a>操作，前提是还没有推送到远程仓库。</p>\n</li>\n<li><p>若要删除一个文件，需要在工作区和版本库中同时删除该文件 <code>git rm &lt;file&gt;</code> ，并在删除完成后重新提交<code>git commit -m &lt;file&gt;</code> 一次：</p>\n</li>\n<li><p>若在工作区错删了文件，则可以借助版本库，将该文件恢复到最新一次提交的状态：<code>git checkout -- &lt;file&gt;</code> <em>（当然，如果回收站还没清空的话，也可以去回收站看看）</em>；</p>\n</li>\n<li><p><strong>注</strong> ：<code>git checkout</code> 的原理是，利用版本库中的最新版本替换工作区的版本。</p>\n</li>\n</ul>\n<h3 id=\"远程仓库\"><a href=\"#远程仓库\" class=\"headerlink\" title=\"远程仓库\"></a>远程仓库</h3><p>可以自己搭建Git服务器作为远程仓库，也可以使用Github的免费仓库（但是是公开的所有人可见的）。</p>\n<p>一台电脑上也可以建立多个版本库，只要不在同一目录中即可。</p>\n<p>Git支持SSH协议。</p>\n<h4 id=\"添加远程库与推送Push\"><a href=\"#添加远程库与推送Push\" class=\"headerlink\" title=\"添加远程库与推送Push\"></a>添加远程库与推送Push</h4><p>在完成Github注册和SSH Key添加之后，就可以在Github上创建一个新的Git仓库，然后根据相应的提示，将本地仓库的文件推送（Push）到远程仓库中。</p>\n<ul>\n<li><code>git remote add origin &lt;仓库地址&gt;</code> ，在本地仓库目录下执行，将本地仓库与远程仓库进行关联，同时为远程仓库定义了新的名字<code>origin</code> ，当然也可以使用别的名字；</li>\n<li><code>git push -u origin master</code> ，将本地仓库的内容推送到远成仓库，实际上是将当前分支<code>master</code> 的内容推送到远程仓库的<code>master</code> 分支，由于刚开始远程仓库是空的，所以第一次推送的时候，需要参数<code>-u</code> ，这样在推送的同时，还会建立起本地分支<code>master</code> 和远程仓库中<code>master</code> 分支的联系，以后推送和拉取内容就可以简化命令，即<code>git push origin master</code> 和</li>\n</ul>\n<h4 id=\"从远程库克隆Clone\"><a href=\"#从远程库克隆Clone\" class=\"headerlink\" title=\"从远程库克隆Clone\"></a>从远程库克隆Clone</h4><ul>\n<li><p><code>git clone https://github.com/zouguijin/docSync.git</code> </p>\n</li>\n<li><p><code>git clone git@github.com:zouguijin/docSync.git</code> </p>\n<p>Git支持多种协议，默认的git（所使用的是ssh协议），此外还可以使用https协议（但是https协议有时候比较慢，而且每次推送都需要输入口令，使用ssh就不需要输入口令，<code>get clone</code> 的时候都要口令…）。</p>\n</li>\n</ul>\n<h3 id=\"分支（Branch）\"><a href=\"#分支（Branch）\" class=\"headerlink\" title=\"分支（Branch）\"></a>分支（Branch）</h3><p>创建属于自己的分支，其他人是看不到的，一个未完成的项目可以在分支上不断更新，直到完成之后再一次提交到<code>master</code> 主分支上。</p>\n<h4 id=\"创建与合并\"><a href=\"#创建与合并\" class=\"headerlink\" title=\"创建与合并\"></a>创建与合并</h4><ul>\n<li><p>原理：</p>\n<p>一个分支就是一条时间线，随着不断地提交逐渐变长。最初只有主分支即<code>master</code> 分支，同时有一个<code>master</code> 指针指向主分支的最新提交，之前说的指针<code>HEAD</code> 指向的是指针<code>master</code> ，而不是指向最新提交。即：</p>\n<blockquote>\n<p><code>HEAD</code> -&gt; <code>master</code> -&gt; <code>最新提交</code> </p>\n</blockquote>\n<p>每次提交之后，<code>master</code> 分支都会向前延长，同时指针<code>master</code> 都会指向最新的提交，指针<code>HEAD</code> 的指向不变。</p>\n<p>创建新的分支，例如<code>branch</code> 时，即创建新的指针<code>branch</code> ，指向与<code>master</code> 相同的提交，此时若将指针<code>HEAD</code> 指向<code>branch</code> ，则表示切换当前分支，由主分支切换到<code>branch</code> 分支。</p>\n<blockquote>\n<p><code>master</code> -&gt;<code>最新提交</code> &lt;- <code>branch</code> &lt;- <code>HEAD</code>  </p>\n</blockquote>\n<p>如果在<code>branch</code> 分支下提交新的修改，那么<code>branch</code> 分支就会向前延长，指针<code>branch</code> 指向最新提交，但此时指针<code>master</code> 保持切换前的指向位置不变。</p>\n<p>合并分支，也就是将主分支的<code>master</code> 指针指向<code>branch</code> 指针所指向的最新提交即可，合并分支后，一般都会将工作时使用的新分支<code>branch</code> 删除，即删除<code>branch</code> 指针。</p>\n<p><strong>注</strong> ：可见，所谓创建分支，只是创建了一个指针，切换、合并分支，只是改变了指针的指向，删除分支，只是将对应的指针删除，所有的操作都不涉及内容的改变。</p>\n</li>\n<li><p>命令操作</p>\n<ul>\n<li><code>git branch</code> ，查看分支情况，当前分支前会用<code>*</code> 标记；</li>\n<li><code>git branch &lt;name&gt;</code> ，创建分支；</li>\n<li><code>git checkout &lt;name&gt;</code> ，切换分支，由当前分支切换到指定命名分支；</li>\n<li><code>git checkout -b &lt;name&gt;</code> ，创建&amp;切换分支；</li>\n<li><code>git merge &lt;name&gt;</code> ，合并分支，将指定命名分支合并到当前分支上；（默认使用<code>Fast Forward</code> 模式，该模式下删除分支后，分支信息也随之删除，即看不到历史合并信息；若希望能看到历史合并信息，就需要禁用FF模式，并最好添加注释信息，即<code>git merge --no-ff -m &quot;注释信息&quot; &lt;name&gt;</code>）</li>\n<li><code>git branch -d &lt;name&gt;</code> ，删除指定命名分支。</li>\n</ul>\n</li>\n<li><p>合并冲突<span id=\"conflict-solve\"></span></p>\n<p>如果两个需要合并的分支各自都有新的提交，而且两者的提交在同一位置有不同的表述，在合并的时候就会出现冲突，即不能简单地删除、添加或者替换。</p>\n<p>冲突出现的时候，在显示分支的括号中会多出<code>|MERGING</code> 字样，表示此时必须解决合并冲突，分支切换操作被禁止，这时需要利用<code>git diff</code> 查看文件内容，并手动修改冲突的内容，然后重新添加和提交即可。（Git会用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容）</p>\n<p><code>git log --graph</code> 可以看到分支的合并情况，或者简化版<code>git log --graph --pretty=oneline --abbrev-commit</code> 。</p>\n</li>\n<li><p>分支管理策略</p>\n<ul>\n<li>保证主分支<code>master</code> 是稳定的，仅仅用于发布公开的、可以使用的新版本；</li>\n<li>如果团队合作的话，需要新建一个团队开发提交的分支，例如<code>dev</code> 分支，平时的提交与合并都在该分支上完成，一个完整的版本完成之后再将<code>dev</code> 分支合并到主分支上。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Bug分支\"><a href=\"#Bug分支\" class=\"headerlink\" title=\"Bug分支\"></a>Bug分支</h4><p>当遇到Bug的时候，可以切换到需要修复Bug的分支上，在该分支上创建临时的Bug分支，在临时分支上修复Bug，然后合并原分支上，最后删除临时分支即可。</p>\n<p>此时，如果手头上的工作没有做完（工作区有正在修改的内容，如果将Bug修复完成之后就添加、提交，那么之前正在处理但未处理完成的工作就会和修复的Bug一起添加并提交上去，这是我们不想看见的），那么这时候就需要将未完成的工作<strong>先拿出工作区并暂存</strong>起来：</p>\n<blockquote>\n<p><code>git stash</code> </p>\n</blockquote>\n<p>此时，利用<code>git status</code> 查看工作区，会看见工作区是干净的。</p>\n<p>完成Bug修复之后，可以再将之前的工作取出来放进工作区继续完成：</p>\n<ul>\n<li><code>git stash list</code> ，若有多个工作，可以先查看列表，再决定需要恢复哪个工作；</li>\n<li><code>git stash apply</code> ，恢复工作之后，暂存的内容并不会自动删除，需要使用<code>git stash drop</code> 将相应的内容删除；</li>\n<li><code>git stash pop</code> ，推荐使用，恢复工作的同时，可以将暂存的内容也删除；</li>\n<li>若要指定恢复或者删除哪一条<code>stash</code> ，可以添加后续命令<code>stash@{x}</code> ，<code>x</code> 可以从<code>stash</code> 列表中选取。</li>\n</ul>\n<h4 id=\"Feature分支\"><a href=\"#Feature分支\" class=\"headerlink\" title=\"Feature分支\"></a>Feature分支</h4><p>为项目开发一个新的功能时，最好在项目分支上新建一个分支，功能完成之后再将新功能的代码合并到项目分支中。</p>\n<p>如果在合并之前，需要放弃该功能分支，则需要通过强行删除的操作完成：</p>\n<blockquote>\n<p><code>git branch -D &lt;name&gt;</code></p>\n</blockquote>\n<h4 id=\"推送与抓取\"><a href=\"#推送与抓取\" class=\"headerlink\" title=\"推送与抓取\"></a>推送与抓取</h4><ul>\n<li><p><code>git remote -v</code> ，查看远程库的信息，会给出本地可以抓取和推送的远程库的地址以及远程库的命名（默认是<code>origin</code>）；</p>\n</li>\n<li><p><code>git push origin &lt;name&gt;</code> ，推送分支，即将指定分支上的所有本地内容推送到远程仓库中的<strong>相对应</strong>的分支上，可以推送本地<code>master</code> 分支内容，也可以推送其他分支的内容；</p>\n</li>\n<li><p><code>git clone &lt;git/https&gt;</code> ，其他用户从远程库克隆的时候，默认情况下只能看到<code>master</code> 分支（当然其他分支也随之克隆下来了，只是不稍微调整是看不到的），前面说了，一般不会直接向<code>master</code> 分支推送修改，所以需要在本地创建远程仓库<code>origin</code> 的分支<code>branch</code> （这里的<code>branch</code> 需要与远程仓库的<code>branch</code> 同名）：</p>\n<blockquote>\n<p><code>git checkout -b branch origin/branch</code> </p>\n</blockquote>\n<p>只有这样，才能建立本地与远成仓库的联系，之后的抓取<code>git pull</code> 和推送<code>git push origin branch</code> 才可以进行。</p>\n</li>\n<li><p><code>git pull</code> ，抓取分支，首先需要建立本地分支与远程仓库相应分支之间的链接：</p>\n<blockquote>\n<p><code>git branch --set-upstream branch origin/branch</code> </p>\n</blockquote>\n<p>在之前建立本地分支与远程库分支的基础上，可以将最新的提交从远程库相应的分支上抓取下来：</p>\n<blockquote>\n<p><code>git pull</code> </p>\n</blockquote>\n<p>如果<code>git pull</code> 的时候出现冲突，则需要<a href=\"#conflict-solve\">解决冲突</a> 。</p>\n</li>\n<li><p>本地分支，若不推送到远程，只有本地可见。</p>\n</li>\n</ul>\n<h3 id=\"标签（Tag）\"><a href=\"#标签（Tag）\" class=\"headerlink\" title=\"标签（Tag）\"></a>标签（Tag）</h3><p>版本发布的时候，为了今后方便查找，一般会使用标签的方式，采用有意义的文字标记当前版本，即可以将标签当作版本库的一个快照，本质上标签就是一个指向某一次<code>commit</code> 的指针，类似于分支指针（但是分支指针可以移动，标签指针不可以移动）。</p>\n<ul>\n<li><code>git tag</code> ，查看所有标签；</li>\n<li><code>git tag &lt;name&gt;</code> ，为当前分支生成一个标签，标签默认标记在最新的提交上；</li>\n<li><code>git tag &lt;name&gt; &lt;commit_id&gt;</code> ，若想为历史的某一次提交生成标签，则找到该提交的<code>commit_id</code> 即可；</li>\n<li><code>git tag -a &lt;tagname&gt; -m &quot;注释信息&quot; &lt;commit_id&gt;</code> ，创建标签并生成注释；</li>\n<li><code>git show &lt;tagname&gt;</code> ，查看相应的标签信息；</li>\n</ul>\n<p><strong>注</strong> ：标签是按照字母顺序排序的，而不是按照时间排序。</p>\n<ul>\n<li><p><code>git tag -d &lt;tagname&gt;</code> ，删除本地标签；</p>\n</li>\n<li><p><code>git push origin &lt;tagname&gt;</code> ，将标签推送到远程仓库中；</p>\n</li>\n<li><p><code>git push origin --tags</code> ，一次性地将本地标签全部推送到远程库中；</p>\n</li>\n<li><p>若想要删除的标签已经被推送到了远程库中，那么需要两步才能删除标签：</p>\n<blockquote>\n<p><code>git tag -d &lt;tagname&gt;</code> #首先，本地删除</p>\n<p><code>git push origin :refs/tags/&lt;tagname&gt;</code> #然后，远程删除库中的标签</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"Github\"><a href=\"#Github\" class=\"headerlink\" title=\"Github\"></a>Github</h3><p>如果要参与开源项目，首先将开源项目<code>Fork</code> 到自己的仓库中，然后<strong>从自己的仓库中<code>Clone</code> </strong>，只有这样才能在本地修改之后，再次推送到Github上，若希望开源项目的官方接受自己的修改，则需要在Github上发起<code>Pull Request</code> 。</p>\n<h3 id=\"gitignore\"><a href=\"#gitignore\" class=\"headerlink\" title=\".gitignore\"></a>.gitignore</h3><p>.gitignore文件中的文件名将会在提交的时候被忽略，.gitignore文件需要放在版本库中。</p>\n<p>.gitignore文件不需要从头开始编写，可以参照<a href=\"https://github.com/github/gitignore\" title=\".gitignore-doc\" target=\"_blank\" rel=\"external\">官方文档</a>并进行相应的组合即可。</p>\n<ul>\n<li><code>git add -f &lt;file&gt;</code> ，有时候.gitignore文件中禁止提交的文件类型中，有你希望提交的一份文件，则可以通过上述命令强行添加并提交；</li>\n<li><code>git check-ignore -v &lt;file&gt;</code> ，当发现一个文件无法添加和提交时，需要检查.gitignore文件中哪一条规则写错了，可以使用上述命令进行检查。</li>\n</ul>\n<h3 id=\"Git配置\"><a href=\"#Git配置\" class=\"headerlink\" title=\"Git配置\"></a>Git配置</h3><ul>\n<li>当前仓库的配置文档存放在<code>.git/config</code> 文件中；</li>\n<li>当前用户的配置文档存放在用户主目录下的隐藏文件<code>.gitignore</code> 中；</li>\n<li><code>git config --global alias. &lt;short-command&gt; &lt;origin-command&gt;</code> ，配置别名，简化使用。</li>\n</ul>\n<h3 id=\"Git服务器搭建\"><a href=\"#Git服务器搭建\" class=\"headerlink\" title=\"Git服务器搭建\"></a>Git服务器搭建</h3><p>服务器系统采用Linux，推荐Ubuntu或者Debian，以下操作需要sudo权限。</p>\n<ol>\n<li><p>安装Git:</p>\n<p><code>sudo apt-get install git</code> </p>\n</li>\n<li><p>创建Git用户，用于运行Git服务：</p>\n<p><code>sudo adduser git</code> </p>\n</li>\n<li><p>添加公钥，保证用户的登录：</p>\n<p>收集所有需要登录服务器的用户的公钥，即<code>id_rsa.pub</code> 文件的内容，将公钥添加进服务器的<code>/home/git/.ssh/authorized_keys</code> 文件中，一行一个。</p>\n</li>\n<li><p>初始化Git仓库：</p>\n<p>选定一个目录作为Git仓库，例如<code>/git/git-server.git</code> ，在目录<code>/git</code> 下执行命令：</p>\n<p><code>sudo git init --bare git-server.git</code> </p>\n<p>创建的是裸仓库，即没有工作区，服务器的目的是为了共享，而不允许用户登录到服务器上去修改，然后将Git仓库的所有者更改为之前添加的用户git：</p>\n<p><code>sudo chown -R git:git git-server.git</code> </p>\n</li>\n<li><p>禁用shell登录：</p>\n<p>即禁止之前创建的用户git登录shell，可以通过编辑<code>/etc/passwd</code> 文件完成，将以下一行</p>\n<p><code>git:x:1001:1001:,,,:/home/git:/bin/bash</code> </p>\n<p>改为</p>\n<p><code>git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</code> </p>\n<p>意思就是，用户<code>git</code> 每次一登录shell就会自动退出，即无法登录shell进行其他操作，这么做的目的是，让<code>git</code> 用户可以正常通过ssh使用git，但禁止其登录shell。</p>\n</li>\n<li><p>远程Git仓库已经建立好了，其他客户端用户可以使用<code>git clone</code> 将服务器上的内容克隆到本地进行修改：</p>\n<p><code>git clone git@server:/git/git-server.git</code> </p>\n<p>修改完成之后，就是推送与共享了。</p>\n</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"Git-Study\"><a href=\"#Git-Study\" class=\"headerlink\" title=\"Git Study\"></a>Git Study</h1><h3 id=\"Git-Introduction\"><a href=\"#Git-Introduction\" class=\"headerlink\" title=\"Git Introduction\"></a>Git Introduction</h3><p>Git是一种开源的分布式版本管理系统。</p>\n<p>每台安装了Git的机器上都会维持一个Git的本地仓库。</p>\n<h3 id=\"本地版本库的创建与管理\"><a href=\"#本地版本库的创建与管理\" class=\"headerlink\" title=\"本地版本库的创建与管理\"></a>本地版本库的创建与管理</h3><h4 id=\"创建与文件提交\"><a href=\"#创建与文件提交\" class=\"headerlink\" title=\"创建与文件提交\"></a>创建与文件提交</h4><ul>\n<li>初始化一个Git仓库：<code>git init</code>；</li>\n<li>添加文件到Git仓库（<a href=\"#gitadd-principle\">背后的原理</a>）:<ol>\n<li><code>git add &lt;file&gt;</code> ，可以使用多次，添加多个文件；</li>\n<li><code>git commit -m &quot;提交说明文字&quot;</code> ，完成一次提交。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"查看仓库状态\"><a href=\"#查看仓库状态\" class=\"headerlink\" title=\"查看仓库状态\"></a>查看仓库状态</h4><ul>\n<li><code>git status</code> ，查看本地仓库的<a href=\"#workplace\">工作区</a>状态，命令会告诉我们，当前有哪些文件被修改了，现在的状态是”没有添加任何文件“OR”已添加待提交“，此外还会对后续操作提示相应的命令；</li>\n<li><code>git diff</code> ， 如果有文件被修改了，可以用该命令查看具体的修改内容（有”-“号的一行说明有删减，有“+”的一行说明有增加）。</li>\n</ul>\n<h4 id=\"版本回退与回退的撤销\"><a href=\"#版本回退与回退的撤销\" class=\"headerlink\" title=\"版本回退与回退的撤销\"></a>版本回退与回退的撤销</h4><ul>\n<li><p><code>git log</code> ，查看提交的历史记录，以便确定回退到哪一个版本，精简输出可以使用<code>git log --pretty=oneline</code>；<span id=\"versionback\"></span></p>\n</li>\n<li><p><code>git reflog</code> ，查看命令的历史记录，可以用于确定版本回退之前的最新版本号<code>commit_id</code> ；</p>\n</li>\n<li><p><code>git reset --hard &lt;commit_id&gt;</code> ，<code>commit_id</code> 是版本号，是SHA1计算得出的十六进制数字，每提交一次就会新生成一个<code>commit_id</code> ，版本号没有必要每次都输入完整，保证前几位不同就可以。此外，<code>HEAD</code> 表示当前版本号，<code>HEAD^</code> 表示上一个版本号，以此类推，<code>HEAD~100</code> 表示上100个版本号。</p>\n<p><strong>注意</strong> ：对于只有一个版本的版本库是无法再回退到上一个状态（即最初初始化的状态）</p>\n</li>\n</ul>\n<h4 id=\"工作区与暂存区\"><a href=\"#工作区与暂存区\" class=\"headerlink\" title=\"工作区与暂存区\"></a>工作区与暂存区</h4><ul>\n<li><p><span id=\"workplace\">工作区（Working Directory）</span></p>\n<p>也就是当时使用<code>git init</code> 初始化的本地仓库的目录/文件夹。</p>\n</li>\n<li><p>版本库（Repository）</p>\n<p>工作区内的隐藏目录<code>.git</code> ，这个目录不算工作区，而是属于版本库。版本库中最重要的部分是暂存区（stage/index）这也是Git与SVN不同之处，同时还有Git自动创建的第一个<a href=\"#branch\">分支</a><code>master</code> 和指向<code>master</code> 的<a href=\"#pointer-HEAD\">指针<code>HEAD</code></a> 。</p>\n</li>\n<li><p>工作区与暂存区的关系</p>\n<p>这里通过<code>git add &lt;file&gt;</code> 的<span id=\"gitadd-principle\">工作原理</span>来解释一下工作区与暂存区之间的关系。</p>\n<ol>\n<li><p><code>git add</code> 添加的时候，实际上是将文件或者文件的修改添加到暂存区中；</p>\n</li>\n<li><p><code>git commit</code> 提交文件或文件修改，实际上是将暂存区的所有内容提交到当前分支中。</p>\n<p><strong>注意</strong>：</p>\n<ul>\n<li><p>提交之后，工作区就没有任何新的修改，暂存区也没有任何内容，同时产生了新的版本。</p>\n</li>\n<li><p>提交的时候，Git只负责将已经加入暂存区的修改内容提交到分支中，即若<code>git add</code> 之后再对文件进行修改，那么此时修改的内容是不会提交到分支中的。</p>\n<p><code>git diff HEAD -- &lt;file&gt;</code> ，可以用于查看工作区与版本库中最新版本之间的区别。</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"管理与修改、删除\"><a href=\"#管理与修改、删除\" class=\"headerlink\" title=\"管理与修改、删除\"></a>管理与修改、删除</h4><p>Git跟踪并管理的是<strong>文件的修改部分</strong> ,而非整个文件。</p>\n<p>所以，如果修改没有从工作区添加到暂存区，那么这些修改就无法被提交到版本库的最新版本中。</p>\n<ul>\n<li><p><code>git checkout -- &lt;file&gt;</code> ，直接放弃对工作区的所有修改，这比一行一行的恢复更省力气，有时候对于不知道修改了哪部分内容的情况也很有用。</p>\n</li>\n<li><p><code>git rm --cached &lt;file&gt;</code> ，将添加到暂存区的修改撤销（unstage），并将修改重新放回工作区，如果此时仍想撤销所有的修改，则执行命令<code>git checkout -- &lt;file&gt;</code> ；</p>\n</li>\n<li><p>如果已经向本地版本库提交了不合适的修改并想要撤销时，需要<a href=\"#versionback\">版本回退</a>操作，前提是还没有推送到远程仓库。</p>\n</li>\n<li><p>若要删除一个文件，需要在工作区和版本库中同时删除该文件 <code>git rm &lt;file&gt;</code> ，并在删除完成后重新提交<code>git commit -m &lt;file&gt;</code> 一次：</p>\n</li>\n<li><p>若在工作区错删了文件，则可以借助版本库，将该文件恢复到最新一次提交的状态：<code>git checkout -- &lt;file&gt;</code> <em>（当然，如果回收站还没清空的话，也可以去回收站看看）</em>；</p>\n</li>\n<li><p><strong>注</strong> ：<code>git checkout</code> 的原理是，利用版本库中的最新版本替换工作区的版本。</p>\n</li>\n</ul>\n<h3 id=\"远程仓库\"><a href=\"#远程仓库\" class=\"headerlink\" title=\"远程仓库\"></a>远程仓库</h3><p>可以自己搭建Git服务器作为远程仓库，也可以使用Github的免费仓库（但是是公开的所有人可见的）。</p>\n<p>一台电脑上也可以建立多个版本库，只要不在同一目录中即可。</p>\n<p>Git支持SSH协议。</p>\n<h4 id=\"添加远程库与推送Push\"><a href=\"#添加远程库与推送Push\" class=\"headerlink\" title=\"添加远程库与推送Push\"></a>添加远程库与推送Push</h4><p>在完成Github注册和SSH Key添加之后，就可以在Github上创建一个新的Git仓库，然后根据相应的提示，将本地仓库的文件推送（Push）到远程仓库中。</p>\n<ul>\n<li><code>git remote add origin &lt;仓库地址&gt;</code> ，在本地仓库目录下执行，将本地仓库与远程仓库进行关联，同时为远程仓库定义了新的名字<code>origin</code> ，当然也可以使用别的名字；</li>\n<li><code>git push -u origin master</code> ，将本地仓库的内容推送到远成仓库，实际上是将当前分支<code>master</code> 的内容推送到远程仓库的<code>master</code> 分支，由于刚开始远程仓库是空的，所以第一次推送的时候，需要参数<code>-u</code> ，这样在推送的同时，还会建立起本地分支<code>master</code> 和远程仓库中<code>master</code> 分支的联系，以后推送和拉取内容就可以简化命令，即<code>git push origin master</code> 和</li>\n</ul>\n<h4 id=\"从远程库克隆Clone\"><a href=\"#从远程库克隆Clone\" class=\"headerlink\" title=\"从远程库克隆Clone\"></a>从远程库克隆Clone</h4><ul>\n<li><p><code>git clone https://github.com/zouguijin/docSync.git</code> </p>\n</li>\n<li><p><code>git clone git@github.com:zouguijin/docSync.git</code> </p>\n<p>Git支持多种协议，默认的git（所使用的是ssh协议），此外还可以使用https协议（但是https协议有时候比较慢，而且每次推送都需要输入口令，使用ssh就不需要输入口令，<code>get clone</code> 的时候都要口令…）。</p>\n</li>\n</ul>\n<h3 id=\"分支（Branch）\"><a href=\"#分支（Branch）\" class=\"headerlink\" title=\"分支（Branch）\"></a>分支（Branch）</h3><p>创建属于自己的分支，其他人是看不到的，一个未完成的项目可以在分支上不断更新，直到完成之后再一次提交到<code>master</code> 主分支上。</p>\n<h4 id=\"创建与合并\"><a href=\"#创建与合并\" class=\"headerlink\" title=\"创建与合并\"></a>创建与合并</h4><ul>\n<li><p>原理：</p>\n<p>一个分支就是一条时间线，随着不断地提交逐渐变长。最初只有主分支即<code>master</code> 分支，同时有一个<code>master</code> 指针指向主分支的最新提交，之前说的指针<code>HEAD</code> 指向的是指针<code>master</code> ，而不是指向最新提交。即：</p>\n<blockquote>\n<p><code>HEAD</code> -&gt; <code>master</code> -&gt; <code>最新提交</code> </p>\n</blockquote>\n<p>每次提交之后，<code>master</code> 分支都会向前延长，同时指针<code>master</code> 都会指向最新的提交，指针<code>HEAD</code> 的指向不变。</p>\n<p>创建新的分支，例如<code>branch</code> 时，即创建新的指针<code>branch</code> ，指向与<code>master</code> 相同的提交，此时若将指针<code>HEAD</code> 指向<code>branch</code> ，则表示切换当前分支，由主分支切换到<code>branch</code> 分支。</p>\n<blockquote>\n<p><code>master</code> -&gt;<code>最新提交</code> &lt;- <code>branch</code> &lt;- <code>HEAD</code>  </p>\n</blockquote>\n<p>如果在<code>branch</code> 分支下提交新的修改，那么<code>branch</code> 分支就会向前延长，指针<code>branch</code> 指向最新提交，但此时指针<code>master</code> 保持切换前的指向位置不变。</p>\n<p>合并分支，也就是将主分支的<code>master</code> 指针指向<code>branch</code> 指针所指向的最新提交即可，合并分支后，一般都会将工作时使用的新分支<code>branch</code> 删除，即删除<code>branch</code> 指针。</p>\n<p><strong>注</strong> ：可见，所谓创建分支，只是创建了一个指针，切换、合并分支，只是改变了指针的指向，删除分支，只是将对应的指针删除，所有的操作都不涉及内容的改变。</p>\n</li>\n<li><p>命令操作</p>\n<ul>\n<li><code>git branch</code> ，查看分支情况，当前分支前会用<code>*</code> 标记；</li>\n<li><code>git branch &lt;name&gt;</code> ，创建分支；</li>\n<li><code>git checkout &lt;name&gt;</code> ，切换分支，由当前分支切换到指定命名分支；</li>\n<li><code>git checkout -b &lt;name&gt;</code> ，创建&amp;切换分支；</li>\n<li><code>git merge &lt;name&gt;</code> ，合并分支，将指定命名分支合并到当前分支上；（默认使用<code>Fast Forward</code> 模式，该模式下删除分支后，分支信息也随之删除，即看不到历史合并信息；若希望能看到历史合并信息，就需要禁用FF模式，并最好添加注释信息，即<code>git merge --no-ff -m &quot;注释信息&quot; &lt;name&gt;</code>）</li>\n<li><code>git branch -d &lt;name&gt;</code> ，删除指定命名分支。</li>\n</ul>\n</li>\n<li><p>合并冲突<span id=\"conflict-solve\"></span></p>\n<p>如果两个需要合并的分支各自都有新的提交，而且两者的提交在同一位置有不同的表述，在合并的时候就会出现冲突，即不能简单地删除、添加或者替换。</p>\n<p>冲突出现的时候，在显示分支的括号中会多出<code>|MERGING</code> 字样，表示此时必须解决合并冲突，分支切换操作被禁止，这时需要利用<code>git diff</code> 查看文件内容，并手动修改冲突的内容，然后重新添加和提交即可。（Git会用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容）</p>\n<p><code>git log --graph</code> 可以看到分支的合并情况，或者简化版<code>git log --graph --pretty=oneline --abbrev-commit</code> 。</p>\n</li>\n<li><p>分支管理策略</p>\n<ul>\n<li>保证主分支<code>master</code> 是稳定的，仅仅用于发布公开的、可以使用的新版本；</li>\n<li>如果团队合作的话，需要新建一个团队开发提交的分支，例如<code>dev</code> 分支，平时的提交与合并都在该分支上完成，一个完整的版本完成之后再将<code>dev</code> 分支合并到主分支上。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Bug分支\"><a href=\"#Bug分支\" class=\"headerlink\" title=\"Bug分支\"></a>Bug分支</h4><p>当遇到Bug的时候，可以切换到需要修复Bug的分支上，在该分支上创建临时的Bug分支，在临时分支上修复Bug，然后合并原分支上，最后删除临时分支即可。</p>\n<p>此时，如果手头上的工作没有做完（工作区有正在修改的内容，如果将Bug修复完成之后就添加、提交，那么之前正在处理但未处理完成的工作就会和修复的Bug一起添加并提交上去，这是我们不想看见的），那么这时候就需要将未完成的工作<strong>先拿出工作区并暂存</strong>起来：</p>\n<blockquote>\n<p><code>git stash</code> </p>\n</blockquote>\n<p>此时，利用<code>git status</code> 查看工作区，会看见工作区是干净的。</p>\n<p>完成Bug修复之后，可以再将之前的工作取出来放进工作区继续完成：</p>\n<ul>\n<li><code>git stash list</code> ，若有多个工作，可以先查看列表，再决定需要恢复哪个工作；</li>\n<li><code>git stash apply</code> ，恢复工作之后，暂存的内容并不会自动删除，需要使用<code>git stash drop</code> 将相应的内容删除；</li>\n<li><code>git stash pop</code> ，推荐使用，恢复工作的同时，可以将暂存的内容也删除；</li>\n<li>若要指定恢复或者删除哪一条<code>stash</code> ，可以添加后续命令<code>stash@{x}</code> ，<code>x</code> 可以从<code>stash</code> 列表中选取。</li>\n</ul>\n<h4 id=\"Feature分支\"><a href=\"#Feature分支\" class=\"headerlink\" title=\"Feature分支\"></a>Feature分支</h4><p>为项目开发一个新的功能时，最好在项目分支上新建一个分支，功能完成之后再将新功能的代码合并到项目分支中。</p>\n<p>如果在合并之前，需要放弃该功能分支，则需要通过强行删除的操作完成：</p>\n<blockquote>\n<p><code>git branch -D &lt;name&gt;</code></p>\n</blockquote>\n<h4 id=\"推送与抓取\"><a href=\"#推送与抓取\" class=\"headerlink\" title=\"推送与抓取\"></a>推送与抓取</h4><ul>\n<li><p><code>git remote -v</code> ，查看远程库的信息，会给出本地可以抓取和推送的远程库的地址以及远程库的命名（默认是<code>origin</code>）；</p>\n</li>\n<li><p><code>git push origin &lt;name&gt;</code> ，推送分支，即将指定分支上的所有本地内容推送到远程仓库中的<strong>相对应</strong>的分支上，可以推送本地<code>master</code> 分支内容，也可以推送其他分支的内容；</p>\n</li>\n<li><p><code>git clone &lt;git/https&gt;</code> ，其他用户从远程库克隆的时候，默认情况下只能看到<code>master</code> 分支（当然其他分支也随之克隆下来了，只是不稍微调整是看不到的），前面说了，一般不会直接向<code>master</code> 分支推送修改，所以需要在本地创建远程仓库<code>origin</code> 的分支<code>branch</code> （这里的<code>branch</code> 需要与远程仓库的<code>branch</code> 同名）：</p>\n<blockquote>\n<p><code>git checkout -b branch origin/branch</code> </p>\n</blockquote>\n<p>只有这样，才能建立本地与远成仓库的联系，之后的抓取<code>git pull</code> 和推送<code>git push origin branch</code> 才可以进行。</p>\n</li>\n<li><p><code>git pull</code> ，抓取分支，首先需要建立本地分支与远程仓库相应分支之间的链接：</p>\n<blockquote>\n<p><code>git branch --set-upstream branch origin/branch</code> </p>\n</blockquote>\n<p>在之前建立本地分支与远程库分支的基础上，可以将最新的提交从远程库相应的分支上抓取下来：</p>\n<blockquote>\n<p><code>git pull</code> </p>\n</blockquote>\n<p>如果<code>git pull</code> 的时候出现冲突，则需要<a href=\"#conflict-solve\">解决冲突</a> 。</p>\n</li>\n<li><p>本地分支，若不推送到远程，只有本地可见。</p>\n</li>\n</ul>\n<h3 id=\"标签（Tag）\"><a href=\"#标签（Tag）\" class=\"headerlink\" title=\"标签（Tag）\"></a>标签（Tag）</h3><p>版本发布的时候，为了今后方便查找，一般会使用标签的方式，采用有意义的文字标记当前版本，即可以将标签当作版本库的一个快照，本质上标签就是一个指向某一次<code>commit</code> 的指针，类似于分支指针（但是分支指针可以移动，标签指针不可以移动）。</p>\n<ul>\n<li><code>git tag</code> ，查看所有标签；</li>\n<li><code>git tag &lt;name&gt;</code> ，为当前分支生成一个标签，标签默认标记在最新的提交上；</li>\n<li><code>git tag &lt;name&gt; &lt;commit_id&gt;</code> ，若想为历史的某一次提交生成标签，则找到该提交的<code>commit_id</code> 即可；</li>\n<li><code>git tag -a &lt;tagname&gt; -m &quot;注释信息&quot; &lt;commit_id&gt;</code> ，创建标签并生成注释；</li>\n<li><code>git show &lt;tagname&gt;</code> ，查看相应的标签信息；</li>\n</ul>\n<p><strong>注</strong> ：标签是按照字母顺序排序的，而不是按照时间排序。</p>\n<ul>\n<li><p><code>git tag -d &lt;tagname&gt;</code> ，删除本地标签；</p>\n</li>\n<li><p><code>git push origin &lt;tagname&gt;</code> ，将标签推送到远程仓库中；</p>\n</li>\n<li><p><code>git push origin --tags</code> ，一次性地将本地标签全部推送到远程库中；</p>\n</li>\n<li><p>若想要删除的标签已经被推送到了远程库中，那么需要两步才能删除标签：</p>\n<blockquote>\n<p><code>git tag -d &lt;tagname&gt;</code> #首先，本地删除</p>\n<p><code>git push origin :refs/tags/&lt;tagname&gt;</code> #然后，远程删除库中的标签</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"Github\"><a href=\"#Github\" class=\"headerlink\" title=\"Github\"></a>Github</h3><p>如果要参与开源项目，首先将开源项目<code>Fork</code> 到自己的仓库中，然后<strong>从自己的仓库中<code>Clone</code> </strong>，只有这样才能在本地修改之后，再次推送到Github上，若希望开源项目的官方接受自己的修改，则需要在Github上发起<code>Pull Request</code> 。</p>\n<h3 id=\"gitignore\"><a href=\"#gitignore\" class=\"headerlink\" title=\".gitignore\"></a>.gitignore</h3><p>.gitignore文件中的文件名将会在提交的时候被忽略，.gitignore文件需要放在版本库中。</p>\n<p>.gitignore文件不需要从头开始编写，可以参照<a href=\"https://github.com/github/gitignore\" title=\".gitignore-doc\">官方文档</a>并进行相应的组合即可。</p>\n<ul>\n<li><code>git add -f &lt;file&gt;</code> ，有时候.gitignore文件中禁止提交的文件类型中，有你希望提交的一份文件，则可以通过上述命令强行添加并提交；</li>\n<li><code>git check-ignore -v &lt;file&gt;</code> ，当发现一个文件无法添加和提交时，需要检查.gitignore文件中哪一条规则写错了，可以使用上述命令进行检查。</li>\n</ul>\n<h3 id=\"Git配置\"><a href=\"#Git配置\" class=\"headerlink\" title=\"Git配置\"></a>Git配置</h3><ul>\n<li>当前仓库的配置文档存放在<code>.git/config</code> 文件中；</li>\n<li>当前用户的配置文档存放在用户主目录下的隐藏文件<code>.gitignore</code> 中；</li>\n<li><code>git config --global alias. &lt;short-command&gt; &lt;origin-command&gt;</code> ，配置别名，简化使用。</li>\n</ul>\n<h3 id=\"Git服务器搭建\"><a href=\"#Git服务器搭建\" class=\"headerlink\" title=\"Git服务器搭建\"></a>Git服务器搭建</h3><p>服务器系统采用Linux，推荐Ubuntu或者Debian，以下操作需要sudo权限。</p>\n<ol>\n<li><p>安装Git:</p>\n<p><code>sudo apt-get install git</code> </p>\n</li>\n<li><p>创建Git用户，用于运行Git服务：</p>\n<p><code>sudo adduser git</code> </p>\n</li>\n<li><p>添加公钥，保证用户的登录：</p>\n<p>收集所有需要登录服务器的用户的公钥，即<code>id_rsa.pub</code> 文件的内容，将公钥添加进服务器的<code>/home/git/.ssh/authorized_keys</code> 文件中，一行一个。</p>\n</li>\n<li><p>初始化Git仓库：</p>\n<p>选定一个目录作为Git仓库，例如<code>/git/git-server.git</code> ，在目录<code>/git</code> 下执行命令：</p>\n<p><code>sudo git init --bare git-server.git</code> </p>\n<p>创建的是裸仓库，即没有工作区，服务器的目的是为了共享，而不允许用户登录到服务器上去修改，然后将Git仓库的所有者更改为之前添加的用户git：</p>\n<p><code>sudo chown -R git:git git-server.git</code> </p>\n</li>\n<li><p>禁用shell登录：</p>\n<p>即禁止之前创建的用户git登录shell，可以通过编辑<code>/etc/passwd</code> 文件完成，将以下一行</p>\n<p><code>git:x:1001:1001:,,,:/home/git:/bin/bash</code> </p>\n<p>改为</p>\n<p><code>git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</code> </p>\n<p>意思就是，用户<code>git</code> 每次一登录shell就会自动退出，即无法登录shell进行其他操作，这么做的目的是，让<code>git</code> 用户可以正常通过ssh使用git，但禁止其登录shell。</p>\n</li>\n<li><p>远程Git仓库已经建立好了，其他客户端用户可以使用<code>git clone</code> 将服务器上的内容克隆到本地进行修改：</p>\n<p><code>git clone git@server:/git/git-server.git</code> </p>\n<p>修改完成之后，就是推送与共享了。</p>\n</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}