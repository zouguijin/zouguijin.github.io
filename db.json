{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/noise/source/css/font.less","path":"css/font.less","modified":0,"renderable":1},{"_id":"themes/noise/source/css/noise.less","path":"css/noise.less","modified":0,"renderable":1},{"_id":"themes/noise/source/css/highlight.less","path":"css/highlight.less","modified":0,"renderable":1},{"_id":"themes/noise/source/css/normalize.css","path":"css/normalize.css","modified":0,"renderable":1}],"Cache":[{"_id":"themes/noise/.travis.yml","hash":"9195328ae9f1b8c5089f2c898e1b9bf019980164","modified":1487581801893},{"_id":"themes/noise/LICENSE","hash":"86c2c15a2d0c891e5c0912e31ff7a12ef694ce3f","modified":1487581801893},{"_id":"themes/noise/README.md","hash":"f933e665385bafbee34f6ae95307e767bbe05b62","modified":1487581801893},{"_id":"themes/noise/_config.yml","hash":"32d63000d3d8aa5711fe56f56299aeb4ed392ee3","modified":1487581945862},{"_id":"source/_posts/firstTryonTypora.md","hash":"028f817c23cda011ae69f02549a6ba7c0988d55d","modified":1488110477712},{"_id":"source/_posts/git-multiSync.md","hash":"a38a464a7e672c15bed0941673eb17b3e9f25453","modified":1488109739673},{"_id":"source/_posts/git-study.md","hash":"120fd9a2baf6a459d4ffa0b5de87b4807abd276f","modified":1488110466415},{"_id":"source/_posts/hello-world.md","hash":"029f91fccbe8f87c0f3ea10c4042300d2fa7edc0","modified":1487581657362},{"_id":"source/about/index.md","hash":"6e5b1d8ea8a8d2d48ba046046c37c48fab7d93d8","modified":1487919728545},{"_id":"themes/noise/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1487581801877},{"_id":"themes/noise/.git/config","hash":"1bff9b6eaf288cbd3cca2c31c4e14b203f29d71d","modified":1487581801893},{"_id":"themes/noise/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1487581798183},{"_id":"themes/noise/.git/index","hash":"69b40f3448eed0f10056c3cceb62bf97092cce27","modified":1487919226017},{"_id":"themes/noise/.git/packed-refs","hash":"6c16071509a9073452c8999c0a63cc23a55d7b54","modified":1487581801877},{"_id":"themes/noise/layout/archive.jade","hash":"633384e3627380c91a7ed1f23a82a448cb4a6161","modified":1487581801893},{"_id":"themes/noise/layout/post.jade","hash":"64c91e9eda4ca9e77607cf253694e1a9a10c7383","modified":1487581801893},{"_id":"themes/noise/layout/base.jade","hash":"8f075c5dfa7a380934bcae29875b9ae85751bcfa","modified":1487581801893},{"_id":"themes/noise/layout/page.jade","hash":"acf65a9f678a3b278a4ac20de8754bc9ab0c8f37","modified":1487581801893},{"_id":"themes/noise/layout/index.jade","hash":"cb0e954c2848a46618757c3c20e88ef49385df47","modified":1487581801893},{"_id":"themes/noise/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1487581798183},{"_id":"themes/noise/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1487581798183},{"_id":"themes/noise/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1487581798183},{"_id":"themes/noise/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1487581798183},{"_id":"themes/noise/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1487581798183},{"_id":"themes/noise/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1487581798183},{"_id":"themes/noise/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1487581798183},{"_id":"themes/noise/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1487581798183},{"_id":"themes/noise/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1487581798183},{"_id":"themes/noise/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1487581798183},{"_id":"themes/noise/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1487581798183},{"_id":"themes/noise/.git/logs/HEAD","hash":"2d00eb247a7a649d40054fcdb5c8e10570db7ab4","modified":1487581801877},{"_id":"themes/noise/layout/_partial/comments.jade","hash":"f97607b36dafaa9ef3dc109d7b8393aef5cef19e","modified":1487581801893},{"_id":"themes/noise/layout/_partial/helpers.jade","hash":"f87b4f41e2ddbd3db10fb2ebaa342954c4d8d9a0","modified":1487581801893},{"_id":"themes/noise/layout/_partial/paginator.jade","hash":"484f0850cdc8d8a954c0ac7131ebfd067047c5e5","modified":1487581801893},{"_id":"themes/noise/source/css/_variables.less","hash":"488149b5a7c2953396b859074fa58e4d80dd0442","modified":1487581801893},{"_id":"themes/noise/source/css/font.less","hash":"ff469bbb929ad07d8fa9a8881129ea225adeeb73","modified":1487581801893},{"_id":"themes/noise/source/css/noise.less","hash":"c2bb7170d4b8f5b8e4956e5ffe8c4f1c4069c74a","modified":1487581801893},{"_id":"themes/noise/source/css/highlight.less","hash":"6a00e35295f5b890a3a6daa6f6656af50d918721","modified":1487581801893},{"_id":"themes/noise/source/css/normalize.css","hash":"46844f2fc407f66636c6e783ddaeed2a684c2f8f","modified":1487581801893},{"_id":"themes/noise/.git/refs/heads/master","hash":"44343f89297925bc1cd6ea4b4c3da6f18a18179c","modified":1487581801877},{"_id":"themes/noise/.git/objects/pack/pack-fdb83ccd805a304799dafda5e6e40c21b321adb2.idx","hash":"5e1ff6ccdda82473dccf8ce2f0652b179982d789","modified":1487581801768},{"_id":"themes/noise/.git/logs/refs/heads/master","hash":"2d00eb247a7a649d40054fcdb5c8e10570db7ab4","modified":1487581801877},{"_id":"themes/noise/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1487581801877},{"_id":"themes/noise/.git/logs/refs/remotes/origin/HEAD","hash":"2d00eb247a7a649d40054fcdb5c8e10570db7ab4","modified":1487581801877},{"_id":"themes/noise/.git/objects/pack/pack-fdb83ccd805a304799dafda5e6e40c21b321adb2.pack","hash":"b5b7654e1bfee65e8ccb56fb6d102d6936c3f787","modified":1487581801784},{"_id":"public/about/index.html","hash":"0970be7fe8212baff4783024c5f623205ab5e914","modified":1488110535058},{"_id":"public/2017/02/24/hello-world/index.html","hash":"7cee61b639fa59c48a0a0a96f185e33d6917ee19","modified":1488110535058},{"_id":"public/2017/02/17/firstTryonTypora/index.html","hash":"15b02b040201d73cafe279bf9814f2277db1fc90","modified":1488110535058},{"_id":"public/index.html","hash":"ea816a2c933bb701c646d107b934c96e9f7e5cab","modified":1488110535058},{"_id":"public/tags/BlogTools/index.html","hash":"7e30b55dd4a76cb9caf53b9f14b8a8edc43c7e8c","modified":1488110535058},{"_id":"public/tags/Markdown-Editor/index.html","hash":"0198224b69937f3e91205a032bae3fdbfdf26533","modified":1488110535058},{"_id":"public/tags/Github/index.html","hash":"e2bd63e8573b8fb50ed36b384bddb02336355bd5","modified":1488110535058},{"_id":"public/tags/hexo/index.html","hash":"9afe863ea7da769d5e5e542f8c58d0573e97e09f","modified":1488110535059},{"_id":"public/tags/Git/index.html","hash":"50d89f697bf09f209e133df3a3475bfe09936f71","modified":1488110535059},{"_id":"public/categories/Study/index.html","hash":"5ea1f00f046917d4ed5d4f80e56181c594a8d737","modified":1488110535059},{"_id":"public/archives/index.html","hash":"bb9c3453326eba96aa38c960ef000aa8f299d9de","modified":1488110535059},{"_id":"public/archives/2017/index.html","hash":"bb9c3453326eba96aa38c960ef000aa8f299d9de","modified":1488110535059},{"_id":"public/archives/2017/02/index.html","hash":"bb9c3453326eba96aa38c960ef000aa8f299d9de","modified":1488110535059},{"_id":"public/2017/02/26/git-multiSync/index.html","hash":"66eb1a90cacc799713d89e09a533db1435289f5f","modified":1488110535059},{"_id":"public/2017/02/24/git-study/index.html","hash":"ac7e570139d3639a13279458362682f5b9f872d6","modified":1488110535059},{"_id":"public/css/normalize.css","hash":"d0fbef3dd405f26a5fdc896ca1f7875901782c6f","modified":1488110535099},{"_id":"public/css/font.css","hash":"675361046170c7a4e8c11c774f64b3d1a631b900","modified":1488110535100},{"_id":"public/css/highlight.css","hash":"061dc4e4c8f818a08c7f23aab625345b2d677d5f","modified":1488110535134},{"_id":"public/css/noise.css","hash":"56092b4a16cfcdcad32c5b6136fd5cb3c14989df","modified":1488110535134}],"Category":[{"name":"Study","_id":"cizmml95h0003qkup89pyveyj"}],"Data":[],"Page":[{"title":"About Me","catogeries":["AboutMe"],"tags":["Career","Life"],"_content":"\n\n\n# About Me\n\n- 对美的东西有一种完美主义的执念\n- 如果要做，就尽全力做到最好\n- 认真地选择一本好书或者一部好剧，安静地从头看到尾\n- 希望，平静，且明智\n- *未完，继续探索...*","source":"about/index.md","raw":"title: About Me\n\ncatogeries:\n\n- AboutMe\n\ntags:\n\n- Career\n- Life\n\n---\n\n\n\n# About Me\n\n- 对美的东西有一种完美主义的执念\n- 如果要做，就尽全力做到最好\n- 认真地选择一本好书或者一部好剧，安静地从头看到尾\n- 希望，平静，且明智\n- *未完，继续探索...*","date":"2017-02-24T07:11:17.859Z","updated":"2017-02-24T07:02:08.545Z","path":"about/index.html","comments":1,"layout":"page","_id":"cizmml95e0001qkuppyz9weaq","content":"<h1 id=\"About-Me\"><a href=\"#About-Me\" class=\"headerlink\" title=\"About Me\"></a>About Me</h1><ul>\n<li>对美的东西有一种完美主义的执念</li>\n<li>如果要做，就尽全力做到最好</li>\n<li>认真地选择一本好书或者一部好剧，安静地从头看到尾</li>\n<li>希望，平静，且明智</li>\n<li><em>未完，继续探索…</em></li>\n</ul>\n","excerpt":"","more":"<h1 id=\"About-Me\"><a href=\"#About-Me\" class=\"headerlink\" title=\"About Me\"></a>About Me</h1><ul>\n<li>对美的东西有一种完美主义的执念</li>\n<li>如果要做，就尽全力做到最好</li>\n<li>认真地选择一本好书或者一部好剧，安静地从头看到尾</li>\n<li>希望，平静，且明智</li>\n<li><em>未完，继续探索…</em></li>\n</ul>\n"}],"Post":[{"title":"Typora——Markdown编辑界的极简主义","date":"2017-02-17T01:00:00.000Z","_content":"\n### Before Typora\n\n在Windows平台上，Typora之前，我还曾经接触过[MarkdownPad](http://www.markdownpad.com/)和[MarkPad](http://code52.org/DownmarkerWPF/)两款Markdown编辑工具。\n\nMarkdownPad和MarkPad的特点：\n\n- 都支持Markdown的所有语法，可以实现不动用鼠标就完成一篇排版精美文章的书写；\n- 二者提供的都是两屏对照的实时渲染系统，即用户在左侧屏敲入带有Markdown语法的文字，在右侧屏会实时显示相应的HTML预览效果。\n- 所生成的Markdown文件可以直接用于个人博客以及上传至Github，支持程度好。\n\n不过，MarkdownPad和MarkPad仍有些许不同：\n\n- MarkdownPad的实时渲染采用的是[Awesomium](http://www.awesomium.com/)，简单来说，Awesomium是一个HTML网页UI界面的渲染引擎，适用于基于C++或者.NET的应用程序。个人觉得，Awesomium对于一个Markdown编辑器来说，功能过于强大，以至于使得MarkdownPad的运行比较吃内存，有悖于Markdown轻量级编辑器的定位，同时在Windows10操作系统下实际使用的时候发现，内嵌于MarkdownPad中的Awesomium经常崩溃，出现无法渲染的情况，需要手动下载Awesomium SDK进行修复（据说安装SDK之后就可以修复，但是我没成功...）。\n- MarkPad的渲染使用的是JekyII，一个基于Ruby语言的静态网页和网站生成工具。同时，JekyII还可以和Github结合，搭建一个免费静态博客。\n- 此外，在外观和易用性上，MarkdownPad显得比较老气，风格与MS Office比较类似，常用标记功能的图标都列在菜单栏中，较为容易上手使用，MarkPad则较为有科技感，界面简洁，但是由于没有相应的常用功能列表，所以使用起来还需要经过一段时间的锻炼，适合已经熟悉Markdown语法的用户。\n\n两屏对照的实时渲染确实很方便，用户在书写过程中如果临时想更改之前文字的样式或者修改相应样式中的部分文字，只需要移动光标到相应的位置，修改部分内容即可。\n\n### Typora\n\nTypora是一款本地的、所写即可见的Markdown编辑器。","source":"_posts/firstTryonTypora.md","raw":"title: Typora——Markdown编辑界的极简主义\n\ndate: 2017/2/17 09:00:00\n\ncategories:\n\n- Study\n\ntags:\n\n- BlogTools\n- Markdown Editor\n\n---\n\n### Before Typora\n\n在Windows平台上，Typora之前，我还曾经接触过[MarkdownPad](http://www.markdownpad.com/)和[MarkPad](http://code52.org/DownmarkerWPF/)两款Markdown编辑工具。\n\nMarkdownPad和MarkPad的特点：\n\n- 都支持Markdown的所有语法，可以实现不动用鼠标就完成一篇排版精美文章的书写；\n- 二者提供的都是两屏对照的实时渲染系统，即用户在左侧屏敲入带有Markdown语法的文字，在右侧屏会实时显示相应的HTML预览效果。\n- 所生成的Markdown文件可以直接用于个人博客以及上传至Github，支持程度好。\n\n不过，MarkdownPad和MarkPad仍有些许不同：\n\n- MarkdownPad的实时渲染采用的是[Awesomium](http://www.awesomium.com/)，简单来说，Awesomium是一个HTML网页UI界面的渲染引擎，适用于基于C++或者.NET的应用程序。个人觉得，Awesomium对于一个Markdown编辑器来说，功能过于强大，以至于使得MarkdownPad的运行比较吃内存，有悖于Markdown轻量级编辑器的定位，同时在Windows10操作系统下实际使用的时候发现，内嵌于MarkdownPad中的Awesomium经常崩溃，出现无法渲染的情况，需要手动下载Awesomium SDK进行修复（据说安装SDK之后就可以修复，但是我没成功...）。\n- MarkPad的渲染使用的是JekyII，一个基于Ruby语言的静态网页和网站生成工具。同时，JekyII还可以和Github结合，搭建一个免费静态博客。\n- 此外，在外观和易用性上，MarkdownPad显得比较老气，风格与MS Office比较类似，常用标记功能的图标都列在菜单栏中，较为容易上手使用，MarkPad则较为有科技感，界面简洁，但是由于没有相应的常用功能列表，所以使用起来还需要经过一段时间的锻炼，适合已经熟悉Markdown语法的用户。\n\n两屏对照的实时渲染确实很方便，用户在书写过程中如果临时想更改之前文字的样式或者修改相应样式中的部分文字，只需要移动光标到相应的位置，修改部分内容即可。\n\n### Typora\n\nTypora是一款本地的、所写即可见的Markdown编辑器。","slug":"firstTryonTypora","published":1,"updated":"2017-02-26T12:01:17.712Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizmml95b0000qkup63ojxzzt","content":"<h3 id=\"Before-Typora\"><a href=\"#Before-Typora\" class=\"headerlink\" title=\"Before Typora\"></a>Before Typora</h3><p>在Windows平台上，Typora之前，我还曾经接触过<a href=\"http://www.markdownpad.com/\" target=\"_blank\" rel=\"external\">MarkdownPad</a>和<a href=\"http://code52.org/DownmarkerWPF/\" target=\"_blank\" rel=\"external\">MarkPad</a>两款Markdown编辑工具。</p>\n<p>MarkdownPad和MarkPad的特点：</p>\n<ul>\n<li>都支持Markdown的所有语法，可以实现不动用鼠标就完成一篇排版精美文章的书写；</li>\n<li>二者提供的都是两屏对照的实时渲染系统，即用户在左侧屏敲入带有Markdown语法的文字，在右侧屏会实时显示相应的HTML预览效果。</li>\n<li>所生成的Markdown文件可以直接用于个人博客以及上传至Github，支持程度好。</li>\n</ul>\n<p>不过，MarkdownPad和MarkPad仍有些许不同：</p>\n<ul>\n<li>MarkdownPad的实时渲染采用的是<a href=\"http://www.awesomium.com/\" target=\"_blank\" rel=\"external\">Awesomium</a>，简单来说，Awesomium是一个HTML网页UI界面的渲染引擎，适用于基于C++或者.NET的应用程序。个人觉得，Awesomium对于一个Markdown编辑器来说，功能过于强大，以至于使得MarkdownPad的运行比较吃内存，有悖于Markdown轻量级编辑器的定位，同时在Windows10操作系统下实际使用的时候发现，内嵌于MarkdownPad中的Awesomium经常崩溃，出现无法渲染的情况，需要手动下载Awesomium SDK进行修复（据说安装SDK之后就可以修复，但是我没成功…）。</li>\n<li>MarkPad的渲染使用的是JekyII，一个基于Ruby语言的静态网页和网站生成工具。同时，JekyII还可以和Github结合，搭建一个免费静态博客。</li>\n<li>此外，在外观和易用性上，MarkdownPad显得比较老气，风格与MS Office比较类似，常用标记功能的图标都列在菜单栏中，较为容易上手使用，MarkPad则较为有科技感，界面简洁，但是由于没有相应的常用功能列表，所以使用起来还需要经过一段时间的锻炼，适合已经熟悉Markdown语法的用户。</li>\n</ul>\n<p>两屏对照的实时渲染确实很方便，用户在书写过程中如果临时想更改之前文字的样式或者修改相应样式中的部分文字，只需要移动光标到相应的位置，修改部分内容即可。</p>\n<h3 id=\"Typora\"><a href=\"#Typora\" class=\"headerlink\" title=\"Typora\"></a>Typora</h3><p>Typora是一款本地的、所写即可见的Markdown编辑器。</p>\n","excerpt":"","more":"<h3 id=\"Before-Typora\"><a href=\"#Before-Typora\" class=\"headerlink\" title=\"Before Typora\"></a>Before Typora</h3><p>在Windows平台上，Typora之前，我还曾经接触过<a href=\"http://www.markdownpad.com/\">MarkdownPad</a>和<a href=\"http://code52.org/DownmarkerWPF/\">MarkPad</a>两款Markdown编辑工具。</p>\n<p>MarkdownPad和MarkPad的特点：</p>\n<ul>\n<li>都支持Markdown的所有语法，可以实现不动用鼠标就完成一篇排版精美文章的书写；</li>\n<li>二者提供的都是两屏对照的实时渲染系统，即用户在左侧屏敲入带有Markdown语法的文字，在右侧屏会实时显示相应的HTML预览效果。</li>\n<li>所生成的Markdown文件可以直接用于个人博客以及上传至Github，支持程度好。</li>\n</ul>\n<p>不过，MarkdownPad和MarkPad仍有些许不同：</p>\n<ul>\n<li>MarkdownPad的实时渲染采用的是<a href=\"http://www.awesomium.com/\">Awesomium</a>，简单来说，Awesomium是一个HTML网页UI界面的渲染引擎，适用于基于C++或者.NET的应用程序。个人觉得，Awesomium对于一个Markdown编辑器来说，功能过于强大，以至于使得MarkdownPad的运行比较吃内存，有悖于Markdown轻量级编辑器的定位，同时在Windows10操作系统下实际使用的时候发现，内嵌于MarkdownPad中的Awesomium经常崩溃，出现无法渲染的情况，需要手动下载Awesomium SDK进行修复（据说安装SDK之后就可以修复，但是我没成功…）。</li>\n<li>MarkPad的渲染使用的是JekyII，一个基于Ruby语言的静态网页和网站生成工具。同时，JekyII还可以和Github结合，搭建一个免费静态博客。</li>\n<li>此外，在外观和易用性上，MarkdownPad显得比较老气，风格与MS Office比较类似，常用标记功能的图标都列在菜单栏中，较为容易上手使用，MarkPad则较为有科技感，界面简洁，但是由于没有相应的常用功能列表，所以使用起来还需要经过一段时间的锻炼，适合已经熟悉Markdown语法的用户。</li>\n</ul>\n<p>两屏对照的实时渲染确实很方便，用户在书写过程中如果临时想更改之前文字的样式或者修改相应样式中的部分文字，只需要移动光标到相应的位置，修改部分内容即可。</p>\n<h3 id=\"Typora\"><a href=\"#Typora\" class=\"headerlink\" title=\"Typora\"></a>Typora</h3><p>Typora是一款本地的、所写即可见的Markdown编辑器。</p>\n"},{"title":"Github Pages+hexo博客的创建与多机更新博客的实现","date":"2017-02-26T11:00:00.000Z","catergories":["Study"],"_content":"\n### 0 前言\n\n---\n\n本篇博文主要介绍在Windows 10系统上创建Github Pages+hexo博客的过程，同时，考虑到可能会在不同地点使用不同机器进行博客的更新操作，所以本篇博文还会介绍如何实现多台机器更新博客内容的方法，主要涉及的名词有：\n\n- Github与Github Pages\n\n  [Github](https://github.com/) 是一个面向开源以及私有软件项目的托管平台，简单来说就是一个远程仓库，注册账号以后可以在Github上存放软件代码，当然也可以存放文件，但是要注意的是，免费使用的情况下，你的Github是开放的，也就是所有人都可以看到你的仓库里存放了什么，如果想要加密则需要付费。\n\n  Github Pages则是在Github上搭建的博客或者网页，网页地址都是 `<your_githubname>.github.io` 。既然Github可以存放软件代码，那当然也可以存放博客文章以及网页需要的HTML/CSS/JS文件，从而Github Pages以Github仓库作为网页服务器，向外界提供一个可以访问的静态网页。\n\n- Markdown\n\n  [Markdown](http://sspai.com/25137/) 是一种用于写作的轻量级标记语言，虽然不像Word那样拥有大量的排版和字体设置，可以排版出一篇或精美或专业的文章，但是Markdown中简单的标记字符易于使用和记忆，甚至可以完成脱离鼠标，单单使用键盘就可以完成一篇文章的书写以及简洁精致的排版，这让使用者可以更加专心的码字，而不是过多地在意繁琐的排版工作。\n\n  Markdown有很多相关的编辑器，这里强烈推荐[Typora](https://typora.io/) 。\n\n  *有关Markdown编辑器的介绍和分析，请见另一篇博文《Typora——Markdown编辑界的极简主义》* \n\n- hexo\n\n  [hexo](https://hexo.io/) 是一款基于[node.js](https://nodejs.org/en/) 、开源的静态博客生成器。所谓“静态”，指的是所生成的博客网页本身只能提供浏览，而不能提交信息（当然，如果嵌入第三方插件，则可以通过插件提交信息，这是后话...）。hexo将书写好的Markdown文件根据选定的hexo主题转换成一堆HTML/CSS/JS文件，并支持本地预览网页，如果觉得没有问题，hexo还提供部署的功能，将网页文件上传到Github中，之后就可以通过访问Github Pages看到已发布的博客网页。\n\n- Git\n\n  [Git](https://git-scm.com/) 是一种开源的分布式版本管理系统，Github是Git发展壮大之后的产物，只支持Git作为唯一的版本库格式进行托管。\n\n  *有关Git的命令操作，请见另一篇文章《Git Study》*\n\n### 1 创建Github Pages并建立Github与本地的连接\n\n---\n\n#### 1.1 注册Github并创建一个新仓库（Repository）\n\n登录Github网站并注册账号成功之后，可以按照<span id=\"create-repo\"></span>[Create a new repository on GitHub](https://help.github.com/articles/create-a-repo/#create-a-new-repository-on-github) 的官方教程，一步一步地创建一个新的仓库，需要注意的只有一点：即因为我们这里是为了创建Github Pages博客的仓库，所以Repository name一定要是`<your_githubname>.github.io` 的形式。\n\n#### 1.2 建立Github与本地的连接（Authenticating）\n\n为了能够将本地的博客内容提交到远端的Github仓库中，需要建立本地与Github仓库的连接<span id=\"create-githublink\"></span>，即要让本地通过Github的身份验证（Authenticating）。考虑到Git默认使用SSH协议，所以我们使用SSH协议建立本地与Github之间的连接，参照[Connecting to GitHub with SSH](https://help.github.com/articles/connecting-to-github-with-ssh/) 。*（以下命令需要安装Git，并在Git Bash中完成输入）* \n\n当然也可以使用HTTPS建立连接，具体可以参照[Authenticating with GitHub from Git](https://help.github.com/articles/set-up-git/#next-steps-authenticating-with-github-from-git) 并做进一步的阅读。\n\n##### 1.2.1 本地生成新的SSH Key\n\n- 执行以下命令，输入你注册Github时使用的邮箱：\n\n   `ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"` \n\n- 出现以下提示的时候，说明已经使用你的邮箱生成了一个新的SSH Key：\n\n  `Generating public/private rsa key pair.` \n\n- 随后会出现以下提示，如果你对保存SSH Key的位置没有特殊的要求时，可以直接回车选择默认保存位置进行SSH Key的保存，保存的位置就是括号中所示的位置（根据实际系统有所不同）：\n\n  ```\n  Enter a file in which to save the key (/Users/you/.ssh/id_rsa):[Press enter]\n  ```\n\n- 接下来，需要为你的SSH Key输入密码，当然也可以选择不要密码，直接两个回车就可以了：\n\n  ```\n  Enter passphrase (empty for no passphrase): [Type a passphrase]\n  Enter same passphrase again: [Type passphrase again]\n  ```\n\n**注** ：如果你之前就有SSH Key，那么你可以检查一下是不是有合适的SSH Key可以使用：`ls -al ~/.ssh` \n\n##### 1.2.2 将SSH Key加入ssh-agent\n\n- 确定ssh-agent正在运行，执行以下命令开启ssh-agent：\n\n  `eval $(ssh-agent -s)` \n\n- 将SSH Key添加到ssh-agent中：\n\n  `ssh-add ~/.ssh/id_rsa` \n\n##### 1.2.3 将SSH Key添加到Github账号中\n\n- 将SSH Key复制到粘贴板：\n\n  ````\n  clip < ~/.ssh/id_rsa.pub\n  ````\n\n- 登录Github，点击右上方的头像，在下拉菜单中选择**Setting** ，然后**SSH and GPG keys** —— **New SSH Key** 或者**Add SSH Key** ，在\"Title\"里输入你想要的名称，然后在下方的“Key”文本框内添加刚才复制的SSH Key，最后点击**Add SSH Key** ，密码验证一下就好。\n\n##### 1.2.4 测试一下SSH连接是否成功\n\n- 执行以下命令：\n\n  `ssh -T git@github.com` \n\n  若输出以下两则信息中的一种，且其中一种是你的签名信息，那么输入`yes` 并回车即可：\n\n  ```\n  The authenticity of host 'github.com (192.30.252.1)' can't be established.\n  RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.\n  Are you sure you want to continue connecting (yes/no)?\n  ```\n\n  ```\n  The authenticity of host 'github.com (192.30.252.1)' can't be established.\n  RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.\n  Are you sure you want to continue connecting (yes/no)?\n  ```\n\n- 之后就可以看到验证成功的消息，确认其中有你的用户名：\n\n  ```\n  Hi <username>! You've successfully authenticated, but GitHub does not provide shell access.\n  ```\n\n  如果出现了`access denied` 的错误信息，请参照 [Error: Permission denied (publickey)](https://help.github.com/articles/error-permission-denied-publickey) 以及 [read these instructions for diagnosing the issue](https://help.github.com/articles/error-permission-denied-publickey) 进行修复。\n\n### 2 Hexo本地建站\n\n---\n\n#### 2.1 hexo安装\n\nhexo是基于node.js且在博客部署的时候需要Git命令操作的，所以在安装hexo之前，需要先安装[node.js](https://nodejs.org/en/) 和[Git](https://git-scm.com/download/win) 。\n\n完成上述两者的安装后，打开Git Bash，执行以下命令即可完成hexo的安装：\n\n```\nnpm install -g hexo-cli\n```\n\n#### 2.2 hexo站点建立\n\n- **1. 确定博客本地站点的位置：** \n\n  ~~选择一个位置，作为今后博客本地站点文件的存放位置， 在该位置建立名为`<your_githubname>.github.io` 的文件夹，`<your_githubname>.github.io` 也就是之前在Github上创建的仓库名~~ \n\n  由于我想要建立的是一个可以实现多机更新的博客，所以应该将hexo站点建立在**本地的Github仓库**中，这样在一台机器上配置好的主题和配置文件就可以随时上传到**Github远程仓库**中保存。如果希望在其他机器上建立hexo站点，在安装Git的基础上，可以先将之前保存在Github远程仓库中的hexo站点文件**克隆**到本地，形成Github本地仓库，然后在本地仓库中安装hexo即可使用，不需要重复配置。\n\n  同时，由于我们的博客静态网页是发布在远程仓库的`master` 分支，即主分支上，所以我们需要在`master` 分支的基础上，**新建一个分支**，命名随意，我这里记为`hexo-files` ，用于保存推送上来的hexo站点文件，同时在Github中将`hexo-files` 分支设置为当前仓库的**默认分支**，这样可以方便将本地仓库的文件推送到远端仓库中。\n\n  综上，在上文[创建Github远端新仓库](#create-repo) 以及新建并设置默认分支为`hexo-files` 的基础上，将这个新仓库**克隆**到本地，从而建立本地的Github仓库：\n\n  ```\n  # 切换到在你希望建立Github本地仓库的路径下\n  git clone git@github.com:<your_githubname>/<your_githubname>.github.io.git\n  ```\n\n  上述命令会自动创建一个名为`<your_githubname>.github.io` 的文件夹，并将远程仓库中的文件都放到这个文件夹中。同时，可以发现文件夹中有一个名为`.git` 的文件夹，这个文件夹保存了有关Github本地仓库的信息以及本地仓库与远程仓库的连接信息，也就是能将`<your_githubname>.github.io` 文件夹中内容推送到远程仓库中的关键。\n\n  **注** ：由于后续建站的时候，`hexo init` 命令初始化时，会将`.git` 文件夹覆盖，所以在这一步结束的时候，需要先将`.git` 文件夹保存起来，等待下一步`hexo init` 之后再复制进来。\n\n- **2. 建站：**\n\n  进入站点文件夹`<your_githubname>.github.io` 内，依次执行以下两条命令，完成hexo站点的建立：\n\n  ```\n  hexo init\n  npm install\n  ```\n\n  **注** ：记得将`.git` 文件夹复制到`<your_githubname>.github.io` 中。\n\n  此时，在Git Bash中进入`<your_githubname>.github.io` 目录下，可以看到当前所处Github分支是`hexo-files` ，如果不是，请返回上一步，设置好默认分支，再克隆远程仓库到本地。\n\n  完成后，站点文件夹内的目录结构大致如下：\n\n  ```\n  .\n  ├── .git\n  ├── _config.yml\n  ├── package.json\n  ├── node_modules\n  ├── scaffolds\n  ├── source\n  |   └── _posts\n  └── themes\n  ```\n\n  各文件和文件夹的含义大致为：\n\n  - `_config.yml` ，存放站点的配置信息，比如站点主题、站点名、站点菜单、站点链接以及第三方插件等等；\n\n  - `package.json` ，存放插件信息，可以查看安装了哪些插件；\n\n  - `node_modules` ，存放站点主题相关的样式文件；\n\n  - `scaffolds` ，模板文件，生成静态网页时，hexo会将Markdown文件中`---` 以上的部分对比模板文件，然后生成新的静态网页文件；\n\n  - `source` ，存放用户写好的Markdown文件，想要生成静态网页的Markdown文件写好之后，就可以放在`_post` 文件夹下。除了`_post` 文件夹，其他以`_` 开头的文件夹都会被忽略，而且，只有将Markdown文件放在`_post` 文件夹下，生成之后才会具有完整的主题样式。\n\n    当然，如果想在网页上创建类似于`About` 的更多菜单选项，可以在`source` 文件夹下新建更多的文件夹，并在其中添加Markdown文件，当然，这些文件生成静态网页后不会具有完整主题样式，只能手动调整。\n\n  - `themes` ，存放主题文件。\n\n  **注** ：由于默认的NPM镜像有时候会很慢，在这时候可以将默认的源切换到淘宝镜像：\n\n  ```\n  npm config set registry \"https://registry.npm.taobao.org\"\n  ```\n\n#### 2.3 hexo站点配置\n\n站点大部分的配置都可以通过`_config.yml` 文件实现，具体各个部分的含义可以参考[Hexo-配置](https://hexo.io/zh-cn/docs/configuration.html) 。\n\n#### 2.4 hexo新内容生成\n\n将一篇写好的Markdown文件放入`_post` 文件夹中（如果你还不知道怎么写，可以先参照和使用文件夹中已有的一个示例），关于如何写一篇Markdown文章，推荐使用[Typora](https://typora.io/) Markdown编辑器，关于Markdown语法，推荐[Typora For Markdown 语法](http://www.jianshu.com/p/092de536d948) ，当然也可以自行搜索。\n\n将Markdown文件生成静态网页文件，执行以下命令之后，会产生一个`public` 文件夹，其中包含的就是所生成的静态网页文件和样式：\n\n``` \nhexo generate\n# 或者简化为 hexo g\n```\n\n启动hexo本地服务器，然后在浏览器中输入`http://localhost:4000/` ，就可以在本地预览新生成的网页：\n\n```\nhexo server\n```\n\n需要注意的是，单纯写一篇文章，生成之后只会在网页显示一部分，如果要阅读全文或者支持文章分类，必须在文章开头添加[Front-matter](https://hexo.io/zh-cn/docs/front-matter.html) ，如下所示：\n\n```\ntitle: Hexo\ndate: 2017/02/27 00:00:00\ncategories:\n- Study\ntags:\n- Hexo\n- Github\n---\nHello World.\n```\n\n#### 2.5 hexo主题更换\n\nhexo的主题很多，可以访问[Themes|Hexo](https://hexo.io/themes/) 选取。\n\n以下将以[Noise](https://github.com/lotabout/hexo-theme-noise) 主题为例，讲解一下主题的更换。\n\n- 找到主题的Github主页，主页上一般都会有安装的步骤和使用教程；\n- 将主题的代码克隆到`/themes` 文件夹下，并安装主题和主题渲染器：\n\n```\ngit clone https://github.com/lotabout/hexo-theme-noise themes/noise\nnpm install hexo-renderer-less --save\nnpm install hexo-renderer-jade --save\n```\n\n- 修改配置文档`_config.yml` ，将`theme` 的值由`landscape` 修改为`noise` 。\n- 重新执行一遍生成操作即可预览:\n\n```\nhexo clean\nhexo generate\nhexo server\n```\n\n#### 2.6 小结\n\n以上就完成了hexo的本地建站工作，如果只想在本地玩玩，到这里就完成了，日常的工作就是写写Markdown文章，然后在站点目录下依次执行以下命令即可：\n\n```\nhexo generate\nhexo server\n# visit http://localhost:4000/\n```\n\nPS. 顺便总结一下不问原因的、从零开始的快速建站方法：\n\n```\n# install node.js and git\nnpm install -g hexo-cli\n# choose a path and clone <your_githubname>.github.io.git to local dir\ngit clone git@github.com:<your_githubname>/<your_githubname>.github.io.git\ncd <your_githubname>.github.io\n# 先将 .git 文件夹复制\nhexo init\n# 再将 .git 文件夹粘贴进来\nnpm install\n# write a markdown file and put it into /source/_post/\nhexo generate\nhexo server\n```\n\n### 3 hexo部署到Github\n\n---\n\n- 安装插件：\n\n```\nnpm install hexo-deployer-git --save\n```\n\n- 修改配置文件`_config.yml` ：\n\n```\ndeploy:\n  type: git\n  repo:  https://github.com/<your_githubname>/<your_name>.github.io.git\n  branch: master\n# branch: master 意思是，部署的时候选择master分支发布\n```\n\n​\t**注 ：配置文件中冒号后面一定要空一格** \n\n- 将hexo站点文件推送到远程仓库中，并将生成的静态网页部署到Github Pages：\n\n```\ngit add .\ngit commit -m \"注释\"\ngit push origin hexo-files # 意思是，将本地仓库hexo-files分支的内容推送到名为origin的远程仓库的默认分支中\n# 生成静态网页并部署到Github上\nhexo generate\nhexo deploy\n# 或者简化  hexo g -d\n```\n\n​\t有时候会跳出一个窗口，输入Github账号和密码即可。\n\n- 登录`https://<your_githubname>.github.io` ，查看部署完成的博客内容。\n\n**注** ：我还没有出现过部署不成功的情况，如果有，请查看[hexo部署后没动静，咋办](http://lowrank.science/Hexo-Github/) 。\n\n### 4 hexo博客更新以及多机更新流程\n\n---\n\n- **Status1** ：如果上一次更新时使用的就是当前的机器，那么只需要将新完成的Markdown文件放入`_post` 文件夹内，按照情况执行以下命令即可：\n\n```\n# 本地预览时\nhexo generate\nhexo server\n# 确定完成，需要推送&发布\nhexo clean # 清理一下减少推送的数据量\ngit add .\ngit commit -m \"注释\"\ngit push origin hexo-files\nhexo g -d\n```\n\n- **Status2** ：如果上一次更新时使用的不是当前机器，那么首先需要确定当前机器已经[建立了Github与本地的连接](#create-githublink) 并且已经安装了node.js和Git，之后根据情况执行以下命令：\n\n```\n# 创建本地仓库\ngit clone git@github.com:<your_githubname>/<your_githubname>.github.io.git\ncd <your_githubname>.github.io\n# 若当前机器是第一次用于编写发布博客，则需要安装hexo\nnpm install -g hexo-cli\n# 否则，从这里开始\nnpm install hexo \nnpm install\nnpm install hexo-deployer-git --save\n# npm install hexo-renderer-less --save\n# npm install hexo-renderer-jade --save\n# 之后，就可以按照上述的 Status1 推送和发布博客了\n```\n\n### 5 总结\n\n本文介绍了Hexo+Github Pages博客的建立方法和过程，以及如何实现多机更新Github博客的原理和方法。\n\n总的来说，如果是第一次搭建Github博客，要学习的东西还是蛮多的，如果不明白其中的道理，加上网上零零散散不完全的教程，经常会绕到死胡同里。其中，我认为掌握Github**仓库**和**分支**的概念是很重要的，当然这也是学习Github中很重要的两个知识点。\n\n在简单学习Github之后，我又萌生了将未完成的Markdown文件存储在Github远程仓库上的想法，这样未编写完成的Markdown文章就可以在不同机器上抓取并编写，然后推送共享，随时随地编写文章，直到完成。这对于我一个经常在实验室和宿舍两头跑的学生来说，是一件挺方便的事情。\n\n之后的工作......应该是系统地学习Github，了解Github上更多有趣的东西吧，先放个链接吧，[如何使用Github](https://www.zhihu.com/question/20070065) 以及[Github上有趣的项目](https://www.zhihu.com/question/23498424)。","source":"_posts/git-multiSync.md","raw":"title: Github Pages+hexo博客的创建与多机更新博客的实现\n\ndate: 2017/2/26 19:00:00\n\ncatergories:\n\n- Study\n\ntags:\n\n- BlogTools\n- Github\n- hexo\n\n---\n\n### 0 前言\n\n---\n\n本篇博文主要介绍在Windows 10系统上创建Github Pages+hexo博客的过程，同时，考虑到可能会在不同地点使用不同机器进行博客的更新操作，所以本篇博文还会介绍如何实现多台机器更新博客内容的方法，主要涉及的名词有：\n\n- Github与Github Pages\n\n  [Github](https://github.com/) 是一个面向开源以及私有软件项目的托管平台，简单来说就是一个远程仓库，注册账号以后可以在Github上存放软件代码，当然也可以存放文件，但是要注意的是，免费使用的情况下，你的Github是开放的，也就是所有人都可以看到你的仓库里存放了什么，如果想要加密则需要付费。\n\n  Github Pages则是在Github上搭建的博客或者网页，网页地址都是 `<your_githubname>.github.io` 。既然Github可以存放软件代码，那当然也可以存放博客文章以及网页需要的HTML/CSS/JS文件，从而Github Pages以Github仓库作为网页服务器，向外界提供一个可以访问的静态网页。\n\n- Markdown\n\n  [Markdown](http://sspai.com/25137/) 是一种用于写作的轻量级标记语言，虽然不像Word那样拥有大量的排版和字体设置，可以排版出一篇或精美或专业的文章，但是Markdown中简单的标记字符易于使用和记忆，甚至可以完成脱离鼠标，单单使用键盘就可以完成一篇文章的书写以及简洁精致的排版，这让使用者可以更加专心的码字，而不是过多地在意繁琐的排版工作。\n\n  Markdown有很多相关的编辑器，这里强烈推荐[Typora](https://typora.io/) 。\n\n  *有关Markdown编辑器的介绍和分析，请见另一篇博文《Typora——Markdown编辑界的极简主义》* \n\n- hexo\n\n  [hexo](https://hexo.io/) 是一款基于[node.js](https://nodejs.org/en/) 、开源的静态博客生成器。所谓“静态”，指的是所生成的博客网页本身只能提供浏览，而不能提交信息（当然，如果嵌入第三方插件，则可以通过插件提交信息，这是后话...）。hexo将书写好的Markdown文件根据选定的hexo主题转换成一堆HTML/CSS/JS文件，并支持本地预览网页，如果觉得没有问题，hexo还提供部署的功能，将网页文件上传到Github中，之后就可以通过访问Github Pages看到已发布的博客网页。\n\n- Git\n\n  [Git](https://git-scm.com/) 是一种开源的分布式版本管理系统，Github是Git发展壮大之后的产物，只支持Git作为唯一的版本库格式进行托管。\n\n  *有关Git的命令操作，请见另一篇文章《Git Study》*\n\n### 1 创建Github Pages并建立Github与本地的连接\n\n---\n\n#### 1.1 注册Github并创建一个新仓库（Repository）\n\n登录Github网站并注册账号成功之后，可以按照<span id=\"create-repo\"></span>[Create a new repository on GitHub](https://help.github.com/articles/create-a-repo/#create-a-new-repository-on-github) 的官方教程，一步一步地创建一个新的仓库，需要注意的只有一点：即因为我们这里是为了创建Github Pages博客的仓库，所以Repository name一定要是`<your_githubname>.github.io` 的形式。\n\n#### 1.2 建立Github与本地的连接（Authenticating）\n\n为了能够将本地的博客内容提交到远端的Github仓库中，需要建立本地与Github仓库的连接<span id=\"create-githublink\"></span>，即要让本地通过Github的身份验证（Authenticating）。考虑到Git默认使用SSH协议，所以我们使用SSH协议建立本地与Github之间的连接，参照[Connecting to GitHub with SSH](https://help.github.com/articles/connecting-to-github-with-ssh/) 。*（以下命令需要安装Git，并在Git Bash中完成输入）* \n\n当然也可以使用HTTPS建立连接，具体可以参照[Authenticating with GitHub from Git](https://help.github.com/articles/set-up-git/#next-steps-authenticating-with-github-from-git) 并做进一步的阅读。\n\n##### 1.2.1 本地生成新的SSH Key\n\n- 执行以下命令，输入你注册Github时使用的邮箱：\n\n   `ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"` \n\n- 出现以下提示的时候，说明已经使用你的邮箱生成了一个新的SSH Key：\n\n  `Generating public/private rsa key pair.` \n\n- 随后会出现以下提示，如果你对保存SSH Key的位置没有特殊的要求时，可以直接回车选择默认保存位置进行SSH Key的保存，保存的位置就是括号中所示的位置（根据实际系统有所不同）：\n\n  ```\n  Enter a file in which to save the key (/Users/you/.ssh/id_rsa):[Press enter]\n  ```\n\n- 接下来，需要为你的SSH Key输入密码，当然也可以选择不要密码，直接两个回车就可以了：\n\n  ```\n  Enter passphrase (empty for no passphrase): [Type a passphrase]\n  Enter same passphrase again: [Type passphrase again]\n  ```\n\n**注** ：如果你之前就有SSH Key，那么你可以检查一下是不是有合适的SSH Key可以使用：`ls -al ~/.ssh` \n\n##### 1.2.2 将SSH Key加入ssh-agent\n\n- 确定ssh-agent正在运行，执行以下命令开启ssh-agent：\n\n  `eval $(ssh-agent -s)` \n\n- 将SSH Key添加到ssh-agent中：\n\n  `ssh-add ~/.ssh/id_rsa` \n\n##### 1.2.3 将SSH Key添加到Github账号中\n\n- 将SSH Key复制到粘贴板：\n\n  ````\n  clip < ~/.ssh/id_rsa.pub\n  ````\n\n- 登录Github，点击右上方的头像，在下拉菜单中选择**Setting** ，然后**SSH and GPG keys** —— **New SSH Key** 或者**Add SSH Key** ，在\"Title\"里输入你想要的名称，然后在下方的“Key”文本框内添加刚才复制的SSH Key，最后点击**Add SSH Key** ，密码验证一下就好。\n\n##### 1.2.4 测试一下SSH连接是否成功\n\n- 执行以下命令：\n\n  `ssh -T git@github.com` \n\n  若输出以下两则信息中的一种，且其中一种是你的签名信息，那么输入`yes` 并回车即可：\n\n  ```\n  The authenticity of host 'github.com (192.30.252.1)' can't be established.\n  RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.\n  Are you sure you want to continue connecting (yes/no)?\n  ```\n\n  ```\n  The authenticity of host 'github.com (192.30.252.1)' can't be established.\n  RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.\n  Are you sure you want to continue connecting (yes/no)?\n  ```\n\n- 之后就可以看到验证成功的消息，确认其中有你的用户名：\n\n  ```\n  Hi <username>! You've successfully authenticated, but GitHub does not provide shell access.\n  ```\n\n  如果出现了`access denied` 的错误信息，请参照 [Error: Permission denied (publickey)](https://help.github.com/articles/error-permission-denied-publickey) 以及 [read these instructions for diagnosing the issue](https://help.github.com/articles/error-permission-denied-publickey) 进行修复。\n\n### 2 Hexo本地建站\n\n---\n\n#### 2.1 hexo安装\n\nhexo是基于node.js且在博客部署的时候需要Git命令操作的，所以在安装hexo之前，需要先安装[node.js](https://nodejs.org/en/) 和[Git](https://git-scm.com/download/win) 。\n\n完成上述两者的安装后，打开Git Bash，执行以下命令即可完成hexo的安装：\n\n```\nnpm install -g hexo-cli\n```\n\n#### 2.2 hexo站点建立\n\n- **1. 确定博客本地站点的位置：** \n\n  ~~选择一个位置，作为今后博客本地站点文件的存放位置， 在该位置建立名为`<your_githubname>.github.io` 的文件夹，`<your_githubname>.github.io` 也就是之前在Github上创建的仓库名~~ \n\n  由于我想要建立的是一个可以实现多机更新的博客，所以应该将hexo站点建立在**本地的Github仓库**中，这样在一台机器上配置好的主题和配置文件就可以随时上传到**Github远程仓库**中保存。如果希望在其他机器上建立hexo站点，在安装Git的基础上，可以先将之前保存在Github远程仓库中的hexo站点文件**克隆**到本地，形成Github本地仓库，然后在本地仓库中安装hexo即可使用，不需要重复配置。\n\n  同时，由于我们的博客静态网页是发布在远程仓库的`master` 分支，即主分支上，所以我们需要在`master` 分支的基础上，**新建一个分支**，命名随意，我这里记为`hexo-files` ，用于保存推送上来的hexo站点文件，同时在Github中将`hexo-files` 分支设置为当前仓库的**默认分支**，这样可以方便将本地仓库的文件推送到远端仓库中。\n\n  综上，在上文[创建Github远端新仓库](#create-repo) 以及新建并设置默认分支为`hexo-files` 的基础上，将这个新仓库**克隆**到本地，从而建立本地的Github仓库：\n\n  ```\n  # 切换到在你希望建立Github本地仓库的路径下\n  git clone git@github.com:<your_githubname>/<your_githubname>.github.io.git\n  ```\n\n  上述命令会自动创建一个名为`<your_githubname>.github.io` 的文件夹，并将远程仓库中的文件都放到这个文件夹中。同时，可以发现文件夹中有一个名为`.git` 的文件夹，这个文件夹保存了有关Github本地仓库的信息以及本地仓库与远程仓库的连接信息，也就是能将`<your_githubname>.github.io` 文件夹中内容推送到远程仓库中的关键。\n\n  **注** ：由于后续建站的时候，`hexo init` 命令初始化时，会将`.git` 文件夹覆盖，所以在这一步结束的时候，需要先将`.git` 文件夹保存起来，等待下一步`hexo init` 之后再复制进来。\n\n- **2. 建站：**\n\n  进入站点文件夹`<your_githubname>.github.io` 内，依次执行以下两条命令，完成hexo站点的建立：\n\n  ```\n  hexo init\n  npm install\n  ```\n\n  **注** ：记得将`.git` 文件夹复制到`<your_githubname>.github.io` 中。\n\n  此时，在Git Bash中进入`<your_githubname>.github.io` 目录下，可以看到当前所处Github分支是`hexo-files` ，如果不是，请返回上一步，设置好默认分支，再克隆远程仓库到本地。\n\n  完成后，站点文件夹内的目录结构大致如下：\n\n  ```\n  .\n  ├── .git\n  ├── _config.yml\n  ├── package.json\n  ├── node_modules\n  ├── scaffolds\n  ├── source\n  |   └── _posts\n  └── themes\n  ```\n\n  各文件和文件夹的含义大致为：\n\n  - `_config.yml` ，存放站点的配置信息，比如站点主题、站点名、站点菜单、站点链接以及第三方插件等等；\n\n  - `package.json` ，存放插件信息，可以查看安装了哪些插件；\n\n  - `node_modules` ，存放站点主题相关的样式文件；\n\n  - `scaffolds` ，模板文件，生成静态网页时，hexo会将Markdown文件中`---` 以上的部分对比模板文件，然后生成新的静态网页文件；\n\n  - `source` ，存放用户写好的Markdown文件，想要生成静态网页的Markdown文件写好之后，就可以放在`_post` 文件夹下。除了`_post` 文件夹，其他以`_` 开头的文件夹都会被忽略，而且，只有将Markdown文件放在`_post` 文件夹下，生成之后才会具有完整的主题样式。\n\n    当然，如果想在网页上创建类似于`About` 的更多菜单选项，可以在`source` 文件夹下新建更多的文件夹，并在其中添加Markdown文件，当然，这些文件生成静态网页后不会具有完整主题样式，只能手动调整。\n\n  - `themes` ，存放主题文件。\n\n  **注** ：由于默认的NPM镜像有时候会很慢，在这时候可以将默认的源切换到淘宝镜像：\n\n  ```\n  npm config set registry \"https://registry.npm.taobao.org\"\n  ```\n\n#### 2.3 hexo站点配置\n\n站点大部分的配置都可以通过`_config.yml` 文件实现，具体各个部分的含义可以参考[Hexo-配置](https://hexo.io/zh-cn/docs/configuration.html) 。\n\n#### 2.4 hexo新内容生成\n\n将一篇写好的Markdown文件放入`_post` 文件夹中（如果你还不知道怎么写，可以先参照和使用文件夹中已有的一个示例），关于如何写一篇Markdown文章，推荐使用[Typora](https://typora.io/) Markdown编辑器，关于Markdown语法，推荐[Typora For Markdown 语法](http://www.jianshu.com/p/092de536d948) ，当然也可以自行搜索。\n\n将Markdown文件生成静态网页文件，执行以下命令之后，会产生一个`public` 文件夹，其中包含的就是所生成的静态网页文件和样式：\n\n``` \nhexo generate\n# 或者简化为 hexo g\n```\n\n启动hexo本地服务器，然后在浏览器中输入`http://localhost:4000/` ，就可以在本地预览新生成的网页：\n\n```\nhexo server\n```\n\n需要注意的是，单纯写一篇文章，生成之后只会在网页显示一部分，如果要阅读全文或者支持文章分类，必须在文章开头添加[Front-matter](https://hexo.io/zh-cn/docs/front-matter.html) ，如下所示：\n\n```\ntitle: Hexo\ndate: 2017/02/27 00:00:00\ncategories:\n- Study\ntags:\n- Hexo\n- Github\n---\nHello World.\n```\n\n#### 2.5 hexo主题更换\n\nhexo的主题很多，可以访问[Themes|Hexo](https://hexo.io/themes/) 选取。\n\n以下将以[Noise](https://github.com/lotabout/hexo-theme-noise) 主题为例，讲解一下主题的更换。\n\n- 找到主题的Github主页，主页上一般都会有安装的步骤和使用教程；\n- 将主题的代码克隆到`/themes` 文件夹下，并安装主题和主题渲染器：\n\n```\ngit clone https://github.com/lotabout/hexo-theme-noise themes/noise\nnpm install hexo-renderer-less --save\nnpm install hexo-renderer-jade --save\n```\n\n- 修改配置文档`_config.yml` ，将`theme` 的值由`landscape` 修改为`noise` 。\n- 重新执行一遍生成操作即可预览:\n\n```\nhexo clean\nhexo generate\nhexo server\n```\n\n#### 2.6 小结\n\n以上就完成了hexo的本地建站工作，如果只想在本地玩玩，到这里就完成了，日常的工作就是写写Markdown文章，然后在站点目录下依次执行以下命令即可：\n\n```\nhexo generate\nhexo server\n# visit http://localhost:4000/\n```\n\nPS. 顺便总结一下不问原因的、从零开始的快速建站方法：\n\n```\n# install node.js and git\nnpm install -g hexo-cli\n# choose a path and clone <your_githubname>.github.io.git to local dir\ngit clone git@github.com:<your_githubname>/<your_githubname>.github.io.git\ncd <your_githubname>.github.io\n# 先将 .git 文件夹复制\nhexo init\n# 再将 .git 文件夹粘贴进来\nnpm install\n# write a markdown file and put it into /source/_post/\nhexo generate\nhexo server\n```\n\n### 3 hexo部署到Github\n\n---\n\n- 安装插件：\n\n```\nnpm install hexo-deployer-git --save\n```\n\n- 修改配置文件`_config.yml` ：\n\n```\ndeploy:\n  type: git\n  repo:  https://github.com/<your_githubname>/<your_name>.github.io.git\n  branch: master\n# branch: master 意思是，部署的时候选择master分支发布\n```\n\n​\t**注 ：配置文件中冒号后面一定要空一格** \n\n- 将hexo站点文件推送到远程仓库中，并将生成的静态网页部署到Github Pages：\n\n```\ngit add .\ngit commit -m \"注释\"\ngit push origin hexo-files # 意思是，将本地仓库hexo-files分支的内容推送到名为origin的远程仓库的默认分支中\n# 生成静态网页并部署到Github上\nhexo generate\nhexo deploy\n# 或者简化  hexo g -d\n```\n\n​\t有时候会跳出一个窗口，输入Github账号和密码即可。\n\n- 登录`https://<your_githubname>.github.io` ，查看部署完成的博客内容。\n\n**注** ：我还没有出现过部署不成功的情况，如果有，请查看[hexo部署后没动静，咋办](http://lowrank.science/Hexo-Github/) 。\n\n### 4 hexo博客更新以及多机更新流程\n\n---\n\n- **Status1** ：如果上一次更新时使用的就是当前的机器，那么只需要将新完成的Markdown文件放入`_post` 文件夹内，按照情况执行以下命令即可：\n\n```\n# 本地预览时\nhexo generate\nhexo server\n# 确定完成，需要推送&发布\nhexo clean # 清理一下减少推送的数据量\ngit add .\ngit commit -m \"注释\"\ngit push origin hexo-files\nhexo g -d\n```\n\n- **Status2** ：如果上一次更新时使用的不是当前机器，那么首先需要确定当前机器已经[建立了Github与本地的连接](#create-githublink) 并且已经安装了node.js和Git，之后根据情况执行以下命令：\n\n```\n# 创建本地仓库\ngit clone git@github.com:<your_githubname>/<your_githubname>.github.io.git\ncd <your_githubname>.github.io\n# 若当前机器是第一次用于编写发布博客，则需要安装hexo\nnpm install -g hexo-cli\n# 否则，从这里开始\nnpm install hexo \nnpm install\nnpm install hexo-deployer-git --save\n# npm install hexo-renderer-less --save\n# npm install hexo-renderer-jade --save\n# 之后，就可以按照上述的 Status1 推送和发布博客了\n```\n\n### 5 总结\n\n本文介绍了Hexo+Github Pages博客的建立方法和过程，以及如何实现多机更新Github博客的原理和方法。\n\n总的来说，如果是第一次搭建Github博客，要学习的东西还是蛮多的，如果不明白其中的道理，加上网上零零散散不完全的教程，经常会绕到死胡同里。其中，我认为掌握Github**仓库**和**分支**的概念是很重要的，当然这也是学习Github中很重要的两个知识点。\n\n在简单学习Github之后，我又萌生了将未完成的Markdown文件存储在Github远程仓库上的想法，这样未编写完成的Markdown文章就可以在不同机器上抓取并编写，然后推送共享，随时随地编写文章，直到完成。这对于我一个经常在实验室和宿舍两头跑的学生来说，是一件挺方便的事情。\n\n之后的工作......应该是系统地学习Github，了解Github上更多有趣的东西吧，先放个链接吧，[如何使用Github](https://www.zhihu.com/question/20070065) 以及[Github上有趣的项目](https://www.zhihu.com/question/23498424)。","slug":"git-multiSync","published":1,"updated":"2017-02-26T11:48:59.673Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizmml95f0002qkupm3psys2p","content":"<h3 id=\"0-前言\"><a href=\"#0-前言\" class=\"headerlink\" title=\"0 前言\"></a>0 前言</h3><hr>\n<p>本篇博文主要介绍在Windows 10系统上创建Github Pages+hexo博客的过程，同时，考虑到可能会在不同地点使用不同机器进行博客的更新操作，所以本篇博文还会介绍如何实现多台机器更新博客内容的方法，主要涉及的名词有：</p>\n<ul>\n<li><p>Github与Github Pages</p>\n<p><a href=\"https://github.com/\" target=\"_blank\" rel=\"external\">Github</a> 是一个面向开源以及私有软件项目的托管平台，简单来说就是一个远程仓库，注册账号以后可以在Github上存放软件代码，当然也可以存放文件，但是要注意的是，免费使用的情况下，你的Github是开放的，也就是所有人都可以看到你的仓库里存放了什么，如果想要加密则需要付费。</p>\n<p>Github Pages则是在Github上搭建的博客或者网页，网页地址都是 <code>&lt;your_githubname&gt;.github.io</code> 。既然Github可以存放软件代码，那当然也可以存放博客文章以及网页需要的HTML/CSS/JS文件，从而Github Pages以Github仓库作为网页服务器，向外界提供一个可以访问的静态网页。</p>\n</li>\n<li><p>Markdown</p>\n<p><a href=\"http://sspai.com/25137/\" target=\"_blank\" rel=\"external\">Markdown</a> 是一种用于写作的轻量级标记语言，虽然不像Word那样拥有大量的排版和字体设置，可以排版出一篇或精美或专业的文章，但是Markdown中简单的标记字符易于使用和记忆，甚至可以完成脱离鼠标，单单使用键盘就可以完成一篇文章的书写以及简洁精致的排版，这让使用者可以更加专心的码字，而不是过多地在意繁琐的排版工作。</p>\n<p>Markdown有很多相关的编辑器，这里强烈推荐<a href=\"https://typora.io/\" target=\"_blank\" rel=\"external\">Typora</a> 。</p>\n<p><em>有关Markdown编辑器的介绍和分析，请见另一篇博文《Typora——Markdown编辑界的极简主义》</em> </p>\n</li>\n<li><p>hexo</p>\n<p><a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">hexo</a> 是一款基于<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"external\">node.js</a> 、开源的静态博客生成器。所谓“静态”，指的是所生成的博客网页本身只能提供浏览，而不能提交信息（当然，如果嵌入第三方插件，则可以通过插件提交信息，这是后话…）。hexo将书写好的Markdown文件根据选定的hexo主题转换成一堆HTML/CSS/JS文件，并支持本地预览网页，如果觉得没有问题，hexo还提供部署的功能，将网页文件上传到Github中，之后就可以通过访问Github Pages看到已发布的博客网页。</p>\n</li>\n<li><p>Git</p>\n<p><a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"external\">Git</a> 是一种开源的分布式版本管理系统，Github是Git发展壮大之后的产物，只支持Git作为唯一的版本库格式进行托管。</p>\n<p><em>有关Git的命令操作，请见另一篇文章《Git Study》</em></p>\n</li>\n</ul>\n<h3 id=\"1-创建Github-Pages并建立Github与本地的连接\"><a href=\"#1-创建Github-Pages并建立Github与本地的连接\" class=\"headerlink\" title=\"1 创建Github Pages并建立Github与本地的连接\"></a>1 创建Github Pages并建立Github与本地的连接</h3><hr>\n<h4 id=\"1-1-注册Github并创建一个新仓库（Repository）\"><a href=\"#1-1-注册Github并创建一个新仓库（Repository）\" class=\"headerlink\" title=\"1.1 注册Github并创建一个新仓库（Repository）\"></a>1.1 注册Github并创建一个新仓库（Repository）</h4><p>登录Github网站并注册账号成功之后，可以按照<span id=\"create-repo\"></span><a href=\"https://help.github.com/articles/create-a-repo/#create-a-new-repository-on-github\" target=\"_blank\" rel=\"external\">Create a new repository on GitHub</a> 的官方教程，一步一步地创建一个新的仓库，需要注意的只有一点：即因为我们这里是为了创建Github Pages博客的仓库，所以Repository name一定要是<code>&lt;your_githubname&gt;.github.io</code> 的形式。</p>\n<h4 id=\"1-2-建立Github与本地的连接（Authenticating）\"><a href=\"#1-2-建立Github与本地的连接（Authenticating）\" class=\"headerlink\" title=\"1.2 建立Github与本地的连接（Authenticating）\"></a>1.2 建立Github与本地的连接（Authenticating）</h4><p>为了能够将本地的博客内容提交到远端的Github仓库中，需要建立本地与Github仓库的连接<span id=\"create-githublink\"></span>，即要让本地通过Github的身份验证（Authenticating）。考虑到Git默认使用SSH协议，所以我们使用SSH协议建立本地与Github之间的连接，参照<a href=\"https://help.github.com/articles/connecting-to-github-with-ssh/\" target=\"_blank\" rel=\"external\">Connecting to GitHub with SSH</a> 。<em>（以下命令需要安装Git，并在Git Bash中完成输入）</em> </p>\n<p>当然也可以使用HTTPS建立连接，具体可以参照<a href=\"https://help.github.com/articles/set-up-git/#next-steps-authenticating-with-github-from-git\" target=\"_blank\" rel=\"external\">Authenticating with GitHub from Git</a> 并做进一步的阅读。</p>\n<h5 id=\"1-2-1-本地生成新的SSH-Key\"><a href=\"#1-2-1-本地生成新的SSH-Key\" class=\"headerlink\" title=\"1.2.1 本地生成新的SSH Key\"></a>1.2.1 本地生成新的SSH Key</h5><ul>\n<li><p>执行以下命令，输入你注册Github时使用的邮箱：</p>\n<p> <code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code> </p>\n</li>\n<li><p>出现以下提示的时候，说明已经使用你的邮箱生成了一个新的SSH Key：</p>\n<p><code>Generating public/private rsa key pair.</code> </p>\n</li>\n<li><p>随后会出现以下提示，如果你对保存SSH Key的位置没有特殊的要求时，可以直接回车选择默认保存位置进行SSH Key的保存，保存的位置就是括号中所示的位置（根据实际系统有所不同）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Enter a file in which to save the key (/Users/you/.ssh/id_rsa):[Press enter]</div></pre></td></tr></table></figure>\n</li>\n<li><p>接下来，需要为你的SSH Key输入密码，当然也可以选择不要密码，直接两个回车就可以了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Enter passphrase (empty for no passphrase): [Type a passphrase]</div><div class=\"line\">Enter same passphrase again: [Type passphrase again]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>注</strong> ：如果你之前就有SSH Key，那么你可以检查一下是不是有合适的SSH Key可以使用：<code>ls -al ~/.ssh</code> </p>\n<h5 id=\"1-2-2-将SSH-Key加入ssh-agent\"><a href=\"#1-2-2-将SSH-Key加入ssh-agent\" class=\"headerlink\" title=\"1.2.2 将SSH Key加入ssh-agent\"></a>1.2.2 将SSH Key加入ssh-agent</h5><ul>\n<li><p>确定ssh-agent正在运行，执行以下命令开启ssh-agent：</p>\n<p><code>eval $(ssh-agent -s)</code> </p>\n</li>\n<li><p>将SSH Key添加到ssh-agent中：</p>\n<p><code>ssh-add ~/.ssh/id_rsa</code> </p>\n</li>\n</ul>\n<h5 id=\"1-2-3-将SSH-Key添加到Github账号中\"><a href=\"#1-2-3-将SSH-Key添加到Github账号中\" class=\"headerlink\" title=\"1.2.3 将SSH Key添加到Github账号中\"></a>1.2.3 将SSH Key添加到Github账号中</h5><ul>\n<li><p>将SSH Key复制到粘贴板：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clip &lt; ~/.ssh/id_rsa.pub</div></pre></td></tr></table></figure>\n</li>\n<li><p>登录Github，点击右上方的头像，在下拉菜单中选择<strong>Setting</strong> ，然后<strong>SSH and GPG keys</strong> —— <strong>New SSH Key</strong> 或者<strong>Add SSH Key</strong> ，在”Title”里输入你想要的名称，然后在下方的“Key”文本框内添加刚才复制的SSH Key，最后点击<strong>Add SSH Key</strong> ，密码验证一下就好。</p>\n</li>\n</ul>\n<h5 id=\"1-2-4-测试一下SSH连接是否成功\"><a href=\"#1-2-4-测试一下SSH连接是否成功\" class=\"headerlink\" title=\"1.2.4 测试一下SSH连接是否成功\"></a>1.2.4 测试一下SSH连接是否成功</h5><ul>\n<li><p>执行以下命令：</p>\n<p><code>ssh -T git@github.com</code> </p>\n<p>若输出以下两则信息中的一种，且其中一种是你的签名信息，那么输入<code>yes</code> 并回车即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">The authenticity of host &apos;github.com (192.30.252.1)&apos; can&apos;t be established.</div><div class=\"line\">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</div><div class=\"line\">Are you sure you want to continue connecting (yes/no)?</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">The authenticity of host &apos;github.com (192.30.252.1)&apos; can&apos;t be established.</div><div class=\"line\">RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</div><div class=\"line\">Are you sure you want to continue connecting (yes/no)?</div></pre></td></tr></table></figure>\n</li>\n<li><p>之后就可以看到验证成功的消息，确认其中有你的用户名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Hi &lt;username&gt;! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</div></pre></td></tr></table></figure>\n<p>如果出现了<code>access denied</code> 的错误信息，请参照 <a href=\"https://help.github.com/articles/error-permission-denied-publickey\" target=\"_blank\" rel=\"external\">Error: Permission denied (publickey)</a> 以及 <a href=\"https://help.github.com/articles/error-permission-denied-publickey\" target=\"_blank\" rel=\"external\">read these instructions for diagnosing the issue</a> 进行修复。</p>\n</li>\n</ul>\n<h3 id=\"2-Hexo本地建站\"><a href=\"#2-Hexo本地建站\" class=\"headerlink\" title=\"2 Hexo本地建站\"></a>2 Hexo本地建站</h3><hr>\n<h4 id=\"2-1-hexo安装\"><a href=\"#2-1-hexo安装\" class=\"headerlink\" title=\"2.1 hexo安装\"></a>2.1 hexo安装</h4><p>hexo是基于node.js且在博客部署的时候需要Git命令操作的，所以在安装hexo之前，需要先安装<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"external\">node.js</a> 和<a href=\"https://git-scm.com/download/win\" target=\"_blank\" rel=\"external\">Git</a> 。</p>\n<p>完成上述两者的安装后，打开Git Bash，执行以下命令即可完成hexo的安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g hexo-cli</div></pre></td></tr></table></figure>\n<h4 id=\"2-2-hexo站点建立\"><a href=\"#2-2-hexo站点建立\" class=\"headerlink\" title=\"2.2 hexo站点建立\"></a>2.2 hexo站点建立</h4><ul>\n<li><p><strong>1. 确定博客本地站点的位置：</strong> </p>\n<p><del>选择一个位置，作为今后博客本地站点文件的存放位置， 在该位置建立名为<code>&lt;your_githubname&gt;.github.io</code> 的文件夹，<code>&lt;your_githubname&gt;.github.io</code> 也就是之前在Github上创建的仓库名</del> </p>\n<p>由于我想要建立的是一个可以实现多机更新的博客，所以应该将hexo站点建立在<strong>本地的Github仓库</strong>中，这样在一台机器上配置好的主题和配置文件就可以随时上传到<strong>Github远程仓库</strong>中保存。如果希望在其他机器上建立hexo站点，在安装Git的基础上，可以先将之前保存在Github远程仓库中的hexo站点文件<strong>克隆</strong>到本地，形成Github本地仓库，然后在本地仓库中安装hexo即可使用，不需要重复配置。</p>\n<p>同时，由于我们的博客静态网页是发布在远程仓库的<code>master</code> 分支，即主分支上，所以我们需要在<code>master</code> 分支的基础上，<strong>新建一个分支</strong>，命名随意，我这里记为<code>hexo-files</code> ，用于保存推送上来的hexo站点文件，同时在Github中将<code>hexo-files</code> 分支设置为当前仓库的<strong>默认分支</strong>，这样可以方便将本地仓库的文件推送到远端仓库中。</p>\n<p>综上，在上文<a href=\"#create-repo\">创建Github远端新仓库</a> 以及新建并设置默认分支为<code>hexo-files</code> 的基础上，将这个新仓库<strong>克隆</strong>到本地，从而建立本地的Github仓库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 切换到在你希望建立Github本地仓库的路径下</div><div class=\"line\">git clone git@github.com:&lt;your_githubname&gt;/&lt;your_githubname&gt;.github.io.git</div></pre></td></tr></table></figure>\n<p>上述命令会自动创建一个名为<code>&lt;your_githubname&gt;.github.io</code> 的文件夹，并将远程仓库中的文件都放到这个文件夹中。同时，可以发现文件夹中有一个名为<code>.git</code> 的文件夹，这个文件夹保存了有关Github本地仓库的信息以及本地仓库与远程仓库的连接信息，也就是能将<code>&lt;your_githubname&gt;.github.io</code> 文件夹中内容推送到远程仓库中的关键。</p>\n<p><strong>注</strong> ：由于后续建站的时候，<code>hexo init</code> 命令初始化时，会将<code>.git</code> 文件夹覆盖，所以在这一步结束的时候，需要先将<code>.git</code> 文件夹保存起来，等待下一步<code>hexo init</code> 之后再复制进来。</p>\n</li>\n<li><p><strong>2. 建站：</strong></p>\n<p>进入站点文件夹<code>&lt;your_githubname&gt;.github.io</code> 内，依次执行以下两条命令，完成hexo站点的建立：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init</div><div class=\"line\">npm install</div></pre></td></tr></table></figure>\n<p><strong>注</strong> ：记得将<code>.git</code> 文件夹复制到<code>&lt;your_githubname&gt;.github.io</code> 中。</p>\n<p>此时，在Git Bash中进入<code>&lt;your_githubname&gt;.github.io</code> 目录下，可以看到当前所处Github分支是<code>hexo-files</code> ，如果不是，请返回上一步，设置好默认分支，再克隆远程仓库到本地。</p>\n<p>完成后，站点文件夹内的目录结构大致如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── .git</div><div class=\"line\">├── _config.yml</div><div class=\"line\">├── package.json</div><div class=\"line\">├── node_modules</div><div class=\"line\">├── scaffolds</div><div class=\"line\">├── source</div><div class=\"line\">|   └── _posts</div><div class=\"line\">└── themes</div></pre></td></tr></table></figure>\n<p>各文件和文件夹的含义大致为：</p>\n<ul>\n<li><p><code>_config.yml</code> ，存放站点的配置信息，比如站点主题、站点名、站点菜单、站点链接以及第三方插件等等；</p>\n</li>\n<li><p><code>package.json</code> ，存放插件信息，可以查看安装了哪些插件；</p>\n</li>\n<li><p><code>node_modules</code> ，存放站点主题相关的样式文件；</p>\n</li>\n<li><p><code>scaffolds</code> ，模板文件，生成静态网页时，hexo会将Markdown文件中<code>---</code> 以上的部分对比模板文件，然后生成新的静态网页文件；</p>\n</li>\n<li><p><code>source</code> ，存放用户写好的Markdown文件，想要生成静态网页的Markdown文件写好之后，就可以放在<code>_post</code> 文件夹下。除了<code>_post</code> 文件夹，其他以<code>_</code> 开头的文件夹都会被忽略，而且，只有将Markdown文件放在<code>_post</code> 文件夹下，生成之后才会具有完整的主题样式。</p>\n<p>当然，如果想在网页上创建类似于<code>About</code> 的更多菜单选项，可以在<code>source</code> 文件夹下新建更多的文件夹，并在其中添加Markdown文件，当然，这些文件生成静态网页后不会具有完整主题样式，只能手动调整。</p>\n</li>\n<li><p><code>themes</code> ，存放主题文件。</p>\n</li>\n</ul>\n<p><strong>注</strong> ：由于默认的NPM镜像有时候会很慢，在这时候可以将默认的源切换到淘宝镜像：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm config set registry &quot;https://registry.npm.taobao.org&quot;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-3-hexo站点配置\"><a href=\"#2-3-hexo站点配置\" class=\"headerlink\" title=\"2.3 hexo站点配置\"></a>2.3 hexo站点配置</h4><p>站点大部分的配置都可以通过<code>_config.yml</code> 文件实现，具体各个部分的含义可以参考<a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"external\">Hexo-配置</a> 。</p>\n<h4 id=\"2-4-hexo新内容生成\"><a href=\"#2-4-hexo新内容生成\" class=\"headerlink\" title=\"2.4 hexo新内容生成\"></a>2.4 hexo新内容生成</h4><p>将一篇写好的Markdown文件放入<code>_post</code> 文件夹中（如果你还不知道怎么写，可以先参照和使用文件夹中已有的一个示例），关于如何写一篇Markdown文章，推荐使用<a href=\"https://typora.io/\" target=\"_blank\" rel=\"external\">Typora</a> Markdown编辑器，关于Markdown语法，推荐<a href=\"http://www.jianshu.com/p/092de536d948\" target=\"_blank\" rel=\"external\">Typora For Markdown 语法</a> ，当然也可以自行搜索。</p>\n<p>将Markdown文件生成静态网页文件，执行以下命令之后，会产生一个<code>public</code> 文件夹，其中包含的就是所生成的静态网页文件和样式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate</div><div class=\"line\"># 或者简化为 hexo g</div></pre></td></tr></table></figure>\n<p>启动hexo本地服务器，然后在浏览器中输入<code>http://localhost:4000/</code> ，就可以在本地预览新生成的网页：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo server</div></pre></td></tr></table></figure>\n<p>需要注意的是，单纯写一篇文章，生成之后只会在网页显示一部分，如果要阅读全文或者支持文章分类，必须在文章开头添加<a href=\"https://hexo.io/zh-cn/docs/front-matter.html\" target=\"_blank\" rel=\"external\">Front-matter</a> ，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">title: Hexo</div><div class=\"line\">date: 2017/02/27 00:00:00</div><div class=\"line\">categories:</div><div class=\"line\">- Study</div><div class=\"line\">tags:</div><div class=\"line\">- Hexo</div><div class=\"line\">- Github</div><div class=\"line\">---</div><div class=\"line\">Hello World.</div></pre></td></tr></table></figure>\n<h4 id=\"2-5-hexo主题更换\"><a href=\"#2-5-hexo主题更换\" class=\"headerlink\" title=\"2.5 hexo主题更换\"></a>2.5 hexo主题更换</h4><p>hexo的主题很多，可以访问<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"external\">Themes|Hexo</a> 选取。</p>\n<p>以下将以<a href=\"https://github.com/lotabout/hexo-theme-noise\" target=\"_blank\" rel=\"external\">Noise</a> 主题为例，讲解一下主题的更换。</p>\n<ul>\n<li>找到主题的Github主页，主页上一般都会有安装的步骤和使用教程；</li>\n<li>将主题的代码克隆到<code>/themes</code> 文件夹下，并安装主题和主题渲染器：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone https://github.com/lotabout/hexo-theme-noise themes/noise</div><div class=\"line\">npm install hexo-renderer-less --save</div><div class=\"line\">npm install hexo-renderer-jade --save</div></pre></td></tr></table></figure>\n<ul>\n<li>修改配置文档<code>_config.yml</code> ，将<code>theme</code> 的值由<code>landscape</code> 修改为<code>noise</code> 。</li>\n<li>重新执行一遍生成操作即可预览:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo clean</div><div class=\"line\">hexo generate</div><div class=\"line\">hexo server</div></pre></td></tr></table></figure>\n<h4 id=\"2-6-小结\"><a href=\"#2-6-小结\" class=\"headerlink\" title=\"2.6 小结\"></a>2.6 小结</h4><p>以上就完成了hexo的本地建站工作，如果只想在本地玩玩，到这里就完成了，日常的工作就是写写Markdown文章，然后在站点目录下依次执行以下命令即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate</div><div class=\"line\">hexo server</div><div class=\"line\"># visit http://localhost:4000/</div></pre></td></tr></table></figure>\n<p>PS. 顺便总结一下不问原因的、从零开始的快速建站方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"># install node.js and git</div><div class=\"line\">npm install -g hexo-cli</div><div class=\"line\"># choose a path and clone &lt;your_githubname&gt;.github.io.git to local dir</div><div class=\"line\">git clone git@github.com:&lt;your_githubname&gt;/&lt;your_githubname&gt;.github.io.git</div><div class=\"line\">cd &lt;your_githubname&gt;.github.io</div><div class=\"line\"># 先将 .git 文件夹复制</div><div class=\"line\">hexo init</div><div class=\"line\"># 再将 .git 文件夹粘贴进来</div><div class=\"line\">npm install</div><div class=\"line\"># write a markdown file and put it into /source/_post/</div><div class=\"line\">hexo generate</div><div class=\"line\">hexo server</div></pre></td></tr></table></figure>\n<h3 id=\"3-hexo部署到Github\"><a href=\"#3-hexo部署到Github\" class=\"headerlink\" title=\"3 hexo部署到Github\"></a>3 hexo部署到Github</h3><hr>\n<ul>\n<li>安装插件：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>\n<ul>\n<li>修改配置文件<code>_config.yml</code> ：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repo:  https://github.com/&lt;your_githubname&gt;/&lt;your_name&gt;.github.io.git</div><div class=\"line\">  branch: master</div><div class=\"line\"># branch: master 意思是，部署的时候选择master分支发布</div></pre></td></tr></table></figure>\n<p>​    <strong>注 ：配置文件中冒号后面一定要空一格</strong> </p>\n<ul>\n<li>将hexo站点文件推送到远程仓库中，并将生成的静态网页部署到Github Pages：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">git add .</div><div class=\"line\">git commit -m &quot;注释&quot;</div><div class=\"line\">git push origin hexo-files # 意思是，将本地仓库hexo-files分支的内容推送到名为origin的远程仓库的默认分支中</div><div class=\"line\"># 生成静态网页并部署到Github上</div><div class=\"line\">hexo generate</div><div class=\"line\">hexo deploy</div><div class=\"line\"># 或者简化  hexo g -d</div></pre></td></tr></table></figure>\n<p>​    有时候会跳出一个窗口，输入Github账号和密码即可。</p>\n<ul>\n<li>登录<code>https://&lt;your_githubname&gt;.github.io</code> ，查看部署完成的博客内容。</li>\n</ul>\n<p><strong>注</strong> ：我还没有出现过部署不成功的情况，如果有，请查看<a href=\"http://lowrank.science/Hexo-Github/\" target=\"_blank\" rel=\"external\">hexo部署后没动静，咋办</a> 。</p>\n<h3 id=\"4-hexo博客更新以及多机更新流程\"><a href=\"#4-hexo博客更新以及多机更新流程\" class=\"headerlink\" title=\"4 hexo博客更新以及多机更新流程\"></a>4 hexo博客更新以及多机更新流程</h3><hr>\n<ul>\n<li><strong>Status1</strong> ：如果上一次更新时使用的就是当前的机器，那么只需要将新完成的Markdown文件放入<code>_post</code> 文件夹内，按照情况执行以下命令即可：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 本地预览时</div><div class=\"line\">hexo generate</div><div class=\"line\">hexo server</div><div class=\"line\"># 确定完成，需要推送&amp;发布</div><div class=\"line\">hexo clean # 清理一下减少推送的数据量</div><div class=\"line\">git add .</div><div class=\"line\">git commit -m &quot;注释&quot;</div><div class=\"line\">git push origin hexo-files</div><div class=\"line\">hexo g -d</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>Status2</strong> ：如果上一次更新时使用的不是当前机器，那么首先需要确定当前机器已经<a href=\"#create-githublink\">建立了Github与本地的连接</a> 并且已经安装了node.js和Git，之后根据情况执行以下命令：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 创建本地仓库</div><div class=\"line\">git clone git@github.com:&lt;your_githubname&gt;/&lt;your_githubname&gt;.github.io.git</div><div class=\"line\">cd &lt;your_githubname&gt;.github.io</div><div class=\"line\"># 若当前机器是第一次用于编写发布博客，则需要安装hexo</div><div class=\"line\">npm install -g hexo-cli</div><div class=\"line\"># 否则，从这里开始</div><div class=\"line\">npm install hexo </div><div class=\"line\">npm install</div><div class=\"line\">npm install hexo-deployer-git --save</div><div class=\"line\"># npm install hexo-renderer-less --save</div><div class=\"line\"># npm install hexo-renderer-jade --save</div><div class=\"line\"># 之后，就可以按照上述的 Status1 推送和发布博客了</div></pre></td></tr></table></figure>\n<h3 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5 总结\"></a>5 总结</h3><p>本文介绍了Hexo+Github Pages博客的建立方法和过程，以及如何实现多机更新Github博客的原理和方法。</p>\n<p>总的来说，如果是第一次搭建Github博客，要学习的东西还是蛮多的，如果不明白其中的道理，加上网上零零散散不完全的教程，经常会绕到死胡同里。其中，我认为掌握Github<strong>仓库</strong>和<strong>分支</strong>的概念是很重要的，当然这也是学习Github中很重要的两个知识点。</p>\n<p>在简单学习Github之后，我又萌生了将未完成的Markdown文件存储在Github远程仓库上的想法，这样未编写完成的Markdown文章就可以在不同机器上抓取并编写，然后推送共享，随时随地编写文章，直到完成。这对于我一个经常在实验室和宿舍两头跑的学生来说，是一件挺方便的事情。</p>\n<p>之后的工作……应该是系统地学习Github，了解Github上更多有趣的东西吧，先放个链接吧，<a href=\"https://www.zhihu.com/question/20070065\" target=\"_blank\" rel=\"external\">如何使用Github</a> 以及<a href=\"https://www.zhihu.com/question/23498424\" target=\"_blank\" rel=\"external\">Github上有趣的项目</a>。</p>\n","excerpt":"","more":"<h3 id=\"0-前言\"><a href=\"#0-前言\" class=\"headerlink\" title=\"0 前言\"></a>0 前言</h3><hr>\n<p>本篇博文主要介绍在Windows 10系统上创建Github Pages+hexo博客的过程，同时，考虑到可能会在不同地点使用不同机器进行博客的更新操作，所以本篇博文还会介绍如何实现多台机器更新博客内容的方法，主要涉及的名词有：</p>\n<ul>\n<li><p>Github与Github Pages</p>\n<p><a href=\"https://github.com/\">Github</a> 是一个面向开源以及私有软件项目的托管平台，简单来说就是一个远程仓库，注册账号以后可以在Github上存放软件代码，当然也可以存放文件，但是要注意的是，免费使用的情况下，你的Github是开放的，也就是所有人都可以看到你的仓库里存放了什么，如果想要加密则需要付费。</p>\n<p>Github Pages则是在Github上搭建的博客或者网页，网页地址都是 <code>&lt;your_githubname&gt;.github.io</code> 。既然Github可以存放软件代码，那当然也可以存放博客文章以及网页需要的HTML/CSS/JS文件，从而Github Pages以Github仓库作为网页服务器，向外界提供一个可以访问的静态网页。</p>\n</li>\n<li><p>Markdown</p>\n<p><a href=\"http://sspai.com/25137/\">Markdown</a> 是一种用于写作的轻量级标记语言，虽然不像Word那样拥有大量的排版和字体设置，可以排版出一篇或精美或专业的文章，但是Markdown中简单的标记字符易于使用和记忆，甚至可以完成脱离鼠标，单单使用键盘就可以完成一篇文章的书写以及简洁精致的排版，这让使用者可以更加专心的码字，而不是过多地在意繁琐的排版工作。</p>\n<p>Markdown有很多相关的编辑器，这里强烈推荐<a href=\"https://typora.io/\">Typora</a> 。</p>\n<p><em>有关Markdown编辑器的介绍和分析，请见另一篇博文《Typora——Markdown编辑界的极简主义》</em> </p>\n</li>\n<li><p>hexo</p>\n<p><a href=\"https://hexo.io/\">hexo</a> 是一款基于<a href=\"https://nodejs.org/en/\">node.js</a> 、开源的静态博客生成器。所谓“静态”，指的是所生成的博客网页本身只能提供浏览，而不能提交信息（当然，如果嵌入第三方插件，则可以通过插件提交信息，这是后话…）。hexo将书写好的Markdown文件根据选定的hexo主题转换成一堆HTML/CSS/JS文件，并支持本地预览网页，如果觉得没有问题，hexo还提供部署的功能，将网页文件上传到Github中，之后就可以通过访问Github Pages看到已发布的博客网页。</p>\n</li>\n<li><p>Git</p>\n<p><a href=\"https://git-scm.com/\">Git</a> 是一种开源的分布式版本管理系统，Github是Git发展壮大之后的产物，只支持Git作为唯一的版本库格式进行托管。</p>\n<p><em>有关Git的命令操作，请见另一篇文章《Git Study》</em></p>\n</li>\n</ul>\n<h3 id=\"1-创建Github-Pages并建立Github与本地的连接\"><a href=\"#1-创建Github-Pages并建立Github与本地的连接\" class=\"headerlink\" title=\"1 创建Github Pages并建立Github与本地的连接\"></a>1 创建Github Pages并建立Github与本地的连接</h3><hr>\n<h4 id=\"1-1-注册Github并创建一个新仓库（Repository）\"><a href=\"#1-1-注册Github并创建一个新仓库（Repository）\" class=\"headerlink\" title=\"1.1 注册Github并创建一个新仓库（Repository）\"></a>1.1 注册Github并创建一个新仓库（Repository）</h4><p>登录Github网站并注册账号成功之后，可以按照<span id=\"create-repo\"></span><a href=\"https://help.github.com/articles/create-a-repo/#create-a-new-repository-on-github\">Create a new repository on GitHub</a> 的官方教程，一步一步地创建一个新的仓库，需要注意的只有一点：即因为我们这里是为了创建Github Pages博客的仓库，所以Repository name一定要是<code>&lt;your_githubname&gt;.github.io</code> 的形式。</p>\n<h4 id=\"1-2-建立Github与本地的连接（Authenticating）\"><a href=\"#1-2-建立Github与本地的连接（Authenticating）\" class=\"headerlink\" title=\"1.2 建立Github与本地的连接（Authenticating）\"></a>1.2 建立Github与本地的连接（Authenticating）</h4><p>为了能够将本地的博客内容提交到远端的Github仓库中，需要建立本地与Github仓库的连接<span id=\"create-githublink\"></span>，即要让本地通过Github的身份验证（Authenticating）。考虑到Git默认使用SSH协议，所以我们使用SSH协议建立本地与Github之间的连接，参照<a href=\"https://help.github.com/articles/connecting-to-github-with-ssh/\">Connecting to GitHub with SSH</a> 。<em>（以下命令需要安装Git，并在Git Bash中完成输入）</em> </p>\n<p>当然也可以使用HTTPS建立连接，具体可以参照<a href=\"https://help.github.com/articles/set-up-git/#next-steps-authenticating-with-github-from-git\">Authenticating with GitHub from Git</a> 并做进一步的阅读。</p>\n<h5 id=\"1-2-1-本地生成新的SSH-Key\"><a href=\"#1-2-1-本地生成新的SSH-Key\" class=\"headerlink\" title=\"1.2.1 本地生成新的SSH Key\"></a>1.2.1 本地生成新的SSH Key</h5><ul>\n<li><p>执行以下命令，输入你注册Github时使用的邮箱：</p>\n<p> <code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code> </p>\n</li>\n<li><p>出现以下提示的时候，说明已经使用你的邮箱生成了一个新的SSH Key：</p>\n<p><code>Generating public/private rsa key pair.</code> </p>\n</li>\n<li><p>随后会出现以下提示，如果你对保存SSH Key的位置没有特殊的要求时，可以直接回车选择默认保存位置进行SSH Key的保存，保存的位置就是括号中所示的位置（根据实际系统有所不同）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Enter a file in which to save the key (/Users/you/.ssh/id_rsa):[Press enter]</div></pre></td></tr></table></figure>\n</li>\n<li><p>接下来，需要为你的SSH Key输入密码，当然也可以选择不要密码，直接两个回车就可以了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Enter passphrase (empty for no passphrase): [Type a passphrase]</div><div class=\"line\">Enter same passphrase again: [Type passphrase again]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>注</strong> ：如果你之前就有SSH Key，那么你可以检查一下是不是有合适的SSH Key可以使用：<code>ls -al ~/.ssh</code> </p>\n<h5 id=\"1-2-2-将SSH-Key加入ssh-agent\"><a href=\"#1-2-2-将SSH-Key加入ssh-agent\" class=\"headerlink\" title=\"1.2.2 将SSH Key加入ssh-agent\"></a>1.2.2 将SSH Key加入ssh-agent</h5><ul>\n<li><p>确定ssh-agent正在运行，执行以下命令开启ssh-agent：</p>\n<p><code>eval $(ssh-agent -s)</code> </p>\n</li>\n<li><p>将SSH Key添加到ssh-agent中：</p>\n<p><code>ssh-add ~/.ssh/id_rsa</code> </p>\n</li>\n</ul>\n<h5 id=\"1-2-3-将SSH-Key添加到Github账号中\"><a href=\"#1-2-3-将SSH-Key添加到Github账号中\" class=\"headerlink\" title=\"1.2.3 将SSH Key添加到Github账号中\"></a>1.2.3 将SSH Key添加到Github账号中</h5><ul>\n<li><p>将SSH Key复制到粘贴板：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clip &lt; ~/.ssh/id_rsa.pub</div></pre></td></tr></table></figure>\n</li>\n<li><p>登录Github，点击右上方的头像，在下拉菜单中选择<strong>Setting</strong> ，然后<strong>SSH and GPG keys</strong> —— <strong>New SSH Key</strong> 或者<strong>Add SSH Key</strong> ，在”Title”里输入你想要的名称，然后在下方的“Key”文本框内添加刚才复制的SSH Key，最后点击<strong>Add SSH Key</strong> ，密码验证一下就好。</p>\n</li>\n</ul>\n<h5 id=\"1-2-4-测试一下SSH连接是否成功\"><a href=\"#1-2-4-测试一下SSH连接是否成功\" class=\"headerlink\" title=\"1.2.4 测试一下SSH连接是否成功\"></a>1.2.4 测试一下SSH连接是否成功</h5><ul>\n<li><p>执行以下命令：</p>\n<p><code>ssh -T git@github.com</code> </p>\n<p>若输出以下两则信息中的一种，且其中一种是你的签名信息，那么输入<code>yes</code> 并回车即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">The authenticity of host &apos;github.com (192.30.252.1)&apos; can&apos;t be established.</div><div class=\"line\">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</div><div class=\"line\">Are you sure you want to continue connecting (yes/no)?</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">The authenticity of host &apos;github.com (192.30.252.1)&apos; can&apos;t be established.</div><div class=\"line\">RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</div><div class=\"line\">Are you sure you want to continue connecting (yes/no)?</div></pre></td></tr></table></figure>\n</li>\n<li><p>之后就可以看到验证成功的消息，确认其中有你的用户名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Hi &lt;username&gt;! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</div></pre></td></tr></table></figure>\n<p>如果出现了<code>access denied</code> 的错误信息，请参照 <a href=\"https://help.github.com/articles/error-permission-denied-publickey\">Error: Permission denied (publickey)</a> 以及 <a href=\"https://help.github.com/articles/error-permission-denied-publickey\">read these instructions for diagnosing the issue</a> 进行修复。</p>\n</li>\n</ul>\n<h3 id=\"2-Hexo本地建站\"><a href=\"#2-Hexo本地建站\" class=\"headerlink\" title=\"2 Hexo本地建站\"></a>2 Hexo本地建站</h3><hr>\n<h4 id=\"2-1-hexo安装\"><a href=\"#2-1-hexo安装\" class=\"headerlink\" title=\"2.1 hexo安装\"></a>2.1 hexo安装</h4><p>hexo是基于node.js且在博客部署的时候需要Git命令操作的，所以在安装hexo之前，需要先安装<a href=\"https://nodejs.org/en/\">node.js</a> 和<a href=\"https://git-scm.com/download/win\">Git</a> 。</p>\n<p>完成上述两者的安装后，打开Git Bash，执行以下命令即可完成hexo的安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g hexo-cli</div></pre></td></tr></table></figure>\n<h4 id=\"2-2-hexo站点建立\"><a href=\"#2-2-hexo站点建立\" class=\"headerlink\" title=\"2.2 hexo站点建立\"></a>2.2 hexo站点建立</h4><ul>\n<li><p><strong>1. 确定博客本地站点的位置：</strong> </p>\n<p><del>选择一个位置，作为今后博客本地站点文件的存放位置， 在该位置建立名为<code>&lt;your_githubname&gt;.github.io</code> 的文件夹，<code>&lt;your_githubname&gt;.github.io</code> 也就是之前在Github上创建的仓库名</del> </p>\n<p>由于我想要建立的是一个可以实现多机更新的博客，所以应该将hexo站点建立在<strong>本地的Github仓库</strong>中，这样在一台机器上配置好的主题和配置文件就可以随时上传到<strong>Github远程仓库</strong>中保存。如果希望在其他机器上建立hexo站点，在安装Git的基础上，可以先将之前保存在Github远程仓库中的hexo站点文件<strong>克隆</strong>到本地，形成Github本地仓库，然后在本地仓库中安装hexo即可使用，不需要重复配置。</p>\n<p>同时，由于我们的博客静态网页是发布在远程仓库的<code>master</code> 分支，即主分支上，所以我们需要在<code>master</code> 分支的基础上，<strong>新建一个分支</strong>，命名随意，我这里记为<code>hexo-files</code> ，用于保存推送上来的hexo站点文件，同时在Github中将<code>hexo-files</code> 分支设置为当前仓库的<strong>默认分支</strong>，这样可以方便将本地仓库的文件推送到远端仓库中。</p>\n<p>综上，在上文<a href=\"#create-repo\">创建Github远端新仓库</a> 以及新建并设置默认分支为<code>hexo-files</code> 的基础上，将这个新仓库<strong>克隆</strong>到本地，从而建立本地的Github仓库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 切换到在你希望建立Github本地仓库的路径下</div><div class=\"line\">git clone git@github.com:&lt;your_githubname&gt;/&lt;your_githubname&gt;.github.io.git</div></pre></td></tr></table></figure>\n<p>上述命令会自动创建一个名为<code>&lt;your_githubname&gt;.github.io</code> 的文件夹，并将远程仓库中的文件都放到这个文件夹中。同时，可以发现文件夹中有一个名为<code>.git</code> 的文件夹，这个文件夹保存了有关Github本地仓库的信息以及本地仓库与远程仓库的连接信息，也就是能将<code>&lt;your_githubname&gt;.github.io</code> 文件夹中内容推送到远程仓库中的关键。</p>\n<p><strong>注</strong> ：由于后续建站的时候，<code>hexo init</code> 命令初始化时，会将<code>.git</code> 文件夹覆盖，所以在这一步结束的时候，需要先将<code>.git</code> 文件夹保存起来，等待下一步<code>hexo init</code> 之后再复制进来。</p>\n</li>\n<li><p><strong>2. 建站：</strong></p>\n<p>进入站点文件夹<code>&lt;your_githubname&gt;.github.io</code> 内，依次执行以下两条命令，完成hexo站点的建立：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init</div><div class=\"line\">npm install</div></pre></td></tr></table></figure>\n<p><strong>注</strong> ：记得将<code>.git</code> 文件夹复制到<code>&lt;your_githubname&gt;.github.io</code> 中。</p>\n<p>此时，在Git Bash中进入<code>&lt;your_githubname&gt;.github.io</code> 目录下，可以看到当前所处Github分支是<code>hexo-files</code> ，如果不是，请返回上一步，设置好默认分支，再克隆远程仓库到本地。</p>\n<p>完成后，站点文件夹内的目录结构大致如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── .git</div><div class=\"line\">├── _config.yml</div><div class=\"line\">├── package.json</div><div class=\"line\">├── node_modules</div><div class=\"line\">├── scaffolds</div><div class=\"line\">├── source</div><div class=\"line\">|   └── _posts</div><div class=\"line\">└── themes</div></pre></td></tr></table></figure>\n<p>各文件和文件夹的含义大致为：</p>\n<ul>\n<li><p><code>_config.yml</code> ，存放站点的配置信息，比如站点主题、站点名、站点菜单、站点链接以及第三方插件等等；</p>\n</li>\n<li><p><code>package.json</code> ，存放插件信息，可以查看安装了哪些插件；</p>\n</li>\n<li><p><code>node_modules</code> ，存放站点主题相关的样式文件；</p>\n</li>\n<li><p><code>scaffolds</code> ，模板文件，生成静态网页时，hexo会将Markdown文件中<code>---</code> 以上的部分对比模板文件，然后生成新的静态网页文件；</p>\n</li>\n<li><p><code>source</code> ，存放用户写好的Markdown文件，想要生成静态网页的Markdown文件写好之后，就可以放在<code>_post</code> 文件夹下。除了<code>_post</code> 文件夹，其他以<code>_</code> 开头的文件夹都会被忽略，而且，只有将Markdown文件放在<code>_post</code> 文件夹下，生成之后才会具有完整的主题样式。</p>\n<p>当然，如果想在网页上创建类似于<code>About</code> 的更多菜单选项，可以在<code>source</code> 文件夹下新建更多的文件夹，并在其中添加Markdown文件，当然，这些文件生成静态网页后不会具有完整主题样式，只能手动调整。</p>\n</li>\n<li><p><code>themes</code> ，存放主题文件。</p>\n</li>\n</ul>\n<p><strong>注</strong> ：由于默认的NPM镜像有时候会很慢，在这时候可以将默认的源切换到淘宝镜像：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm config set registry &quot;https://registry.npm.taobao.org&quot;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-3-hexo站点配置\"><a href=\"#2-3-hexo站点配置\" class=\"headerlink\" title=\"2.3 hexo站点配置\"></a>2.3 hexo站点配置</h4><p>站点大部分的配置都可以通过<code>_config.yml</code> 文件实现，具体各个部分的含义可以参考<a href=\"https://hexo.io/zh-cn/docs/configuration.html\">Hexo-配置</a> 。</p>\n<h4 id=\"2-4-hexo新内容生成\"><a href=\"#2-4-hexo新内容生成\" class=\"headerlink\" title=\"2.4 hexo新内容生成\"></a>2.4 hexo新内容生成</h4><p>将一篇写好的Markdown文件放入<code>_post</code> 文件夹中（如果你还不知道怎么写，可以先参照和使用文件夹中已有的一个示例），关于如何写一篇Markdown文章，推荐使用<a href=\"https://typora.io/\">Typora</a> Markdown编辑器，关于Markdown语法，推荐<a href=\"http://www.jianshu.com/p/092de536d948\">Typora For Markdown 语法</a> ，当然也可以自行搜索。</p>\n<p>将Markdown文件生成静态网页文件，执行以下命令之后，会产生一个<code>public</code> 文件夹，其中包含的就是所生成的静态网页文件和样式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate</div><div class=\"line\"># 或者简化为 hexo g</div></pre></td></tr></table></figure>\n<p>启动hexo本地服务器，然后在浏览器中输入<code>http://localhost:4000/</code> ，就可以在本地预览新生成的网页：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo server</div></pre></td></tr></table></figure>\n<p>需要注意的是，单纯写一篇文章，生成之后只会在网页显示一部分，如果要阅读全文或者支持文章分类，必须在文章开头添加<a href=\"https://hexo.io/zh-cn/docs/front-matter.html\">Front-matter</a> ，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">title: Hexo</div><div class=\"line\">date: 2017/02/27 00:00:00</div><div class=\"line\">categories:</div><div class=\"line\">- Study</div><div class=\"line\">tags:</div><div class=\"line\">- Hexo</div><div class=\"line\">- Github</div><div class=\"line\">---</div><div class=\"line\">Hello World.</div></pre></td></tr></table></figure>\n<h4 id=\"2-5-hexo主题更换\"><a href=\"#2-5-hexo主题更换\" class=\"headerlink\" title=\"2.5 hexo主题更换\"></a>2.5 hexo主题更换</h4><p>hexo的主题很多，可以访问<a href=\"https://hexo.io/themes/\">Themes|Hexo</a> 选取。</p>\n<p>以下将以<a href=\"https://github.com/lotabout/hexo-theme-noise\">Noise</a> 主题为例，讲解一下主题的更换。</p>\n<ul>\n<li>找到主题的Github主页，主页上一般都会有安装的步骤和使用教程；</li>\n<li>将主题的代码克隆到<code>/themes</code> 文件夹下，并安装主题和主题渲染器：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone https://github.com/lotabout/hexo-theme-noise themes/noise</div><div class=\"line\">npm install hexo-renderer-less --save</div><div class=\"line\">npm install hexo-renderer-jade --save</div></pre></td></tr></table></figure>\n<ul>\n<li>修改配置文档<code>_config.yml</code> ，将<code>theme</code> 的值由<code>landscape</code> 修改为<code>noise</code> 。</li>\n<li>重新执行一遍生成操作即可预览:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo clean</div><div class=\"line\">hexo generate</div><div class=\"line\">hexo server</div></pre></td></tr></table></figure>\n<h4 id=\"2-6-小结\"><a href=\"#2-6-小结\" class=\"headerlink\" title=\"2.6 小结\"></a>2.6 小结</h4><p>以上就完成了hexo的本地建站工作，如果只想在本地玩玩，到这里就完成了，日常的工作就是写写Markdown文章，然后在站点目录下依次执行以下命令即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate</div><div class=\"line\">hexo server</div><div class=\"line\"># visit http://localhost:4000/</div></pre></td></tr></table></figure>\n<p>PS. 顺便总结一下不问原因的、从零开始的快速建站方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"># install node.js and git</div><div class=\"line\">npm install -g hexo-cli</div><div class=\"line\"># choose a path and clone &lt;your_githubname&gt;.github.io.git to local dir</div><div class=\"line\">git clone git@github.com:&lt;your_githubname&gt;/&lt;your_githubname&gt;.github.io.git</div><div class=\"line\">cd &lt;your_githubname&gt;.github.io</div><div class=\"line\"># 先将 .git 文件夹复制</div><div class=\"line\">hexo init</div><div class=\"line\"># 再将 .git 文件夹粘贴进来</div><div class=\"line\">npm install</div><div class=\"line\"># write a markdown file and put it into /source/_post/</div><div class=\"line\">hexo generate</div><div class=\"line\">hexo server</div></pre></td></tr></table></figure>\n<h3 id=\"3-hexo部署到Github\"><a href=\"#3-hexo部署到Github\" class=\"headerlink\" title=\"3 hexo部署到Github\"></a>3 hexo部署到Github</h3><hr>\n<ul>\n<li>安装插件：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>\n<ul>\n<li>修改配置文件<code>_config.yml</code> ：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repo:  https://github.com/&lt;your_githubname&gt;/&lt;your_name&gt;.github.io.git</div><div class=\"line\">  branch: master</div><div class=\"line\"># branch: master 意思是，部署的时候选择master分支发布</div></pre></td></tr></table></figure>\n<p>​    <strong>注 ：配置文件中冒号后面一定要空一格</strong> </p>\n<ul>\n<li>将hexo站点文件推送到远程仓库中，并将生成的静态网页部署到Github Pages：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">git add .</div><div class=\"line\">git commit -m &quot;注释&quot;</div><div class=\"line\">git push origin hexo-files # 意思是，将本地仓库hexo-files分支的内容推送到名为origin的远程仓库的默认分支中</div><div class=\"line\"># 生成静态网页并部署到Github上</div><div class=\"line\">hexo generate</div><div class=\"line\">hexo deploy</div><div class=\"line\"># 或者简化  hexo g -d</div></pre></td></tr></table></figure>\n<p>​    有时候会跳出一个窗口，输入Github账号和密码即可。</p>\n<ul>\n<li>登录<code>https://&lt;your_githubname&gt;.github.io</code> ，查看部署完成的博客内容。</li>\n</ul>\n<p><strong>注</strong> ：我还没有出现过部署不成功的情况，如果有，请查看<a href=\"http://lowrank.science/Hexo-Github/\">hexo部署后没动静，咋办</a> 。</p>\n<h3 id=\"4-hexo博客更新以及多机更新流程\"><a href=\"#4-hexo博客更新以及多机更新流程\" class=\"headerlink\" title=\"4 hexo博客更新以及多机更新流程\"></a>4 hexo博客更新以及多机更新流程</h3><hr>\n<ul>\n<li><strong>Status1</strong> ：如果上一次更新时使用的就是当前的机器，那么只需要将新完成的Markdown文件放入<code>_post</code> 文件夹内，按照情况执行以下命令即可：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 本地预览时</div><div class=\"line\">hexo generate</div><div class=\"line\">hexo server</div><div class=\"line\"># 确定完成，需要推送&amp;发布</div><div class=\"line\">hexo clean # 清理一下减少推送的数据量</div><div class=\"line\">git add .</div><div class=\"line\">git commit -m &quot;注释&quot;</div><div class=\"line\">git push origin hexo-files</div><div class=\"line\">hexo g -d</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>Status2</strong> ：如果上一次更新时使用的不是当前机器，那么首先需要确定当前机器已经<a href=\"#create-githublink\">建立了Github与本地的连接</a> 并且已经安装了node.js和Git，之后根据情况执行以下命令：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 创建本地仓库</div><div class=\"line\">git clone git@github.com:&lt;your_githubname&gt;/&lt;your_githubname&gt;.github.io.git</div><div class=\"line\">cd &lt;your_githubname&gt;.github.io</div><div class=\"line\"># 若当前机器是第一次用于编写发布博客，则需要安装hexo</div><div class=\"line\">npm install -g hexo-cli</div><div class=\"line\"># 否则，从这里开始</div><div class=\"line\">npm install hexo </div><div class=\"line\">npm install</div><div class=\"line\">npm install hexo-deployer-git --save</div><div class=\"line\"># npm install hexo-renderer-less --save</div><div class=\"line\"># npm install hexo-renderer-jade --save</div><div class=\"line\"># 之后，就可以按照上述的 Status1 推送和发布博客了</div></pre></td></tr></table></figure>\n<h3 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5 总结\"></a>5 总结</h3><p>本文介绍了Hexo+Github Pages博客的建立方法和过程，以及如何实现多机更新Github博客的原理和方法。</p>\n<p>总的来说，如果是第一次搭建Github博客，要学习的东西还是蛮多的，如果不明白其中的道理，加上网上零零散散不完全的教程，经常会绕到死胡同里。其中，我认为掌握Github<strong>仓库</strong>和<strong>分支</strong>的概念是很重要的，当然这也是学习Github中很重要的两个知识点。</p>\n<p>在简单学习Github之后，我又萌生了将未完成的Markdown文件存储在Github远程仓库上的想法，这样未编写完成的Markdown文章就可以在不同机器上抓取并编写，然后推送共享，随时随地编写文章，直到完成。这对于我一个经常在实验室和宿舍两头跑的学生来说，是一件挺方便的事情。</p>\n<p>之后的工作……应该是系统地学习Github，了解Github上更多有趣的东西吧，先放个链接吧，<a href=\"https://www.zhihu.com/question/20070065\">如何使用Github</a> 以及<a href=\"https://www.zhihu.com/question/23498424\">Github上有趣的项目</a>。</p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2017-02-24T02:40:00.739Z","updated":"2017-02-20T09:07:37.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizmml95j0005qkupvxzv39qa","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n"},{"title":"Git Study","date":"2017-02-23T16:00:00.000Z","catagories":["Study"],"_content":"\n### 0 Git Introduction\n\nGit是一种开源的分布式版本管理系统。\n\n每台安装了Git的机器上都会维持一个Git的本地仓库。\n\n### 1 本地版本库的创建与管理\n\n#### 1.1 创建与文件提交\n\n- 初始化一个Git仓库：`git init`；\n- 添加文件到Git仓库（[背后的原理](#gitadd-principle)）:\n  1. `git add <file>` ，可以使用多次，添加多个文件；\n  2. `git commit -m \"提交说明文字\"` ，完成一次提交。\n\n#### 1.2 查看仓库状态\n\n- `git status` ，查看本地仓库的[工作区](#workplace)状态，命令会告诉我们，当前有哪些文件被修改了，现在的状态是”没有添加任何文件“OR”已添加待提交“，此外还会对后续操作提示相应的命令；\n- `git diff` ， 如果有文件被修改了，可以用该命令查看具体的修改内容（有\"-\"号的一行说明有删减，有“+”的一行说明有增加）。\n\n#### 1.2 版本回退与回退的撤销\n\n- `git log` ，查看提交的历史记录，以便确定回退到哪一个版本，精简输出可以使用`git log --pretty=oneline`；<span id=\"versionback\"></span>\n\n- `git reflog` ，查看命令的历史记录，可以用于确定版本回退之前的最新版本号`commit_id` ；\n\n- `git reset --hard <commit_id>` ，`commit_id` 是版本号，是SHA1计算得出的十六进制数字，每提交一次就会新生成一个`commit_id` ，版本号没有必要每次都输入完整，保证前几位不同就可以。此外，`HEAD` 表示当前版本号，`HEAD^` 表示上一个版本号，以此类推，`HEAD~100` 表示上100个版本号。\n\n  **注意** ：对于只有一个版本的版本库是无法再回退到上一个状态（即最初初始化的状态）\n\n#### 1.4 工作区与暂存区\n\n- <span id=\"workplace\">工作区（Working Directory）</span>\n\n  也就是当时使用`git init` 初始化的本地仓库的目录/文件夹。\n\n- 版本库（Repository）\n\n  工作区内的隐藏目录`.git` ，这个目录不算工作区，而是属于版本库。版本库中最重要的部分是暂存区（stage/index）这也是Git与SVN不同之处，同时还有Git自动创建的第一个[分支](#branch)`master` 和指向`master` 的[指针`HEAD`](#pointer-HEAD) 。\n\n- 工作区与暂存区的关系\n\n  这里通过`git add <file>` 的<span id=\"gitadd-principle\">工作原理</span>来解释一下工作区与暂存区之间的关系。\n\n  1. `git add` 添加的时候，实际上是将文件或者文件的修改添加到暂存区中；\n\n  2. `git commit` 提交文件或文件修改，实际上是将暂存区的所有内容提交到当前分支中。\n\n     **注意**：\n\n     - 提交之后，工作区就没有任何新的修改，暂存区也没有任何内容，同时产生了新的版本。\n\n     - 提交的时候，Git只负责将已经加入暂存区的修改内容提交到分支中，即若`git add` 之后再对文件进行修改，那么此时修改的内容是不会提交到分支中的。\n\n       `git diff HEAD -- <file>` ，可以用于查看工作区与版本库中最新版本之间的区别。\n\n#### 1.5 管理与修改、删除\n\nGit跟踪并管理的是**文件的修改部分** ,而非整个文件。\n\n所以，如果修改没有从工作区添加到暂存区，那么这些修改就无法被提交到版本库的最新版本中。\n\n- `git checkout -- <file>` ，直接放弃对工作区的所有修改，这比一行一行的恢复更省力气，有时候对于不知道修改了哪部分内容的情况也很有用。\n\n- `git rm --cached <file>` ，将添加到暂存区的修改撤销（unstage），并将修改重新放回工作区，如果此时仍想撤销所有的修改，则执行命令`git checkout -- <file>` ；\n\n- 如果已经向本地版本库提交了不合适的修改并想要撤销时，需要[版本回退](#versionback)操作，前提是还没有推送到远程仓库。\n\n- 若要删除<span id=\"local-delete\"></span>一个文件，需要在工作区和版本库中同时删除该文件 `git rm <file>` ，并在删除完成后重新提交`git commit -m <file> ` 一次：\n\n- 若在工作区错删了文件，则可以借助版本库，将该文件恢复到最新一次提交的状态：`git checkout -- <file>` *（当然，如果回收站还没清空的话，也可以去回收站看看）*；\n\n- **注** ：`git checkout` 的原理是，利用版本库中的最新版本替换工作区的版本。\n\n\n### 2 远程仓库\n\n可以自己搭建Git服务器作为远程仓库，也可以使用Github的免费仓库（但是是公开的所有人可见的）。\n\n一台电脑上也可以建立多个版本库，只要不在同一目录中即可。\n\nGit支持SSH协议。\n\n#### 2.1 添加远程库与推送Push\n\n在完成Github注册和SSH Key添加之后，就可以在Github上创建一个新的Git仓库，然后根据相应的提示，将本地仓库的文件推送（Push）到远程仓库中。\n\n- `git remote add origin <仓库地址>` ，在本地仓库目录下执行，将本地仓库与远程仓库进行关联，同时为远程仓库定义了新的名字`origin` ，当然也可以使用别的名字；\n- `git push -u origin master` ，将本地仓库的内容推送到远成仓库，实际上是将当前分支`master` 的内容推送到远程仓库的`master` 分支，由于刚开始远程仓库是空的，所以第一次推送的时候，需要参数`-u` ，这样在推送的同时，还会建立起本地分支`master` 和远程仓库中`master` 分支的联系，以后推送和拉取内容就可以简化命令，即`git push origin master` 和`git pull` 。\n\n#### 2.2 从远程库克隆Clone\n\n- `git clone https://github.com/zouguijin/docSync.git` \n\n- `git clone git@github.com:zouguijin/docSync.git` \n\n  Git支持多种协议，默认的git（所使用的是ssh协议），此外还可以使用https协议（但是https协议有时候比较慢，而且每次推送都需要输入口令，使用ssh就不需要输入口令，`get clone` 的时候都要口令...）。\n\n#### 2.3 远程仓库文件的删除\n\n在[管理与修改、删除](#local-delete) 部分，讲述了本地工作区和本地仓库文件的删除方法。若希望删除远程库中的文件，需要：\n\n1. 进入与远程库相对应的本地仓库，切换到相应的分支，或者建立本地分支与远程分支的连接，然后通过`git pull` 将远程库的内容抓取到本地库中；\n\n2. 将不需要的内容在本地仓库中删除，然后再次添加`git add .` ，提交`git commit -m \"...\"` ，并最后推送到远程仓库覆盖原内容即可`git push origin branch ` 。\n\n   **注** ：如果上一个提交者不是当前机器，则不能直接在本地修改然后推送，会出现冲突，否则可以直接修改并推送。\n\n### 3 分支（Branch）\n\n创建属于自己的分支，其他人是看不到的，一个未完成的项目可以在分支上不断更新，直到完成之后再一次提交到`master` 主分支上。\n\n#### 3.1 创建与合并\n\n- 原理：\n\n  一个分支就是一条时间线，随着不断地提交逐渐变长。最初只有主分支即`master` 分支，同时有一个`master` 指针指向主分支的最新提交，之前说的指针`HEAD` 指向的是指针`master` ，而不是指向最新提交。即：\n\n  > `HEAD` -> `master` -> `最新提交` \n\n  每次提交之后，`master` 分支都会向前延长，同时指针`master` 都会指向最新的提交，指针`HEAD` 的指向不变。\n\n  创建新的分支，例如`branch` 时，即创建新的指针`branch` ，指向与`master` 相同的提交，此时若将指针`HEAD` 指向`branch` ，则表示切换当前分支，由主分支切换到`branch` 分支。\n\n  > `master` ->`最新提交` <- `branch` <- `HEAD`  \n\n  如果在`branch` 分支下提交新的修改，那么`branch` 分支就会向前延长，指针`branch` 指向最新提交，但此时指针`master` 保持切换前的指向位置不变。\n\n  合并分支，也就是将主分支的`master` 指针指向`branch` 指针所指向的最新提交即可，合并分支后，一般都会将工作时使用的新分支`branch` 删除，即删除`branch` 指针。\n\n  **注** ：可见，所谓创建分支，只是创建了一个指针，切换、合并分支，只是改变了指针的指向，删除分支，只是将对应的指针删除，所有的操作都不涉及内容的改变。\n\n- 命令操作\n\n  - `git branch` ，查看分支情况，当前分支前会用`*` 标记；\n  - `git branch <name>` ，创建分支；\n  - `git checkout <name>` ，切换分支，由当前分支切换到指定命名分支；\n  - `git checkout -b <name>` ，创建&切换分支；\n  - `git merge <name>` ，合并分支，将指定命名分支合并到当前分支上；（默认使用`Fast Forward` 模式，该模式下删除分支后，分支信息也随之删除，即看不到历史合并信息；若希望能看到历史合并信息，就需要禁用FF模式，并最好添加注释信息，即`git merge --no-ff -m \"注释信息\" <name>`）\n  - `git branch -d <name>` ，删除指定命名分支。\n\n- 合并冲突<span id=\"conflict-solve\"></span>\n\n  如果两个需要合并的分支各自都有新的提交，而且两者的提交在同一位置有不同的表述，在合并的时候就会出现冲突，即不能简单地删除、添加或者替换。\n\n  冲突出现的时候，在显示分支的括号中会多出`|MERGING` 字样，表示此时必须解决合并冲突，分支切换操作被禁止，这时需要利用`git diff` 查看文件内容，并手动修改冲突的内容，然后重新添加和提交即可。（Git会用`<<<<<<<`，`=======`，`>>>>>>>`标记出不同分支的内容）\n\n  `git log --graph` 可以看到分支的合并情况，或者简化版`git log --graph --pretty=oneline --abbrev-commit` 。\n\n- 分支管理策略\n\n  - 保证主分支`master` 是稳定的，仅仅用于发布公开的、可以使用的新版本；\n  - 如果团队合作的话，需要新建一个团队开发提交的分支，例如`dev` 分支，平时的提交与合并都在该分支上完成，一个完整的版本完成之后再将`dev` 分支合并到主分支上。\n\n#### 3.2 Bug分支\n\n当遇到Bug的时候，可以切换到需要修复Bug的分支上，在该分支上创建临时的Bug分支，在临时分支上修复Bug，然后合并原分支上，最后删除临时分支即可。\n\n此时，如果手头上的工作没有做完（工作区有正在修改的内容，如果将Bug修复完成之后就添加、提交，那么之前正在处理但未处理完成的工作就会和修复的Bug一起添加并提交上去，这是我们不想看见的），那么这时候就需要将未完成的工作**先拿出工作区并暂存**起来：\n\n> `git stash` \n\n此时，利用`git status` 查看工作区，会看见工作区是干净的。\n\n完成Bug修复之后，可以再将之前的工作取出来放进工作区继续完成：\n\n- `git stash list` ，若有多个工作，可以先查看列表，再决定需要恢复哪个工作；\n- `git stash apply` ，恢复工作之后，暂存的内容并不会自动删除，需要使用`git stash drop` 将相应的内容删除；\n- `git stash pop` ，推荐使用，恢复工作的同时，可以将暂存的内容也删除；\n- 若要指定恢复或者删除哪一条`stash` ，可以添加后续命令`stash@{x}` ，`x` 可以从`stash` 列表中选取。\n\n#### 3.3 Feature分支\n\n为项目开发一个新的功能时，最好在项目分支上新建一个分支，功能完成之后再将新功能的代码合并到项目分支中。\n\n如果在合并之前，需要放弃该功能分支，则需要通过强行删除的操作完成：\n\n> `git branch -D <name>`\n\n#### 3.4 推送与抓取\n\n- `git remote -v` ，查看远程库的信息，会给出本地可以抓取和推送的远程库的地址以及远程库的命名（默认是`origin`）；\n\n- `git push origin <name> ` ，推送分支，即将指定分支上的所有本地内容推送到远程仓库中的**相对应**的分支上，可以推送本地`master` 分支内容，也可以推送其他分支的内容；\n\n- `git clone <git/https>` ，其他用户从远程库克隆的时候，默认情况下只能看到`master` 分支（当然其他分支也随之克隆下来了，只是不稍微调整是看不到的），前面说了，一般不会直接向`master` 分支推送修改，所以需要在本地创建远程仓库`origin` 的分支`branch` （这里的`branch` 需要与远程仓库的`branch` 同名）：\n\n  > `git checkout -b branch origin/branch` \n\n  只有这样，才能建立本地与远成仓库的联系，之后的抓取`git pull` 和推送`git push origin branch ` 才可以进行。\n\n- `git pull` ，抓取分支，首先需要建立本地分支与远程仓库相应分支之间的链接：\n\n  > `git branch --set-upstream branch origin/branch` \n\n  在之前建立本地分支与远程库分支的基础上，可以将最新的提交从远程库相应的分支上抓取下来：\n\n  > `git pull` \n\n  如果`git pull` 的时候出现冲突，则需要[解决冲突](#conflict-solve) 。\n\n- 本地分支，若不推送到远程，只有本地可见。\n\n### 4 标签（Tag）\n\n版本发布的时候，为了今后方便查找，一般会使用标签的方式，采用有意义的文字标记当前版本，即可以将标签当作版本库的一个快照，本质上标签就是一个指向某一次`commit` 的指针，类似于分支指针（但是分支指针可以移动，标签指针不可以移动）。\n\n- `git tag` ，查看所有标签；\n- `git tag <name>` ，为当前分支生成一个标签，标签默认标记在最新的提交上；\n- `git tag <name> <commit_id>` ，若想为历史的某一次提交生成标签，则找到该提交的`commit_id` 即可；\n- `git tag -a <tagname> -m \"注释信息\" <commit_id>` ，创建标签并生成注释；\n- `git show <tagname>` ，查看相应的标签信息；\n\n**注** ：标签是按照字母顺序排序的，而不是按照时间排序。\n\n- `git tag -d <tagname>` ，删除本地标签；\n\n- `git push origin <tagname>` ，将标签推送到远程仓库中；\n\n- `git push origin --tags` ，一次性地将本地标签全部推送到远程库中；\n\n- 若想要删除的标签已经被推送到了远程库中，那么需要两步才能删除标签：\n\n  >`git tag -d <tagname>` #首先，本地删除\n  >\n  >`git push origin :refs/tags/<tagname>` #然后，远程删除库中的标签\n\n### 5 Github\n\n如果要参与开源项目，首先将开源项目`Fork` 到自己的仓库中，然后**从自己的仓库中`Clone` **，只有这样才能在本地修改之后，再次推送到Github上，若希望开源项目的官方接受自己的修改，则需要在Github上发起`Pull Request` 。\n\n### 6 .gitignore\n\n.gitignore文件中的文件名将会在提交的时候被忽略，.gitignore文件需要放在版本库中。\n\n.gitignore文件不需要从头开始编写，可以参照[官方文档](https://github.com/github/gitignore '.gitignore-doc')并进行相应的组合即可。\n\n- `git add -f <file>` ，有时候.gitignore文件中禁止提交的文件类型中，有你希望提交的一份文件，则可以通过上述命令强行添加并提交；\n- `git check-ignore -v <file>` ，当发现一个文件无法添加和提交时，需要检查.gitignore文件中哪一条规则写错了，可以使用上述命令进行检查。\n\n### 7 Git配置\n\n- 当前仓库的配置文档存放在`.git/config` 文件中；\n- 当前用户的配置文档存放在用户主目录下的隐藏文件`.gitignore` 中；\n- `git config --global alias. <short-command> <origin-command>` ，配置别名，简化使用。\n\n### 8 Git服务器搭建\n\n服务器系统采用Linux，推荐Ubuntu或者Debian，以下操作需要sudo权限。\n\n1. 安装Git:\n\n   `sudo apt-get install git` \n\n2. 创建Git用户，用于运行Git服务：\n\n   `sudo adduser git` \n\n3. 添加公钥，保证用户的登录：\n\n   收集所有需要登录服务器的用户的公钥，即`id_rsa.pub` 文件的内容，将公钥添加进服务器的`/home/git/.ssh/authorized_keys` 文件中，一行一个。\n\n4. 初始化Git仓库：\n\n   选定一个目录作为Git仓库，例如`/git/git-server.git` ，在目录`/git` 下执行命令：\n\n   `sudo git init --bare git-server.git` \n\n   创建的是裸仓库，即没有工作区，服务器的目的是为了共享，而不允许用户登录到服务器上去修改，然后将Git仓库的所有者更改为之前添加的用户git：\n\n   `sudo chown -R git:git git-server.git` \n\n5. 禁用shell登录：\n\n   即禁止之前创建的用户git登录shell，可以通过编辑`/etc/passwd` 文件完成，将以下一行\n\n   `git:x:1001:1001:,,,:/home/git:/bin/bash` \n\n   改为\n\n   `git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell` \n\n   意思就是，用户`git` 每次一登录shell就会自动退出，即无法登录shell进行其他操作，这么做的目的是，让`git` 用户可以正常通过ssh使用git，但禁止其登录shell。\n\n6. 远程Git仓库已经建立好了，其他客户端用户可以使用`git clone` 将服务器上的内容克隆到本地进行修改：\n\n   `git clone git@server:/git/git-server.git` \n\n   修改完成之后，就是推送与共享了。","source":"_posts/git-study.md","raw":"title: Git Study\n\ndate: 2017/02/24 00:00:00\n\ncatagories:\n\n- Study\n\ntags:\n\n- Git\n- Github\n\n---\n\n### 0 Git Introduction\n\nGit是一种开源的分布式版本管理系统。\n\n每台安装了Git的机器上都会维持一个Git的本地仓库。\n\n### 1 本地版本库的创建与管理\n\n#### 1.1 创建与文件提交\n\n- 初始化一个Git仓库：`git init`；\n- 添加文件到Git仓库（[背后的原理](#gitadd-principle)）:\n  1. `git add <file>` ，可以使用多次，添加多个文件；\n  2. `git commit -m \"提交说明文字\"` ，完成一次提交。\n\n#### 1.2 查看仓库状态\n\n- `git status` ，查看本地仓库的[工作区](#workplace)状态，命令会告诉我们，当前有哪些文件被修改了，现在的状态是”没有添加任何文件“OR”已添加待提交“，此外还会对后续操作提示相应的命令；\n- `git diff` ， 如果有文件被修改了，可以用该命令查看具体的修改内容（有\"-\"号的一行说明有删减，有“+”的一行说明有增加）。\n\n#### 1.2 版本回退与回退的撤销\n\n- `git log` ，查看提交的历史记录，以便确定回退到哪一个版本，精简输出可以使用`git log --pretty=oneline`；<span id=\"versionback\"></span>\n\n- `git reflog` ，查看命令的历史记录，可以用于确定版本回退之前的最新版本号`commit_id` ；\n\n- `git reset --hard <commit_id>` ，`commit_id` 是版本号，是SHA1计算得出的十六进制数字，每提交一次就会新生成一个`commit_id` ，版本号没有必要每次都输入完整，保证前几位不同就可以。此外，`HEAD` 表示当前版本号，`HEAD^` 表示上一个版本号，以此类推，`HEAD~100` 表示上100个版本号。\n\n  **注意** ：对于只有一个版本的版本库是无法再回退到上一个状态（即最初初始化的状态）\n\n#### 1.4 工作区与暂存区\n\n- <span id=\"workplace\">工作区（Working Directory）</span>\n\n  也就是当时使用`git init` 初始化的本地仓库的目录/文件夹。\n\n- 版本库（Repository）\n\n  工作区内的隐藏目录`.git` ，这个目录不算工作区，而是属于版本库。版本库中最重要的部分是暂存区（stage/index）这也是Git与SVN不同之处，同时还有Git自动创建的第一个[分支](#branch)`master` 和指向`master` 的[指针`HEAD`](#pointer-HEAD) 。\n\n- 工作区与暂存区的关系\n\n  这里通过`git add <file>` 的<span id=\"gitadd-principle\">工作原理</span>来解释一下工作区与暂存区之间的关系。\n\n  1. `git add` 添加的时候，实际上是将文件或者文件的修改添加到暂存区中；\n\n  2. `git commit` 提交文件或文件修改，实际上是将暂存区的所有内容提交到当前分支中。\n\n     **注意**：\n\n     - 提交之后，工作区就没有任何新的修改，暂存区也没有任何内容，同时产生了新的版本。\n\n     - 提交的时候，Git只负责将已经加入暂存区的修改内容提交到分支中，即若`git add` 之后再对文件进行修改，那么此时修改的内容是不会提交到分支中的。\n\n       `git diff HEAD -- <file>` ，可以用于查看工作区与版本库中最新版本之间的区别。\n\n#### 1.5 管理与修改、删除\n\nGit跟踪并管理的是**文件的修改部分** ,而非整个文件。\n\n所以，如果修改没有从工作区添加到暂存区，那么这些修改就无法被提交到版本库的最新版本中。\n\n- `git checkout -- <file>` ，直接放弃对工作区的所有修改，这比一行一行的恢复更省力气，有时候对于不知道修改了哪部分内容的情况也很有用。\n\n- `git rm --cached <file>` ，将添加到暂存区的修改撤销（unstage），并将修改重新放回工作区，如果此时仍想撤销所有的修改，则执行命令`git checkout -- <file>` ；\n\n- 如果已经向本地版本库提交了不合适的修改并想要撤销时，需要[版本回退](#versionback)操作，前提是还没有推送到远程仓库。\n\n- 若要删除<span id=\"local-delete\"></span>一个文件，需要在工作区和版本库中同时删除该文件 `git rm <file>` ，并在删除完成后重新提交`git commit -m <file> ` 一次：\n\n- 若在工作区错删了文件，则可以借助版本库，将该文件恢复到最新一次提交的状态：`git checkout -- <file>` *（当然，如果回收站还没清空的话，也可以去回收站看看）*；\n\n- **注** ：`git checkout` 的原理是，利用版本库中的最新版本替换工作区的版本。\n\n\n### 2 远程仓库\n\n可以自己搭建Git服务器作为远程仓库，也可以使用Github的免费仓库（但是是公开的所有人可见的）。\n\n一台电脑上也可以建立多个版本库，只要不在同一目录中即可。\n\nGit支持SSH协议。\n\n#### 2.1 添加远程库与推送Push\n\n在完成Github注册和SSH Key添加之后，就可以在Github上创建一个新的Git仓库，然后根据相应的提示，将本地仓库的文件推送（Push）到远程仓库中。\n\n- `git remote add origin <仓库地址>` ，在本地仓库目录下执行，将本地仓库与远程仓库进行关联，同时为远程仓库定义了新的名字`origin` ，当然也可以使用别的名字；\n- `git push -u origin master` ，将本地仓库的内容推送到远成仓库，实际上是将当前分支`master` 的内容推送到远程仓库的`master` 分支，由于刚开始远程仓库是空的，所以第一次推送的时候，需要参数`-u` ，这样在推送的同时，还会建立起本地分支`master` 和远程仓库中`master` 分支的联系，以后推送和拉取内容就可以简化命令，即`git push origin master` 和`git pull` 。\n\n#### 2.2 从远程库克隆Clone\n\n- `git clone https://github.com/zouguijin/docSync.git` \n\n- `git clone git@github.com:zouguijin/docSync.git` \n\n  Git支持多种协议，默认的git（所使用的是ssh协议），此外还可以使用https协议（但是https协议有时候比较慢，而且每次推送都需要输入口令，使用ssh就不需要输入口令，`get clone` 的时候都要口令...）。\n\n#### 2.3 远程仓库文件的删除\n\n在[管理与修改、删除](#local-delete) 部分，讲述了本地工作区和本地仓库文件的删除方法。若希望删除远程库中的文件，需要：\n\n1. 进入与远程库相对应的本地仓库，切换到相应的分支，或者建立本地分支与远程分支的连接，然后通过`git pull` 将远程库的内容抓取到本地库中；\n\n2. 将不需要的内容在本地仓库中删除，然后再次添加`git add .` ，提交`git commit -m \"...\"` ，并最后推送到远程仓库覆盖原内容即可`git push origin branch ` 。\n\n   **注** ：如果上一个提交者不是当前机器，则不能直接在本地修改然后推送，会出现冲突，否则可以直接修改并推送。\n\n### 3 分支（Branch）\n\n创建属于自己的分支，其他人是看不到的，一个未完成的项目可以在分支上不断更新，直到完成之后再一次提交到`master` 主分支上。\n\n#### 3.1 创建与合并\n\n- 原理：\n\n  一个分支就是一条时间线，随着不断地提交逐渐变长。最初只有主分支即`master` 分支，同时有一个`master` 指针指向主分支的最新提交，之前说的指针`HEAD` 指向的是指针`master` ，而不是指向最新提交。即：\n\n  > `HEAD` -> `master` -> `最新提交` \n\n  每次提交之后，`master` 分支都会向前延长，同时指针`master` 都会指向最新的提交，指针`HEAD` 的指向不变。\n\n  创建新的分支，例如`branch` 时，即创建新的指针`branch` ，指向与`master` 相同的提交，此时若将指针`HEAD` 指向`branch` ，则表示切换当前分支，由主分支切换到`branch` 分支。\n\n  > `master` ->`最新提交` <- `branch` <- `HEAD`  \n\n  如果在`branch` 分支下提交新的修改，那么`branch` 分支就会向前延长，指针`branch` 指向最新提交，但此时指针`master` 保持切换前的指向位置不变。\n\n  合并分支，也就是将主分支的`master` 指针指向`branch` 指针所指向的最新提交即可，合并分支后，一般都会将工作时使用的新分支`branch` 删除，即删除`branch` 指针。\n\n  **注** ：可见，所谓创建分支，只是创建了一个指针，切换、合并分支，只是改变了指针的指向，删除分支，只是将对应的指针删除，所有的操作都不涉及内容的改变。\n\n- 命令操作\n\n  - `git branch` ，查看分支情况，当前分支前会用`*` 标记；\n  - `git branch <name>` ，创建分支；\n  - `git checkout <name>` ，切换分支，由当前分支切换到指定命名分支；\n  - `git checkout -b <name>` ，创建&切换分支；\n  - `git merge <name>` ，合并分支，将指定命名分支合并到当前分支上；（默认使用`Fast Forward` 模式，该模式下删除分支后，分支信息也随之删除，即看不到历史合并信息；若希望能看到历史合并信息，就需要禁用FF模式，并最好添加注释信息，即`git merge --no-ff -m \"注释信息\" <name>`）\n  - `git branch -d <name>` ，删除指定命名分支。\n\n- 合并冲突<span id=\"conflict-solve\"></span>\n\n  如果两个需要合并的分支各自都有新的提交，而且两者的提交在同一位置有不同的表述，在合并的时候就会出现冲突，即不能简单地删除、添加或者替换。\n\n  冲突出现的时候，在显示分支的括号中会多出`|MERGING` 字样，表示此时必须解决合并冲突，分支切换操作被禁止，这时需要利用`git diff` 查看文件内容，并手动修改冲突的内容，然后重新添加和提交即可。（Git会用`<<<<<<<`，`=======`，`>>>>>>>`标记出不同分支的内容）\n\n  `git log --graph` 可以看到分支的合并情况，或者简化版`git log --graph --pretty=oneline --abbrev-commit` 。\n\n- 分支管理策略\n\n  - 保证主分支`master` 是稳定的，仅仅用于发布公开的、可以使用的新版本；\n  - 如果团队合作的话，需要新建一个团队开发提交的分支，例如`dev` 分支，平时的提交与合并都在该分支上完成，一个完整的版本完成之后再将`dev` 分支合并到主分支上。\n\n#### 3.2 Bug分支\n\n当遇到Bug的时候，可以切换到需要修复Bug的分支上，在该分支上创建临时的Bug分支，在临时分支上修复Bug，然后合并原分支上，最后删除临时分支即可。\n\n此时，如果手头上的工作没有做完（工作区有正在修改的内容，如果将Bug修复完成之后就添加、提交，那么之前正在处理但未处理完成的工作就会和修复的Bug一起添加并提交上去，这是我们不想看见的），那么这时候就需要将未完成的工作**先拿出工作区并暂存**起来：\n\n> `git stash` \n\n此时，利用`git status` 查看工作区，会看见工作区是干净的。\n\n完成Bug修复之后，可以再将之前的工作取出来放进工作区继续完成：\n\n- `git stash list` ，若有多个工作，可以先查看列表，再决定需要恢复哪个工作；\n- `git stash apply` ，恢复工作之后，暂存的内容并不会自动删除，需要使用`git stash drop` 将相应的内容删除；\n- `git stash pop` ，推荐使用，恢复工作的同时，可以将暂存的内容也删除；\n- 若要指定恢复或者删除哪一条`stash` ，可以添加后续命令`stash@{x}` ，`x` 可以从`stash` 列表中选取。\n\n#### 3.3 Feature分支\n\n为项目开发一个新的功能时，最好在项目分支上新建一个分支，功能完成之后再将新功能的代码合并到项目分支中。\n\n如果在合并之前，需要放弃该功能分支，则需要通过强行删除的操作完成：\n\n> `git branch -D <name>`\n\n#### 3.4 推送与抓取\n\n- `git remote -v` ，查看远程库的信息，会给出本地可以抓取和推送的远程库的地址以及远程库的命名（默认是`origin`）；\n\n- `git push origin <name> ` ，推送分支，即将指定分支上的所有本地内容推送到远程仓库中的**相对应**的分支上，可以推送本地`master` 分支内容，也可以推送其他分支的内容；\n\n- `git clone <git/https>` ，其他用户从远程库克隆的时候，默认情况下只能看到`master` 分支（当然其他分支也随之克隆下来了，只是不稍微调整是看不到的），前面说了，一般不会直接向`master` 分支推送修改，所以需要在本地创建远程仓库`origin` 的分支`branch` （这里的`branch` 需要与远程仓库的`branch` 同名）：\n\n  > `git checkout -b branch origin/branch` \n\n  只有这样，才能建立本地与远成仓库的联系，之后的抓取`git pull` 和推送`git push origin branch ` 才可以进行。\n\n- `git pull` ，抓取分支，首先需要建立本地分支与远程仓库相应分支之间的链接：\n\n  > `git branch --set-upstream branch origin/branch` \n\n  在之前建立本地分支与远程库分支的基础上，可以将最新的提交从远程库相应的分支上抓取下来：\n\n  > `git pull` \n\n  如果`git pull` 的时候出现冲突，则需要[解决冲突](#conflict-solve) 。\n\n- 本地分支，若不推送到远程，只有本地可见。\n\n### 4 标签（Tag）\n\n版本发布的时候，为了今后方便查找，一般会使用标签的方式，采用有意义的文字标记当前版本，即可以将标签当作版本库的一个快照，本质上标签就是一个指向某一次`commit` 的指针，类似于分支指针（但是分支指针可以移动，标签指针不可以移动）。\n\n- `git tag` ，查看所有标签；\n- `git tag <name>` ，为当前分支生成一个标签，标签默认标记在最新的提交上；\n- `git tag <name> <commit_id>` ，若想为历史的某一次提交生成标签，则找到该提交的`commit_id` 即可；\n- `git tag -a <tagname> -m \"注释信息\" <commit_id>` ，创建标签并生成注释；\n- `git show <tagname>` ，查看相应的标签信息；\n\n**注** ：标签是按照字母顺序排序的，而不是按照时间排序。\n\n- `git tag -d <tagname>` ，删除本地标签；\n\n- `git push origin <tagname>` ，将标签推送到远程仓库中；\n\n- `git push origin --tags` ，一次性地将本地标签全部推送到远程库中；\n\n- 若想要删除的标签已经被推送到了远程库中，那么需要两步才能删除标签：\n\n  >`git tag -d <tagname>` #首先，本地删除\n  >\n  >`git push origin :refs/tags/<tagname>` #然后，远程删除库中的标签\n\n### 5 Github\n\n如果要参与开源项目，首先将开源项目`Fork` 到自己的仓库中，然后**从自己的仓库中`Clone` **，只有这样才能在本地修改之后，再次推送到Github上，若希望开源项目的官方接受自己的修改，则需要在Github上发起`Pull Request` 。\n\n### 6 .gitignore\n\n.gitignore文件中的文件名将会在提交的时候被忽略，.gitignore文件需要放在版本库中。\n\n.gitignore文件不需要从头开始编写，可以参照[官方文档](https://github.com/github/gitignore '.gitignore-doc')并进行相应的组合即可。\n\n- `git add -f <file>` ，有时候.gitignore文件中禁止提交的文件类型中，有你希望提交的一份文件，则可以通过上述命令强行添加并提交；\n- `git check-ignore -v <file>` ，当发现一个文件无法添加和提交时，需要检查.gitignore文件中哪一条规则写错了，可以使用上述命令进行检查。\n\n### 7 Git配置\n\n- 当前仓库的配置文档存放在`.git/config` 文件中；\n- 当前用户的配置文档存放在用户主目录下的隐藏文件`.gitignore` 中；\n- `git config --global alias. <short-command> <origin-command>` ，配置别名，简化使用。\n\n### 8 Git服务器搭建\n\n服务器系统采用Linux，推荐Ubuntu或者Debian，以下操作需要sudo权限。\n\n1. 安装Git:\n\n   `sudo apt-get install git` \n\n2. 创建Git用户，用于运行Git服务：\n\n   `sudo adduser git` \n\n3. 添加公钥，保证用户的登录：\n\n   收集所有需要登录服务器的用户的公钥，即`id_rsa.pub` 文件的内容，将公钥添加进服务器的`/home/git/.ssh/authorized_keys` 文件中，一行一个。\n\n4. 初始化Git仓库：\n\n   选定一个目录作为Git仓库，例如`/git/git-server.git` ，在目录`/git` 下执行命令：\n\n   `sudo git init --bare git-server.git` \n\n   创建的是裸仓库，即没有工作区，服务器的目的是为了共享，而不允许用户登录到服务器上去修改，然后将Git仓库的所有者更改为之前添加的用户git：\n\n   `sudo chown -R git:git git-server.git` \n\n5. 禁用shell登录：\n\n   即禁止之前创建的用户git登录shell，可以通过编辑`/etc/passwd` 文件完成，将以下一行\n\n   `git:x:1001:1001:,,,:/home/git:/bin/bash` \n\n   改为\n\n   `git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell` \n\n   意思就是，用户`git` 每次一登录shell就会自动退出，即无法登录shell进行其他操作，这么做的目的是，让`git` 用户可以正常通过ssh使用git，但禁止其登录shell。\n\n6. 远程Git仓库已经建立好了，其他客户端用户可以使用`git clone` 将服务器上的内容克隆到本地进行修改：\n\n   `git clone git@server:/git/git-server.git` \n\n   修改完成之后，就是推送与共享了。","slug":"git-study","published":1,"updated":"2017-02-26T12:01:06.415Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizmml95l0006qkup9xx754hm","content":"<h3 id=\"0-Git-Introduction\"><a href=\"#0-Git-Introduction\" class=\"headerlink\" title=\"0 Git Introduction\"></a>0 Git Introduction</h3><p>Git是一种开源的分布式版本管理系统。</p>\n<p>每台安装了Git的机器上都会维持一个Git的本地仓库。</p>\n<h3 id=\"1-本地版本库的创建与管理\"><a href=\"#1-本地版本库的创建与管理\" class=\"headerlink\" title=\"1 本地版本库的创建与管理\"></a>1 本地版本库的创建与管理</h3><h4 id=\"1-1-创建与文件提交\"><a href=\"#1-1-创建与文件提交\" class=\"headerlink\" title=\"1.1 创建与文件提交\"></a>1.1 创建与文件提交</h4><ul>\n<li>初始化一个Git仓库：<code>git init</code>；</li>\n<li>添加文件到Git仓库（<a href=\"#gitadd-principle\">背后的原理</a>）:<ol>\n<li><code>git add &lt;file&gt;</code> ，可以使用多次，添加多个文件；</li>\n<li><code>git commit -m &quot;提交说明文字&quot;</code> ，完成一次提交。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"1-2-查看仓库状态\"><a href=\"#1-2-查看仓库状态\" class=\"headerlink\" title=\"1.2 查看仓库状态\"></a>1.2 查看仓库状态</h4><ul>\n<li><code>git status</code> ，查看本地仓库的<a href=\"#workplace\">工作区</a>状态，命令会告诉我们，当前有哪些文件被修改了，现在的状态是”没有添加任何文件“OR”已添加待提交“，此外还会对后续操作提示相应的命令；</li>\n<li><code>git diff</code> ， 如果有文件被修改了，可以用该命令查看具体的修改内容（有”-“号的一行说明有删减，有“+”的一行说明有增加）。</li>\n</ul>\n<h4 id=\"1-2-版本回退与回退的撤销\"><a href=\"#1-2-版本回退与回退的撤销\" class=\"headerlink\" title=\"1.2 版本回退与回退的撤销\"></a>1.2 版本回退与回退的撤销</h4><ul>\n<li><p><code>git log</code> ，查看提交的历史记录，以便确定回退到哪一个版本，精简输出可以使用<code>git log --pretty=oneline</code>；<span id=\"versionback\"></span></p>\n</li>\n<li><p><code>git reflog</code> ，查看命令的历史记录，可以用于确定版本回退之前的最新版本号<code>commit_id</code> ；</p>\n</li>\n<li><p><code>git reset --hard &lt;commit_id&gt;</code> ，<code>commit_id</code> 是版本号，是SHA1计算得出的十六进制数字，每提交一次就会新生成一个<code>commit_id</code> ，版本号没有必要每次都输入完整，保证前几位不同就可以。此外，<code>HEAD</code> 表示当前版本号，<code>HEAD^</code> 表示上一个版本号，以此类推，<code>HEAD~100</code> 表示上100个版本号。</p>\n<p><strong>注意</strong> ：对于只有一个版本的版本库是无法再回退到上一个状态（即最初初始化的状态）</p>\n</li>\n</ul>\n<h4 id=\"1-4-工作区与暂存区\"><a href=\"#1-4-工作区与暂存区\" class=\"headerlink\" title=\"1.4 工作区与暂存区\"></a>1.4 工作区与暂存区</h4><ul>\n<li><p><span id=\"workplace\">工作区（Working Directory）</span></p>\n<p>也就是当时使用<code>git init</code> 初始化的本地仓库的目录/文件夹。</p>\n</li>\n<li><p>版本库（Repository）</p>\n<p>工作区内的隐藏目录<code>.git</code> ，这个目录不算工作区，而是属于版本库。版本库中最重要的部分是暂存区（stage/index）这也是Git与SVN不同之处，同时还有Git自动创建的第一个<a href=\"#branch\">分支</a><code>master</code> 和指向<code>master</code> 的<a href=\"#pointer-HEAD\">指针<code>HEAD</code></a> 。</p>\n</li>\n<li><p>工作区与暂存区的关系</p>\n<p>这里通过<code>git add &lt;file&gt;</code> 的<span id=\"gitadd-principle\">工作原理</span>来解释一下工作区与暂存区之间的关系。</p>\n<ol>\n<li><p><code>git add</code> 添加的时候，实际上是将文件或者文件的修改添加到暂存区中；</p>\n</li>\n<li><p><code>git commit</code> 提交文件或文件修改，实际上是将暂存区的所有内容提交到当前分支中。</p>\n<p><strong>注意</strong>：</p>\n<ul>\n<li><p>提交之后，工作区就没有任何新的修改，暂存区也没有任何内容，同时产生了新的版本。</p>\n</li>\n<li><p>提交的时候，Git只负责将已经加入暂存区的修改内容提交到分支中，即若<code>git add</code> 之后再对文件进行修改，那么此时修改的内容是不会提交到分支中的。</p>\n<p><code>git diff HEAD -- &lt;file&gt;</code> ，可以用于查看工作区与版本库中最新版本之间的区别。</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"1-5-管理与修改、删除\"><a href=\"#1-5-管理与修改、删除\" class=\"headerlink\" title=\"1.5 管理与修改、删除\"></a>1.5 管理与修改、删除</h4><p>Git跟踪并管理的是<strong>文件的修改部分</strong> ,而非整个文件。</p>\n<p>所以，如果修改没有从工作区添加到暂存区，那么这些修改就无法被提交到版本库的最新版本中。</p>\n<ul>\n<li><p><code>git checkout -- &lt;file&gt;</code> ，直接放弃对工作区的所有修改，这比一行一行的恢复更省力气，有时候对于不知道修改了哪部分内容的情况也很有用。</p>\n</li>\n<li><p><code>git rm --cached &lt;file&gt;</code> ，将添加到暂存区的修改撤销（unstage），并将修改重新放回工作区，如果此时仍想撤销所有的修改，则执行命令<code>git checkout -- &lt;file&gt;</code> ；</p>\n</li>\n<li><p>如果已经向本地版本库提交了不合适的修改并想要撤销时，需要<a href=\"#versionback\">版本回退</a>操作，前提是还没有推送到远程仓库。</p>\n</li>\n<li><p>若要删除<span id=\"local-delete\"></span>一个文件，需要在工作区和版本库中同时删除该文件 <code>git rm &lt;file&gt;</code> ，并在删除完成后重新提交<code>git commit -m &lt;file&gt;</code> 一次：</p>\n</li>\n<li><p>若在工作区错删了文件，则可以借助版本库，将该文件恢复到最新一次提交的状态：<code>git checkout -- &lt;file&gt;</code> <em>（当然，如果回收站还没清空的话，也可以去回收站看看）</em>；</p>\n</li>\n<li><p><strong>注</strong> ：<code>git checkout</code> 的原理是，利用版本库中的最新版本替换工作区的版本。</p>\n</li>\n</ul>\n<h3 id=\"2-远程仓库\"><a href=\"#2-远程仓库\" class=\"headerlink\" title=\"2 远程仓库\"></a>2 远程仓库</h3><p>可以自己搭建Git服务器作为远程仓库，也可以使用Github的免费仓库（但是是公开的所有人可见的）。</p>\n<p>一台电脑上也可以建立多个版本库，只要不在同一目录中即可。</p>\n<p>Git支持SSH协议。</p>\n<h4 id=\"2-1-添加远程库与推送Push\"><a href=\"#2-1-添加远程库与推送Push\" class=\"headerlink\" title=\"2.1 添加远程库与推送Push\"></a>2.1 添加远程库与推送Push</h4><p>在完成Github注册和SSH Key添加之后，就可以在Github上创建一个新的Git仓库，然后根据相应的提示，将本地仓库的文件推送（Push）到远程仓库中。</p>\n<ul>\n<li><code>git remote add origin &lt;仓库地址&gt;</code> ，在本地仓库目录下执行，将本地仓库与远程仓库进行关联，同时为远程仓库定义了新的名字<code>origin</code> ，当然也可以使用别的名字；</li>\n<li><code>git push -u origin master</code> ，将本地仓库的内容推送到远成仓库，实际上是将当前分支<code>master</code> 的内容推送到远程仓库的<code>master</code> 分支，由于刚开始远程仓库是空的，所以第一次推送的时候，需要参数<code>-u</code> ，这样在推送的同时，还会建立起本地分支<code>master</code> 和远程仓库中<code>master</code> 分支的联系，以后推送和拉取内容就可以简化命令，即<code>git push origin master</code> 和<code>git pull</code> 。</li>\n</ul>\n<h4 id=\"2-2-从远程库克隆Clone\"><a href=\"#2-2-从远程库克隆Clone\" class=\"headerlink\" title=\"2.2 从远程库克隆Clone\"></a>2.2 从远程库克隆Clone</h4><ul>\n<li><p><code>git clone https://github.com/zouguijin/docSync.git</code> </p>\n</li>\n<li><p><code>git clone git@github.com:zouguijin/docSync.git</code> </p>\n<p>Git支持多种协议，默认的git（所使用的是ssh协议），此外还可以使用https协议（但是https协议有时候比较慢，而且每次推送都需要输入口令，使用ssh就不需要输入口令，<code>get clone</code> 的时候都要口令…）。</p>\n</li>\n</ul>\n<h4 id=\"2-3-远程仓库文件的删除\"><a href=\"#2-3-远程仓库文件的删除\" class=\"headerlink\" title=\"2.3 远程仓库文件的删除\"></a>2.3 远程仓库文件的删除</h4><p>在<a href=\"#local-delete\">管理与修改、删除</a> 部分，讲述了本地工作区和本地仓库文件的删除方法。若希望删除远程库中的文件，需要：</p>\n<ol>\n<li><p>进入与远程库相对应的本地仓库，切换到相应的分支，或者建立本地分支与远程分支的连接，然后通过<code>git pull</code> 将远程库的内容抓取到本地库中；</p>\n</li>\n<li><p>将不需要的内容在本地仓库中删除，然后再次添加<code>git add .</code> ，提交<code>git commit -m &quot;...&quot;</code> ，并最后推送到远程仓库覆盖原内容即可<code>git push origin branch</code> 。</p>\n<p><strong>注</strong> ：如果上一个提交者不是当前机器，则不能直接在本地修改然后推送，会出现冲突，否则可以直接修改并推送。</p>\n</li>\n</ol>\n<h3 id=\"3-分支（Branch）\"><a href=\"#3-分支（Branch）\" class=\"headerlink\" title=\"3 分支（Branch）\"></a>3 分支（Branch）</h3><p>创建属于自己的分支，其他人是看不到的，一个未完成的项目可以在分支上不断更新，直到完成之后再一次提交到<code>master</code> 主分支上。</p>\n<h4 id=\"3-1-创建与合并\"><a href=\"#3-1-创建与合并\" class=\"headerlink\" title=\"3.1 创建与合并\"></a>3.1 创建与合并</h4><ul>\n<li><p>原理：</p>\n<p>一个分支就是一条时间线，随着不断地提交逐渐变长。最初只有主分支即<code>master</code> 分支，同时有一个<code>master</code> 指针指向主分支的最新提交，之前说的指针<code>HEAD</code> 指向的是指针<code>master</code> ，而不是指向最新提交。即：</p>\n<blockquote>\n<p><code>HEAD</code> -&gt; <code>master</code> -&gt; <code>最新提交</code> </p>\n</blockquote>\n<p>每次提交之后，<code>master</code> 分支都会向前延长，同时指针<code>master</code> 都会指向最新的提交，指针<code>HEAD</code> 的指向不变。</p>\n<p>创建新的分支，例如<code>branch</code> 时，即创建新的指针<code>branch</code> ，指向与<code>master</code> 相同的提交，此时若将指针<code>HEAD</code> 指向<code>branch</code> ，则表示切换当前分支，由主分支切换到<code>branch</code> 分支。</p>\n<blockquote>\n<p><code>master</code> -&gt;<code>最新提交</code> &lt;- <code>branch</code> &lt;- <code>HEAD</code>  </p>\n</blockquote>\n<p>如果在<code>branch</code> 分支下提交新的修改，那么<code>branch</code> 分支就会向前延长，指针<code>branch</code> 指向最新提交，但此时指针<code>master</code> 保持切换前的指向位置不变。</p>\n<p>合并分支，也就是将主分支的<code>master</code> 指针指向<code>branch</code> 指针所指向的最新提交即可，合并分支后，一般都会将工作时使用的新分支<code>branch</code> 删除，即删除<code>branch</code> 指针。</p>\n<p><strong>注</strong> ：可见，所谓创建分支，只是创建了一个指针，切换、合并分支，只是改变了指针的指向，删除分支，只是将对应的指针删除，所有的操作都不涉及内容的改变。</p>\n</li>\n<li><p>命令操作</p>\n<ul>\n<li><code>git branch</code> ，查看分支情况，当前分支前会用<code>*</code> 标记；</li>\n<li><code>git branch &lt;name&gt;</code> ，创建分支；</li>\n<li><code>git checkout &lt;name&gt;</code> ，切换分支，由当前分支切换到指定命名分支；</li>\n<li><code>git checkout -b &lt;name&gt;</code> ，创建&amp;切换分支；</li>\n<li><code>git merge &lt;name&gt;</code> ，合并分支，将指定命名分支合并到当前分支上；（默认使用<code>Fast Forward</code> 模式，该模式下删除分支后，分支信息也随之删除，即看不到历史合并信息；若希望能看到历史合并信息，就需要禁用FF模式，并最好添加注释信息，即<code>git merge --no-ff -m &quot;注释信息&quot; &lt;name&gt;</code>）</li>\n<li><code>git branch -d &lt;name&gt;</code> ，删除指定命名分支。</li>\n</ul>\n</li>\n<li><p>合并冲突<span id=\"conflict-solve\"></span></p>\n<p>如果两个需要合并的分支各自都有新的提交，而且两者的提交在同一位置有不同的表述，在合并的时候就会出现冲突，即不能简单地删除、添加或者替换。</p>\n<p>冲突出现的时候，在显示分支的括号中会多出<code>|MERGING</code> 字样，表示此时必须解决合并冲突，分支切换操作被禁止，这时需要利用<code>git diff</code> 查看文件内容，并手动修改冲突的内容，然后重新添加和提交即可。（Git会用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容）</p>\n<p><code>git log --graph</code> 可以看到分支的合并情况，或者简化版<code>git log --graph --pretty=oneline --abbrev-commit</code> 。</p>\n</li>\n<li><p>分支管理策略</p>\n<ul>\n<li>保证主分支<code>master</code> 是稳定的，仅仅用于发布公开的、可以使用的新版本；</li>\n<li>如果团队合作的话，需要新建一个团队开发提交的分支，例如<code>dev</code> 分支，平时的提交与合并都在该分支上完成，一个完整的版本完成之后再将<code>dev</code> 分支合并到主分支上。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-2-Bug分支\"><a href=\"#3-2-Bug分支\" class=\"headerlink\" title=\"3.2 Bug分支\"></a>3.2 Bug分支</h4><p>当遇到Bug的时候，可以切换到需要修复Bug的分支上，在该分支上创建临时的Bug分支，在临时分支上修复Bug，然后合并原分支上，最后删除临时分支即可。</p>\n<p>此时，如果手头上的工作没有做完（工作区有正在修改的内容，如果将Bug修复完成之后就添加、提交，那么之前正在处理但未处理完成的工作就会和修复的Bug一起添加并提交上去，这是我们不想看见的），那么这时候就需要将未完成的工作<strong>先拿出工作区并暂存</strong>起来：</p>\n<blockquote>\n<p><code>git stash</code> </p>\n</blockquote>\n<p>此时，利用<code>git status</code> 查看工作区，会看见工作区是干净的。</p>\n<p>完成Bug修复之后，可以再将之前的工作取出来放进工作区继续完成：</p>\n<ul>\n<li><code>git stash list</code> ，若有多个工作，可以先查看列表，再决定需要恢复哪个工作；</li>\n<li><code>git stash apply</code> ，恢复工作之后，暂存的内容并不会自动删除，需要使用<code>git stash drop</code> 将相应的内容删除；</li>\n<li><code>git stash pop</code> ，推荐使用，恢复工作的同时，可以将暂存的内容也删除；</li>\n<li>若要指定恢复或者删除哪一条<code>stash</code> ，可以添加后续命令<code>stash@{x}</code> ，<code>x</code> 可以从<code>stash</code> 列表中选取。</li>\n</ul>\n<h4 id=\"3-3-Feature分支\"><a href=\"#3-3-Feature分支\" class=\"headerlink\" title=\"3.3 Feature分支\"></a>3.3 Feature分支</h4><p>为项目开发一个新的功能时，最好在项目分支上新建一个分支，功能完成之后再将新功能的代码合并到项目分支中。</p>\n<p>如果在合并之前，需要放弃该功能分支，则需要通过强行删除的操作完成：</p>\n<blockquote>\n<p><code>git branch -D &lt;name&gt;</code></p>\n</blockquote>\n<h4 id=\"3-4-推送与抓取\"><a href=\"#3-4-推送与抓取\" class=\"headerlink\" title=\"3.4 推送与抓取\"></a>3.4 推送与抓取</h4><ul>\n<li><p><code>git remote -v</code> ，查看远程库的信息，会给出本地可以抓取和推送的远程库的地址以及远程库的命名（默认是<code>origin</code>）；</p>\n</li>\n<li><p><code>git push origin &lt;name&gt;</code> ，推送分支，即将指定分支上的所有本地内容推送到远程仓库中的<strong>相对应</strong>的分支上，可以推送本地<code>master</code> 分支内容，也可以推送其他分支的内容；</p>\n</li>\n<li><p><code>git clone &lt;git/https&gt;</code> ，其他用户从远程库克隆的时候，默认情况下只能看到<code>master</code> 分支（当然其他分支也随之克隆下来了，只是不稍微调整是看不到的），前面说了，一般不会直接向<code>master</code> 分支推送修改，所以需要在本地创建远程仓库<code>origin</code> 的分支<code>branch</code> （这里的<code>branch</code> 需要与远程仓库的<code>branch</code> 同名）：</p>\n<blockquote>\n<p><code>git checkout -b branch origin/branch</code> </p>\n</blockquote>\n<p>只有这样，才能建立本地与远成仓库的联系，之后的抓取<code>git pull</code> 和推送<code>git push origin branch</code> 才可以进行。</p>\n</li>\n<li><p><code>git pull</code> ，抓取分支，首先需要建立本地分支与远程仓库相应分支之间的链接：</p>\n<blockquote>\n<p><code>git branch --set-upstream branch origin/branch</code> </p>\n</blockquote>\n<p>在之前建立本地分支与远程库分支的基础上，可以将最新的提交从远程库相应的分支上抓取下来：</p>\n<blockquote>\n<p><code>git pull</code> </p>\n</blockquote>\n<p>如果<code>git pull</code> 的时候出现冲突，则需要<a href=\"#conflict-solve\">解决冲突</a> 。</p>\n</li>\n<li><p>本地分支，若不推送到远程，只有本地可见。</p>\n</li>\n</ul>\n<h3 id=\"4-标签（Tag）\"><a href=\"#4-标签（Tag）\" class=\"headerlink\" title=\"4 标签（Tag）\"></a>4 标签（Tag）</h3><p>版本发布的时候，为了今后方便查找，一般会使用标签的方式，采用有意义的文字标记当前版本，即可以将标签当作版本库的一个快照，本质上标签就是一个指向某一次<code>commit</code> 的指针，类似于分支指针（但是分支指针可以移动，标签指针不可以移动）。</p>\n<ul>\n<li><code>git tag</code> ，查看所有标签；</li>\n<li><code>git tag &lt;name&gt;</code> ，为当前分支生成一个标签，标签默认标记在最新的提交上；</li>\n<li><code>git tag &lt;name&gt; &lt;commit_id&gt;</code> ，若想为历史的某一次提交生成标签，则找到该提交的<code>commit_id</code> 即可；</li>\n<li><code>git tag -a &lt;tagname&gt; -m &quot;注释信息&quot; &lt;commit_id&gt;</code> ，创建标签并生成注释；</li>\n<li><code>git show &lt;tagname&gt;</code> ，查看相应的标签信息；</li>\n</ul>\n<p><strong>注</strong> ：标签是按照字母顺序排序的，而不是按照时间排序。</p>\n<ul>\n<li><p><code>git tag -d &lt;tagname&gt;</code> ，删除本地标签；</p>\n</li>\n<li><p><code>git push origin &lt;tagname&gt;</code> ，将标签推送到远程仓库中；</p>\n</li>\n<li><p><code>git push origin --tags</code> ，一次性地将本地标签全部推送到远程库中；</p>\n</li>\n<li><p>若想要删除的标签已经被推送到了远程库中，那么需要两步才能删除标签：</p>\n<blockquote>\n<p><code>git tag -d &lt;tagname&gt;</code> #首先，本地删除</p>\n<p><code>git push origin :refs/tags/&lt;tagname&gt;</code> #然后，远程删除库中的标签</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"5-Github\"><a href=\"#5-Github\" class=\"headerlink\" title=\"5 Github\"></a>5 Github</h3><p>如果要参与开源项目，首先将开源项目<code>Fork</code> 到自己的仓库中，然后<strong>从自己的仓库中<code>Clone</code> </strong>，只有这样才能在本地修改之后，再次推送到Github上，若希望开源项目的官方接受自己的修改，则需要在Github上发起<code>Pull Request</code> 。</p>\n<h3 id=\"6-gitignore\"><a href=\"#6-gitignore\" class=\"headerlink\" title=\"6 .gitignore\"></a>6 .gitignore</h3><p>.gitignore文件中的文件名将会在提交的时候被忽略，.gitignore文件需要放在版本库中。</p>\n<p>.gitignore文件不需要从头开始编写，可以参照<a href=\"https://github.com/github/gitignore\" title=\".gitignore-doc\" target=\"_blank\" rel=\"external\">官方文档</a>并进行相应的组合即可。</p>\n<ul>\n<li><code>git add -f &lt;file&gt;</code> ，有时候.gitignore文件中禁止提交的文件类型中，有你希望提交的一份文件，则可以通过上述命令强行添加并提交；</li>\n<li><code>git check-ignore -v &lt;file&gt;</code> ，当发现一个文件无法添加和提交时，需要检查.gitignore文件中哪一条规则写错了，可以使用上述命令进行检查。</li>\n</ul>\n<h3 id=\"7-Git配置\"><a href=\"#7-Git配置\" class=\"headerlink\" title=\"7 Git配置\"></a>7 Git配置</h3><ul>\n<li>当前仓库的配置文档存放在<code>.git/config</code> 文件中；</li>\n<li>当前用户的配置文档存放在用户主目录下的隐藏文件<code>.gitignore</code> 中；</li>\n<li><code>git config --global alias. &lt;short-command&gt; &lt;origin-command&gt;</code> ，配置别名，简化使用。</li>\n</ul>\n<h3 id=\"8-Git服务器搭建\"><a href=\"#8-Git服务器搭建\" class=\"headerlink\" title=\"8 Git服务器搭建\"></a>8 Git服务器搭建</h3><p>服务器系统采用Linux，推荐Ubuntu或者Debian，以下操作需要sudo权限。</p>\n<ol>\n<li><p>安装Git:</p>\n<p><code>sudo apt-get install git</code> </p>\n</li>\n<li><p>创建Git用户，用于运行Git服务：</p>\n<p><code>sudo adduser git</code> </p>\n</li>\n<li><p>添加公钥，保证用户的登录：</p>\n<p>收集所有需要登录服务器的用户的公钥，即<code>id_rsa.pub</code> 文件的内容，将公钥添加进服务器的<code>/home/git/.ssh/authorized_keys</code> 文件中，一行一个。</p>\n</li>\n<li><p>初始化Git仓库：</p>\n<p>选定一个目录作为Git仓库，例如<code>/git/git-server.git</code> ，在目录<code>/git</code> 下执行命令：</p>\n<p><code>sudo git init --bare git-server.git</code> </p>\n<p>创建的是裸仓库，即没有工作区，服务器的目的是为了共享，而不允许用户登录到服务器上去修改，然后将Git仓库的所有者更改为之前添加的用户git：</p>\n<p><code>sudo chown -R git:git git-server.git</code> </p>\n</li>\n<li><p>禁用shell登录：</p>\n<p>即禁止之前创建的用户git登录shell，可以通过编辑<code>/etc/passwd</code> 文件完成，将以下一行</p>\n<p><code>git:x:1001:1001:,,,:/home/git:/bin/bash</code> </p>\n<p>改为</p>\n<p><code>git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</code> </p>\n<p>意思就是，用户<code>git</code> 每次一登录shell就会自动退出，即无法登录shell进行其他操作，这么做的目的是，让<code>git</code> 用户可以正常通过ssh使用git，但禁止其登录shell。</p>\n</li>\n<li><p>远程Git仓库已经建立好了，其他客户端用户可以使用<code>git clone</code> 将服务器上的内容克隆到本地进行修改：</p>\n<p><code>git clone git@server:/git/git-server.git</code> </p>\n<p>修改完成之后，就是推送与共享了。</p>\n</li>\n</ol>\n","excerpt":"","more":"<h3 id=\"0-Git-Introduction\"><a href=\"#0-Git-Introduction\" class=\"headerlink\" title=\"0 Git Introduction\"></a>0 Git Introduction</h3><p>Git是一种开源的分布式版本管理系统。</p>\n<p>每台安装了Git的机器上都会维持一个Git的本地仓库。</p>\n<h3 id=\"1-本地版本库的创建与管理\"><a href=\"#1-本地版本库的创建与管理\" class=\"headerlink\" title=\"1 本地版本库的创建与管理\"></a>1 本地版本库的创建与管理</h3><h4 id=\"1-1-创建与文件提交\"><a href=\"#1-1-创建与文件提交\" class=\"headerlink\" title=\"1.1 创建与文件提交\"></a>1.1 创建与文件提交</h4><ul>\n<li>初始化一个Git仓库：<code>git init</code>；</li>\n<li>添加文件到Git仓库（<a href=\"#gitadd-principle\">背后的原理</a>）:<ol>\n<li><code>git add &lt;file&gt;</code> ，可以使用多次，添加多个文件；</li>\n<li><code>git commit -m &quot;提交说明文字&quot;</code> ，完成一次提交。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"1-2-查看仓库状态\"><a href=\"#1-2-查看仓库状态\" class=\"headerlink\" title=\"1.2 查看仓库状态\"></a>1.2 查看仓库状态</h4><ul>\n<li><code>git status</code> ，查看本地仓库的<a href=\"#workplace\">工作区</a>状态，命令会告诉我们，当前有哪些文件被修改了，现在的状态是”没有添加任何文件“OR”已添加待提交“，此外还会对后续操作提示相应的命令；</li>\n<li><code>git diff</code> ， 如果有文件被修改了，可以用该命令查看具体的修改内容（有”-“号的一行说明有删减，有“+”的一行说明有增加）。</li>\n</ul>\n<h4 id=\"1-2-版本回退与回退的撤销\"><a href=\"#1-2-版本回退与回退的撤销\" class=\"headerlink\" title=\"1.2 版本回退与回退的撤销\"></a>1.2 版本回退与回退的撤销</h4><ul>\n<li><p><code>git log</code> ，查看提交的历史记录，以便确定回退到哪一个版本，精简输出可以使用<code>git log --pretty=oneline</code>；<span id=\"versionback\"></span></p>\n</li>\n<li><p><code>git reflog</code> ，查看命令的历史记录，可以用于确定版本回退之前的最新版本号<code>commit_id</code> ；</p>\n</li>\n<li><p><code>git reset --hard &lt;commit_id&gt;</code> ，<code>commit_id</code> 是版本号，是SHA1计算得出的十六进制数字，每提交一次就会新生成一个<code>commit_id</code> ，版本号没有必要每次都输入完整，保证前几位不同就可以。此外，<code>HEAD</code> 表示当前版本号，<code>HEAD^</code> 表示上一个版本号，以此类推，<code>HEAD~100</code> 表示上100个版本号。</p>\n<p><strong>注意</strong> ：对于只有一个版本的版本库是无法再回退到上一个状态（即最初初始化的状态）</p>\n</li>\n</ul>\n<h4 id=\"1-4-工作区与暂存区\"><a href=\"#1-4-工作区与暂存区\" class=\"headerlink\" title=\"1.4 工作区与暂存区\"></a>1.4 工作区与暂存区</h4><ul>\n<li><p><span id=\"workplace\">工作区（Working Directory）</span></p>\n<p>也就是当时使用<code>git init</code> 初始化的本地仓库的目录/文件夹。</p>\n</li>\n<li><p>版本库（Repository）</p>\n<p>工作区内的隐藏目录<code>.git</code> ，这个目录不算工作区，而是属于版本库。版本库中最重要的部分是暂存区（stage/index）这也是Git与SVN不同之处，同时还有Git自动创建的第一个<a href=\"#branch\">分支</a><code>master</code> 和指向<code>master</code> 的<a href=\"#pointer-HEAD\">指针<code>HEAD</code></a> 。</p>\n</li>\n<li><p>工作区与暂存区的关系</p>\n<p>这里通过<code>git add &lt;file&gt;</code> 的<span id=\"gitadd-principle\">工作原理</span>来解释一下工作区与暂存区之间的关系。</p>\n<ol>\n<li><p><code>git add</code> 添加的时候，实际上是将文件或者文件的修改添加到暂存区中；</p>\n</li>\n<li><p><code>git commit</code> 提交文件或文件修改，实际上是将暂存区的所有内容提交到当前分支中。</p>\n<p><strong>注意</strong>：</p>\n<ul>\n<li><p>提交之后，工作区就没有任何新的修改，暂存区也没有任何内容，同时产生了新的版本。</p>\n</li>\n<li><p>提交的时候，Git只负责将已经加入暂存区的修改内容提交到分支中，即若<code>git add</code> 之后再对文件进行修改，那么此时修改的内容是不会提交到分支中的。</p>\n<p><code>git diff HEAD -- &lt;file&gt;</code> ，可以用于查看工作区与版本库中最新版本之间的区别。</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"1-5-管理与修改、删除\"><a href=\"#1-5-管理与修改、删除\" class=\"headerlink\" title=\"1.5 管理与修改、删除\"></a>1.5 管理与修改、删除</h4><p>Git跟踪并管理的是<strong>文件的修改部分</strong> ,而非整个文件。</p>\n<p>所以，如果修改没有从工作区添加到暂存区，那么这些修改就无法被提交到版本库的最新版本中。</p>\n<ul>\n<li><p><code>git checkout -- &lt;file&gt;</code> ，直接放弃对工作区的所有修改，这比一行一行的恢复更省力气，有时候对于不知道修改了哪部分内容的情况也很有用。</p>\n</li>\n<li><p><code>git rm --cached &lt;file&gt;</code> ，将添加到暂存区的修改撤销（unstage），并将修改重新放回工作区，如果此时仍想撤销所有的修改，则执行命令<code>git checkout -- &lt;file&gt;</code> ；</p>\n</li>\n<li><p>如果已经向本地版本库提交了不合适的修改并想要撤销时，需要<a href=\"#versionback\">版本回退</a>操作，前提是还没有推送到远程仓库。</p>\n</li>\n<li><p>若要删除<span id=\"local-delete\"></span>一个文件，需要在工作区和版本库中同时删除该文件 <code>git rm &lt;file&gt;</code> ，并在删除完成后重新提交<code>git commit -m &lt;file&gt;</code> 一次：</p>\n</li>\n<li><p>若在工作区错删了文件，则可以借助版本库，将该文件恢复到最新一次提交的状态：<code>git checkout -- &lt;file&gt;</code> <em>（当然，如果回收站还没清空的话，也可以去回收站看看）</em>；</p>\n</li>\n<li><p><strong>注</strong> ：<code>git checkout</code> 的原理是，利用版本库中的最新版本替换工作区的版本。</p>\n</li>\n</ul>\n<h3 id=\"2-远程仓库\"><a href=\"#2-远程仓库\" class=\"headerlink\" title=\"2 远程仓库\"></a>2 远程仓库</h3><p>可以自己搭建Git服务器作为远程仓库，也可以使用Github的免费仓库（但是是公开的所有人可见的）。</p>\n<p>一台电脑上也可以建立多个版本库，只要不在同一目录中即可。</p>\n<p>Git支持SSH协议。</p>\n<h4 id=\"2-1-添加远程库与推送Push\"><a href=\"#2-1-添加远程库与推送Push\" class=\"headerlink\" title=\"2.1 添加远程库与推送Push\"></a>2.1 添加远程库与推送Push</h4><p>在完成Github注册和SSH Key添加之后，就可以在Github上创建一个新的Git仓库，然后根据相应的提示，将本地仓库的文件推送（Push）到远程仓库中。</p>\n<ul>\n<li><code>git remote add origin &lt;仓库地址&gt;</code> ，在本地仓库目录下执行，将本地仓库与远程仓库进行关联，同时为远程仓库定义了新的名字<code>origin</code> ，当然也可以使用别的名字；</li>\n<li><code>git push -u origin master</code> ，将本地仓库的内容推送到远成仓库，实际上是将当前分支<code>master</code> 的内容推送到远程仓库的<code>master</code> 分支，由于刚开始远程仓库是空的，所以第一次推送的时候，需要参数<code>-u</code> ，这样在推送的同时，还会建立起本地分支<code>master</code> 和远程仓库中<code>master</code> 分支的联系，以后推送和拉取内容就可以简化命令，即<code>git push origin master</code> 和<code>git pull</code> 。</li>\n</ul>\n<h4 id=\"2-2-从远程库克隆Clone\"><a href=\"#2-2-从远程库克隆Clone\" class=\"headerlink\" title=\"2.2 从远程库克隆Clone\"></a>2.2 从远程库克隆Clone</h4><ul>\n<li><p><code>git clone https://github.com/zouguijin/docSync.git</code> </p>\n</li>\n<li><p><code>git clone git@github.com:zouguijin/docSync.git</code> </p>\n<p>Git支持多种协议，默认的git（所使用的是ssh协议），此外还可以使用https协议（但是https协议有时候比较慢，而且每次推送都需要输入口令，使用ssh就不需要输入口令，<code>get clone</code> 的时候都要口令…）。</p>\n</li>\n</ul>\n<h4 id=\"2-3-远程仓库文件的删除\"><a href=\"#2-3-远程仓库文件的删除\" class=\"headerlink\" title=\"2.3 远程仓库文件的删除\"></a>2.3 远程仓库文件的删除</h4><p>在<a href=\"#local-delete\">管理与修改、删除</a> 部分，讲述了本地工作区和本地仓库文件的删除方法。若希望删除远程库中的文件，需要：</p>\n<ol>\n<li><p>进入与远程库相对应的本地仓库，切换到相应的分支，或者建立本地分支与远程分支的连接，然后通过<code>git pull</code> 将远程库的内容抓取到本地库中；</p>\n</li>\n<li><p>将不需要的内容在本地仓库中删除，然后再次添加<code>git add .</code> ，提交<code>git commit -m &quot;...&quot;</code> ，并最后推送到远程仓库覆盖原内容即可<code>git push origin branch</code> 。</p>\n<p><strong>注</strong> ：如果上一个提交者不是当前机器，则不能直接在本地修改然后推送，会出现冲突，否则可以直接修改并推送。</p>\n</li>\n</ol>\n<h3 id=\"3-分支（Branch）\"><a href=\"#3-分支（Branch）\" class=\"headerlink\" title=\"3 分支（Branch）\"></a>3 分支（Branch）</h3><p>创建属于自己的分支，其他人是看不到的，一个未完成的项目可以在分支上不断更新，直到完成之后再一次提交到<code>master</code> 主分支上。</p>\n<h4 id=\"3-1-创建与合并\"><a href=\"#3-1-创建与合并\" class=\"headerlink\" title=\"3.1 创建与合并\"></a>3.1 创建与合并</h4><ul>\n<li><p>原理：</p>\n<p>一个分支就是一条时间线，随着不断地提交逐渐变长。最初只有主分支即<code>master</code> 分支，同时有一个<code>master</code> 指针指向主分支的最新提交，之前说的指针<code>HEAD</code> 指向的是指针<code>master</code> ，而不是指向最新提交。即：</p>\n<blockquote>\n<p><code>HEAD</code> -&gt; <code>master</code> -&gt; <code>最新提交</code> </p>\n</blockquote>\n<p>每次提交之后，<code>master</code> 分支都会向前延长，同时指针<code>master</code> 都会指向最新的提交，指针<code>HEAD</code> 的指向不变。</p>\n<p>创建新的分支，例如<code>branch</code> 时，即创建新的指针<code>branch</code> ，指向与<code>master</code> 相同的提交，此时若将指针<code>HEAD</code> 指向<code>branch</code> ，则表示切换当前分支，由主分支切换到<code>branch</code> 分支。</p>\n<blockquote>\n<p><code>master</code> -&gt;<code>最新提交</code> &lt;- <code>branch</code> &lt;- <code>HEAD</code>  </p>\n</blockquote>\n<p>如果在<code>branch</code> 分支下提交新的修改，那么<code>branch</code> 分支就会向前延长，指针<code>branch</code> 指向最新提交，但此时指针<code>master</code> 保持切换前的指向位置不变。</p>\n<p>合并分支，也就是将主分支的<code>master</code> 指针指向<code>branch</code> 指针所指向的最新提交即可，合并分支后，一般都会将工作时使用的新分支<code>branch</code> 删除，即删除<code>branch</code> 指针。</p>\n<p><strong>注</strong> ：可见，所谓创建分支，只是创建了一个指针，切换、合并分支，只是改变了指针的指向，删除分支，只是将对应的指针删除，所有的操作都不涉及内容的改变。</p>\n</li>\n<li><p>命令操作</p>\n<ul>\n<li><code>git branch</code> ，查看分支情况，当前分支前会用<code>*</code> 标记；</li>\n<li><code>git branch &lt;name&gt;</code> ，创建分支；</li>\n<li><code>git checkout &lt;name&gt;</code> ，切换分支，由当前分支切换到指定命名分支；</li>\n<li><code>git checkout -b &lt;name&gt;</code> ，创建&amp;切换分支；</li>\n<li><code>git merge &lt;name&gt;</code> ，合并分支，将指定命名分支合并到当前分支上；（默认使用<code>Fast Forward</code> 模式，该模式下删除分支后，分支信息也随之删除，即看不到历史合并信息；若希望能看到历史合并信息，就需要禁用FF模式，并最好添加注释信息，即<code>git merge --no-ff -m &quot;注释信息&quot; &lt;name&gt;</code>）</li>\n<li><code>git branch -d &lt;name&gt;</code> ，删除指定命名分支。</li>\n</ul>\n</li>\n<li><p>合并冲突<span id=\"conflict-solve\"></span></p>\n<p>如果两个需要合并的分支各自都有新的提交，而且两者的提交在同一位置有不同的表述，在合并的时候就会出现冲突，即不能简单地删除、添加或者替换。</p>\n<p>冲突出现的时候，在显示分支的括号中会多出<code>|MERGING</code> 字样，表示此时必须解决合并冲突，分支切换操作被禁止，这时需要利用<code>git diff</code> 查看文件内容，并手动修改冲突的内容，然后重新添加和提交即可。（Git会用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容）</p>\n<p><code>git log --graph</code> 可以看到分支的合并情况，或者简化版<code>git log --graph --pretty=oneline --abbrev-commit</code> 。</p>\n</li>\n<li><p>分支管理策略</p>\n<ul>\n<li>保证主分支<code>master</code> 是稳定的，仅仅用于发布公开的、可以使用的新版本；</li>\n<li>如果团队合作的话，需要新建一个团队开发提交的分支，例如<code>dev</code> 分支，平时的提交与合并都在该分支上完成，一个完整的版本完成之后再将<code>dev</code> 分支合并到主分支上。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-2-Bug分支\"><a href=\"#3-2-Bug分支\" class=\"headerlink\" title=\"3.2 Bug分支\"></a>3.2 Bug分支</h4><p>当遇到Bug的时候，可以切换到需要修复Bug的分支上，在该分支上创建临时的Bug分支，在临时分支上修复Bug，然后合并原分支上，最后删除临时分支即可。</p>\n<p>此时，如果手头上的工作没有做完（工作区有正在修改的内容，如果将Bug修复完成之后就添加、提交，那么之前正在处理但未处理完成的工作就会和修复的Bug一起添加并提交上去，这是我们不想看见的），那么这时候就需要将未完成的工作<strong>先拿出工作区并暂存</strong>起来：</p>\n<blockquote>\n<p><code>git stash</code> </p>\n</blockquote>\n<p>此时，利用<code>git status</code> 查看工作区，会看见工作区是干净的。</p>\n<p>完成Bug修复之后，可以再将之前的工作取出来放进工作区继续完成：</p>\n<ul>\n<li><code>git stash list</code> ，若有多个工作，可以先查看列表，再决定需要恢复哪个工作；</li>\n<li><code>git stash apply</code> ，恢复工作之后，暂存的内容并不会自动删除，需要使用<code>git stash drop</code> 将相应的内容删除；</li>\n<li><code>git stash pop</code> ，推荐使用，恢复工作的同时，可以将暂存的内容也删除；</li>\n<li>若要指定恢复或者删除哪一条<code>stash</code> ，可以添加后续命令<code>stash@{x}</code> ，<code>x</code> 可以从<code>stash</code> 列表中选取。</li>\n</ul>\n<h4 id=\"3-3-Feature分支\"><a href=\"#3-3-Feature分支\" class=\"headerlink\" title=\"3.3 Feature分支\"></a>3.3 Feature分支</h4><p>为项目开发一个新的功能时，最好在项目分支上新建一个分支，功能完成之后再将新功能的代码合并到项目分支中。</p>\n<p>如果在合并之前，需要放弃该功能分支，则需要通过强行删除的操作完成：</p>\n<blockquote>\n<p><code>git branch -D &lt;name&gt;</code></p>\n</blockquote>\n<h4 id=\"3-4-推送与抓取\"><a href=\"#3-4-推送与抓取\" class=\"headerlink\" title=\"3.4 推送与抓取\"></a>3.4 推送与抓取</h4><ul>\n<li><p><code>git remote -v</code> ，查看远程库的信息，会给出本地可以抓取和推送的远程库的地址以及远程库的命名（默认是<code>origin</code>）；</p>\n</li>\n<li><p><code>git push origin &lt;name&gt;</code> ，推送分支，即将指定分支上的所有本地内容推送到远程仓库中的<strong>相对应</strong>的分支上，可以推送本地<code>master</code> 分支内容，也可以推送其他分支的内容；</p>\n</li>\n<li><p><code>git clone &lt;git/https&gt;</code> ，其他用户从远程库克隆的时候，默认情况下只能看到<code>master</code> 分支（当然其他分支也随之克隆下来了，只是不稍微调整是看不到的），前面说了，一般不会直接向<code>master</code> 分支推送修改，所以需要在本地创建远程仓库<code>origin</code> 的分支<code>branch</code> （这里的<code>branch</code> 需要与远程仓库的<code>branch</code> 同名）：</p>\n<blockquote>\n<p><code>git checkout -b branch origin/branch</code> </p>\n</blockquote>\n<p>只有这样，才能建立本地与远成仓库的联系，之后的抓取<code>git pull</code> 和推送<code>git push origin branch</code> 才可以进行。</p>\n</li>\n<li><p><code>git pull</code> ，抓取分支，首先需要建立本地分支与远程仓库相应分支之间的链接：</p>\n<blockquote>\n<p><code>git branch --set-upstream branch origin/branch</code> </p>\n</blockquote>\n<p>在之前建立本地分支与远程库分支的基础上，可以将最新的提交从远程库相应的分支上抓取下来：</p>\n<blockquote>\n<p><code>git pull</code> </p>\n</blockquote>\n<p>如果<code>git pull</code> 的时候出现冲突，则需要<a href=\"#conflict-solve\">解决冲突</a> 。</p>\n</li>\n<li><p>本地分支，若不推送到远程，只有本地可见。</p>\n</li>\n</ul>\n<h3 id=\"4-标签（Tag）\"><a href=\"#4-标签（Tag）\" class=\"headerlink\" title=\"4 标签（Tag）\"></a>4 标签（Tag）</h3><p>版本发布的时候，为了今后方便查找，一般会使用标签的方式，采用有意义的文字标记当前版本，即可以将标签当作版本库的一个快照，本质上标签就是一个指向某一次<code>commit</code> 的指针，类似于分支指针（但是分支指针可以移动，标签指针不可以移动）。</p>\n<ul>\n<li><code>git tag</code> ，查看所有标签；</li>\n<li><code>git tag &lt;name&gt;</code> ，为当前分支生成一个标签，标签默认标记在最新的提交上；</li>\n<li><code>git tag &lt;name&gt; &lt;commit_id&gt;</code> ，若想为历史的某一次提交生成标签，则找到该提交的<code>commit_id</code> 即可；</li>\n<li><code>git tag -a &lt;tagname&gt; -m &quot;注释信息&quot; &lt;commit_id&gt;</code> ，创建标签并生成注释；</li>\n<li><code>git show &lt;tagname&gt;</code> ，查看相应的标签信息；</li>\n</ul>\n<p><strong>注</strong> ：标签是按照字母顺序排序的，而不是按照时间排序。</p>\n<ul>\n<li><p><code>git tag -d &lt;tagname&gt;</code> ，删除本地标签；</p>\n</li>\n<li><p><code>git push origin &lt;tagname&gt;</code> ，将标签推送到远程仓库中；</p>\n</li>\n<li><p><code>git push origin --tags</code> ，一次性地将本地标签全部推送到远程库中；</p>\n</li>\n<li><p>若想要删除的标签已经被推送到了远程库中，那么需要两步才能删除标签：</p>\n<blockquote>\n<p><code>git tag -d &lt;tagname&gt;</code> #首先，本地删除</p>\n<p><code>git push origin :refs/tags/&lt;tagname&gt;</code> #然后，远程删除库中的标签</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"5-Github\"><a href=\"#5-Github\" class=\"headerlink\" title=\"5 Github\"></a>5 Github</h3><p>如果要参与开源项目，首先将开源项目<code>Fork</code> 到自己的仓库中，然后<strong>从自己的仓库中<code>Clone</code> </strong>，只有这样才能在本地修改之后，再次推送到Github上，若希望开源项目的官方接受自己的修改，则需要在Github上发起<code>Pull Request</code> 。</p>\n<h3 id=\"6-gitignore\"><a href=\"#6-gitignore\" class=\"headerlink\" title=\"6 .gitignore\"></a>6 .gitignore</h3><p>.gitignore文件中的文件名将会在提交的时候被忽略，.gitignore文件需要放在版本库中。</p>\n<p>.gitignore文件不需要从头开始编写，可以参照<a href=\"https://github.com/github/gitignore\" title=\".gitignore-doc\">官方文档</a>并进行相应的组合即可。</p>\n<ul>\n<li><code>git add -f &lt;file&gt;</code> ，有时候.gitignore文件中禁止提交的文件类型中，有你希望提交的一份文件，则可以通过上述命令强行添加并提交；</li>\n<li><code>git check-ignore -v &lt;file&gt;</code> ，当发现一个文件无法添加和提交时，需要检查.gitignore文件中哪一条规则写错了，可以使用上述命令进行检查。</li>\n</ul>\n<h3 id=\"7-Git配置\"><a href=\"#7-Git配置\" class=\"headerlink\" title=\"7 Git配置\"></a>7 Git配置</h3><ul>\n<li>当前仓库的配置文档存放在<code>.git/config</code> 文件中；</li>\n<li>当前用户的配置文档存放在用户主目录下的隐藏文件<code>.gitignore</code> 中；</li>\n<li><code>git config --global alias. &lt;short-command&gt; &lt;origin-command&gt;</code> ，配置别名，简化使用。</li>\n</ul>\n<h3 id=\"8-Git服务器搭建\"><a href=\"#8-Git服务器搭建\" class=\"headerlink\" title=\"8 Git服务器搭建\"></a>8 Git服务器搭建</h3><p>服务器系统采用Linux，推荐Ubuntu或者Debian，以下操作需要sudo权限。</p>\n<ol>\n<li><p>安装Git:</p>\n<p><code>sudo apt-get install git</code> </p>\n</li>\n<li><p>创建Git用户，用于运行Git服务：</p>\n<p><code>sudo adduser git</code> </p>\n</li>\n<li><p>添加公钥，保证用户的登录：</p>\n<p>收集所有需要登录服务器的用户的公钥，即<code>id_rsa.pub</code> 文件的内容，将公钥添加进服务器的<code>/home/git/.ssh/authorized_keys</code> 文件中，一行一个。</p>\n</li>\n<li><p>初始化Git仓库：</p>\n<p>选定一个目录作为Git仓库，例如<code>/git/git-server.git</code> ，在目录<code>/git</code> 下执行命令：</p>\n<p><code>sudo git init --bare git-server.git</code> </p>\n<p>创建的是裸仓库，即没有工作区，服务器的目的是为了共享，而不允许用户登录到服务器上去修改，然后将Git仓库的所有者更改为之前添加的用户git：</p>\n<p><code>sudo chown -R git:git git-server.git</code> </p>\n</li>\n<li><p>禁用shell登录：</p>\n<p>即禁止之前创建的用户git登录shell，可以通过编辑<code>/etc/passwd</code> 文件完成，将以下一行</p>\n<p><code>git:x:1001:1001:,,,:/home/git:/bin/bash</code> </p>\n<p>改为</p>\n<p><code>git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</code> </p>\n<p>意思就是，用户<code>git</code> 每次一登录shell就会自动退出，即无法登录shell进行其他操作，这么做的目的是，让<code>git</code> 用户可以正常通过ssh使用git，但禁止其登录shell。</p>\n</li>\n<li><p>远程Git仓库已经建立好了，其他客户端用户可以使用<code>git clone</code> 将服务器上的内容克隆到本地进行修改：</p>\n<p><code>git clone git@server:/git/git-server.git</code> </p>\n<p>修改完成之后，就是推送与共享了。</p>\n</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cizmml95b0000qkup63ojxzzt","category_id":"cizmml95h0003qkup89pyveyj","_id":"cizmml95o0008qkup9z9vdt8b"}],"PostTag":[{"post_id":"cizmml95b0000qkup63ojxzzt","tag_id":"cizmml95i0004qkupa100dyvx","_id":"cizmml95q000aqkup1m17fv8g"},{"post_id":"cizmml95b0000qkup63ojxzzt","tag_id":"cizmml95n0007qkuprncxowxp","_id":"cizmml95q000bqkupatqss5pm"},{"post_id":"cizmml95f0002qkupm3psys2p","tag_id":"cizmml95i0004qkupa100dyvx","_id":"cizmml95s000fqkup0pt9w77n"},{"post_id":"cizmml95f0002qkupm3psys2p","tag_id":"cizmml95q000cqkuprt6z5btb","_id":"cizmml95s000gqkups4ks31lf"},{"post_id":"cizmml95f0002qkupm3psys2p","tag_id":"cizmml95s000dqkup6n4vip0g","_id":"cizmml95t000iqkup3xyftw32"},{"post_id":"cizmml95l0006qkup9xx754hm","tag_id":"cizmml95s000eqkupo1sib43c","_id":"cizmml95u000jqkupfee8ee40"},{"post_id":"cizmml95l0006qkup9xx754hm","tag_id":"cizmml95q000cqkuprt6z5btb","_id":"cizmml95u000kqkupif7f40ld"}],"Tag":[{"name":"BlogTools","_id":"cizmml95i0004qkupa100dyvx"},{"name":"Markdown Editor","_id":"cizmml95n0007qkuprncxowxp"},{"name":"Github","_id":"cizmml95q000cqkuprt6z5btb"},{"name":"hexo","_id":"cizmml95s000dqkup6n4vip0g"},{"name":"Git","_id":"cizmml95s000eqkupo1sib43c"}]}}