<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>leetcode61 Rotate List | StarSea</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- gallery that comes before the header--><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/leetcode/">leetcode</a><a class="post-tag-link" href="/tags/linkedlist/">linkedlist</a></div><div class="post-time">2017-05-11</div></div></div><div class="container post-header"><h1>leetcode61 Rotate List</h1></div><div class="container post-content"><h2 id="leetcode-61-Rotate-List"><a href="#leetcode-61-Rotate-List" class="headerlink" title="leetcode#61 Rotate List"></a>leetcode#61 Rotate List</h2><blockquote>
<p>Given a list, rotate the list to the right by <em>k</em> places, where <em>k</em> is non-negative.</p>
<p>For example:<br>Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code> and <em>k</em> = <code>2</code>,<br>return <code>4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</code>.</p>
</blockquote>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>给定一条单链表，将该链表向右<strong>循环移动（Rotate）</strong>K次，K为非负数。</p>
<p>例如：</p>
<p>给定 <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code> &amp;&amp; <em>k</em> = <code>2</code>,<br>返回 <code>4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</code>.</p>
<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>最初的想法：以为只是单纯地将前（lists.length - K）个链表节点搬移到链表末尾，没有意识到“循环移动”，所以所写的代码虽然可以解决<code>K &lt;= lists.length</code>的情况，但是由于没有考虑到当<code>K &gt; lists.length</code>的情况，所以是不完善的。</p>
<p>后来的想法：既然在<code>K &lt;= lists.length</code>的情况下，是OK的，那么对于<code>K &gt; lists.length</code>的情况，只要对链表节点的总数<strong>取余</strong>，不就可以将取余的结果限制在<code>lists.length</code>之中了么？OK，那就这么干！</p>
<h4 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h4><p>若循环移动的次数正好是链表节点数量的倍数，那么链表的结构是不变的，所以考虑在<code>steps &lt;= lists.length</code>的情况下对链表进行循环移动：</p>
<p>首先需要遍历所有的链表节点，获得节点的总数<code>count</code>，然后<strong>取余</strong><code>steps = k % count</code>，获得需要循环移动的次数，接着使用<strong>一快一慢</strong>两个指针，当快指针<code>fast</code>到达末尾的时候，直接将从<code>head</code>到<code>slow</code>的一段链表<strong>整体搬移</strong>到<code>fast</code>之后即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * public class ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode next;</div><div class="line"> *     ListNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">public class Solution &#123;</div><div class="line">    public ListNode rotateRight(ListNode head, int k) &#123;</div><div class="line">        if(k == 0 || head == null || head.next == null) return head;</div><div class="line">        </div><div class="line">        ListNode fast = head;</div><div class="line">        int count = 1;</div><div class="line">        while(fast.next != null) &#123;</div><div class="line">            fast = fast.next;</div><div class="line">            count++;</div><div class="line">        &#125;</div><div class="line">        int steps = k % count;</div><div class="line">        if(steps == 0) return head; </div><div class="line">        </div><div class="line">        fast = head;</div><div class="line">        ListNode slow = head;</div><div class="line">        while(steps != 0 &amp;&amp; fast != null) &#123;</div><div class="line">            fast = fast.next;</div><div class="line">            steps--;</div><div class="line">        &#125;</div><div class="line">        if(fast == null) return head;</div><div class="line">        else &#123;</div><div class="line">            while(fast.next != null) &#123;</div><div class="line">                slow = slow.next;</div><div class="line">                fast = fast.next;</div><div class="line">            &#125;</div><div class="line">            ListNode next = slow.next;</div><div class="line">            slow.next = fast.next;</div><div class="line">            fast.next = head;</div><div class="line">            head = next;</div><div class="line">            return head;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="大神解法"><a href="#大神解法" class="headerlink" title="大神解法"></a>大神解法</h4><p>解法一：<strong>链表外节点+快慢指针+整体搬移</strong></p>
<ul>
<li>由于需要循环移动，头节点也是需要变化的，所以最好在链表之外新建一个节点<code>dummy</code>（但我在新建的时候，运行报错<code>Memory Limit Exceed</code>…），最后<code>dummy</code>的下一个节点即为新链表的头节点；</li>
<li>通过取余，使得移动的步数小于链表节点数之内，一快一慢两个指针确定整体搬移的起止位置，最后一次搬移成功</li>
</ul>
<p>大体来说，我的解法与该解法思路一样，差别在于，我没有新建额外的节点，而且我在确定<code>slow</code>指针的位置的时候，是与<code>fast</code>指针一起移动的。由于没有新建链表之外的节点，所以我在边界上的判断就会显得稍微多一点，没有该解法简洁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public ListNode rotateRight(ListNode head, int n) &#123;</div><div class="line">    if (head==null||head.next==null) return head;</div><div class="line">    ListNode dummy=new ListNode(0);</div><div class="line">    dummy.next=head;</div><div class="line">    ListNode fast=dummy,slow=dummy;</div><div class="line"></div><div class="line">    int i;</div><div class="line">    for (i=0;fast.next!=null;i++)//Get the total length </div><div class="line">    	fast=fast.next;</div><div class="line">    </div><div class="line">    for (int j=i-n%i;j&gt;0;j--) //Get the i-n%i th node</div><div class="line">    	slow=slow.next;</div><div class="line">    </div><div class="line">    fast.next=dummy.next; //Do the rotation</div><div class="line">    dummy.next=slow.next;</div><div class="line">    slow.next=null;</div><div class="line">    </div><div class="line">    return dummy.next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解法二：<strong>成环</strong>方法</p>
<p>既然是<strong>循环移动</strong>，K的值只要满足非负数就可以任意取值，那么只需要将原链表成环，爱怎么循环移动就怎么循环移动。</p>
<p>成环，首先要遍历链表元素，找到链表末尾的节点，然后将其和链表头节点相连接即可。（以下是C++代码）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode* rotateRight(ListNode* head, int k) &#123;</div><div class="line">        if(!head) return head;</div><div class="line">        </div><div class="line">        int len=1; // number of nodes</div><div class="line">        ListNode *newH, *tail;</div><div class="line">        newH=tail=head;</div><div class="line">        </div><div class="line">        while(tail-&gt;next)  // get the number of nodes in the list</div><div class="line">        &#123;</div><div class="line">            tail = tail-&gt;next;</div><div class="line">            len++;</div><div class="line">        &#125;</div><div class="line">        tail-&gt;next = head; // circle the link</div><div class="line"></div><div class="line">        if(k %= len) </div><div class="line">        &#123;</div><div class="line">            for(auto i=0; i&lt;len-k; i++) tail = tail-&gt;next; // the tail node is the (len-k)-th node (1st node is head)</div><div class="line">        &#125;</div><div class="line">        newH = tail-&gt;next; </div><div class="line">        tail-&gt;next = NULL;</div><div class="line">        return newH;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>怎么说呢？解法二和解法一其实都差不多，只不过解法二没有一快一慢两个指针，但是代价就是，需要成环，然后开环（好像这也不是什么代价……），相对而言解法一就不需要成环，但是需要用一快一慢两个指针确定整体搬移的起止位置。</p>
<p>在两者复杂度基本相同的情况下，我个人还是比较倾向于解法一不成环的方式的，因为该解法里沿用了链表算法中常用的两种思路：链表外新建节点和快慢指针组合，用起来得心应手。</p>
<p>不过以后关于链表的问题，也可以适当地考虑将原链表<strong>成环</strong>后进行操作。</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>