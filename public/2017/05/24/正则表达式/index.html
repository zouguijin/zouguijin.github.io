<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>正则表达式 | StarSea</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- gallery that comes before the header--><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/JavaBasis/">JavaBasis</a><a class="post-tag-link" href="/tags/RegularExpressions/">RegularExpressions</a></div><div class="post-time">2017-05-24</div></div></div><div class="container post-header"><h1>正则表达式</h1></div><div class="container post-content"><h2 id="Regular-Expressions"><a href="#Regular-Expressions" class="headerlink" title="Regular Expressions"></a>Regular Expressions</h2><h3 id="1-字符"><a href="#1-字符" class="headerlink" title="1 字符"></a>1 字符</h3><table>
<thead>
<tr>
<th style="text-align:center"><strong>B</strong></th>
<th style="text-align:center"><strong>指定字符B（没有反斜杠）</strong></th>
<th style="text-align:center"><strong>\n</strong></th>
<th style="text-align:center"><strong>换行</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>\xhh</strong></td>
<td style="text-align:center"><strong>十六进制值为 oxhh 的字符</strong></td>
<td style="text-align:center"><strong>\r</strong></td>
<td style="text-align:center"><strong>回车</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>\uhhh</strong></td>
<td style="text-align:center"><strong>十六进制为 oxhhh 的Unicode字符</strong></td>
<td style="text-align:center"><strong>\f</strong></td>
<td style="text-align:center"><strong>换页</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>\e</strong></td>
<td style="text-align:center"><strong>转义（ESC）</strong></td>
<td style="text-align:center"><strong>\t</strong></td>
<td style="text-align:center"><strong>制表符</strong></td>
</tr>
</tbody>
</table>
<h3 id="2-字符类"><a href="#2-字符类" class="headerlink" title="2 字符类"></a>2 字符类</h3><p>常用的字符类形式：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>.</strong></th>
<th style="text-align:center"><strong>任意字符</strong></th>
<th style="text-align:center"><strong>\s</strong></th>
<th style="text-align:center"><strong>空白符（包括 \n \r \t \f “ “）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>[abc]</strong></td>
<td style="text-align:center"><strong>包含a b c的任意字符（等同于abc之间的或）</strong></td>
<td style="text-align:center"><strong>\S</strong></td>
<td style="text-align:center"><strong>非空白符，即除了上述五种空白符之外的字符</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>[^abc]</strong></td>
<td style="text-align:center"><strong>包含除了a b c之外的任意字符</strong></td>
<td style="text-align:center"><strong>\d</strong></td>
<td style="text-align:center"><strong>数字，[0-9]</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>[a-zA-Z]</strong></td>
<td style="text-align:center"><strong>包含a-z或A-Z的任意字符</strong></td>
<td style="text-align:center"><strong>\D</strong></td>
<td style="text-align:center"><strong>非数字</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>[abc[de]]</strong></td>
<td style="text-align:center"><strong>类似于abcde之间的或</strong></td>
<td style="text-align:center"><strong>\w</strong></td>
<td style="text-align:center"><strong>词字符，即字母和数字，[a-zA-Z0-9]</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>[a-z&amp;&amp;[de]]</strong></td>
<td style="text-align:center"><strong>类似于(a-z)&amp;&amp;de，即包含d e的任意字符</strong></td>
<td style="text-align:center"><strong>\W</strong></td>
<td style="text-align:center"><strong>非字母和非数字的字符</strong></td>
</tr>
</tbody>
</table>
<p>Java中的正则表达式，需要使用<strong>额外的一个右斜杠对右斜杠进行转义</strong>，所以一般在Java的正则表达式中会看到<code>\\d+[.]\\d+[.]\\d+[.]\\d+</code>的情况，表达的意思就是类似于IP地址格式的字符串。</p>
<h3 id="3-边界匹配符"><a href="#3-边界匹配符" class="headerlink" title="3 边界匹配符"></a>3 边界匹配符</h3><table>
<thead>
<tr>
<th style="text-align:center"><strong>^</strong></th>
<th style="text-align:center"><strong>一行的起始</strong></th>
<th style="text-align:center"><strong>\b</strong></th>
<th style="text-align:center"><strong>词的边界</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>$</strong></td>
<td style="text-align:center"><strong>一行的结束</strong></td>
<td style="text-align:center"><strong>\B</strong></td>
<td style="text-align:center"><strong>非词的边界</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>\G</strong></td>
<td style="text-align:center"><strong>前一个匹配的结束</strong></td>
<td style="text-align:center"><strong>-</strong></td>
<td style="text-align:center"><strong>-</strong></td>
</tr>
</tbody>
</table>
<h3 id="4-量词"><a href="#4-量词" class="headerlink" title="4 量词"></a><strong>4 量词</strong></h3><p>量词描述的是一个模式吸收输入文本的方式（好难懂…）</p>
<p>简单一点讲就是，量词在正则表达式中的位置，将会影响正则表达式对输入文本的匹配结果，是匹配单个还是多个，量词将会起到重要的作用。</p>
<h4 id="（1）贪婪型"><a href="#（1）贪婪型" class="headerlink" title="（1）贪婪型"></a>（1）贪婪型</h4><p>量词的默认属性，也是量词最基本的使用方法。所谓“贪婪”，即被该属性的量词描述的时候，正则表达式将会<strong>尽可能多地匹配</strong>，而不是遇到第一个匹配的就停止。</p>
<h4 id="（2）勉强型"><a href="#（2）勉强型" class="headerlink" title="（2）勉强型"></a>（2）勉强型</h4><p>若要限定正则表达式<strong>匹配到最少的字符数</strong>，可以使用勉强型的量词修饰。勉强型的量词，即在贪婪型的基础上，<strong>多加一个问号“?”</strong>。</p>
<h4 id="（3）占有型"><a href="#（3）占有型" class="headerlink" title="（3）占有型"></a>（3）占有型</h4><p>目前，占有型量词修饰的正则表达式，只能在Java中使用，由于比较高级，基本不会使用到。占有型量词，只需要在贪婪型的基础上，<strong>多加一个加号“+”</strong>。</p>
<p>由于正则表达式在匹配的过程中，会产生许多的<strong>中间状态</strong>，以便在匹配失败后回溯到之前成功的状态，这些中间状态过多会引起正则表达式的失控以及效率低下，所以占有型的目的就是通过不保存中间状态的方式，提高正则表达式的效率。</p>
<h4 id="（4）附：贪婪型量词描述"><a href="#（4）附：贪婪型量词描述" class="headerlink" title="（4）附：贪婪型量词描述"></a>（4）附：贪婪型量词描述</h4><p>对<strong>量词的转义</strong>，需要连续的两个右斜杠 <strong>\\ </strong></p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>X?</strong></th>
<th style="text-align:center"><strong>一个或者零个X</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>X*</strong></td>
<td style="text-align:center"><strong>零个或者多个X</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>X+</strong></td>
<td style="text-align:center"><strong>一个或者多个X</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>X{n}</strong></td>
<td style="text-align:center"><strong>n个X</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>X{n,}</strong></td>
<td style="text-align:center"><strong>至少n个X</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>X{n,m}</strong></td>
<td style="text-align:center"><strong>X的出现次数是n-m之间</strong></td>
</tr>
</tbody>
</table>
<h3 id="5-Pattern类与Matcher类"><a href="#5-Pattern类与Matcher类" class="headerlink" title="5 Pattern类与Matcher类"></a><strong>5 Pattern类与Matcher类</strong></h3><h4 id="（1）Pattern类的使用"><a href="#（1）Pattern类的使用" class="headerlink" title="（1）Pattern类的使用"></a>（1）Pattern类的使用</h4><p>可以单纯使用String类提供的方法分割或者替换字符串中的字符，如果觉得不能满足需求，也可以通过<strong>Pattern类</strong>自定义正则表达式对象，用于匹配字符串。</p>
<ul>
<li><p>导入Pattern类所在的包，<code>java.util.regex</code>；</p>
</li>
<li><p>写好正则表达式regex之后，使用Pattern类的静态方法<code>Pattern.compile(String regex)</code>编译正则表达式，生成一个Pattern类对象；</p>
</li>
<li><p>将所需匹配的原字符串作为参数，传递给Pattern类的方法<code>matcher(String str)</code>，生成一个Matcher类对象，之后就可以使用Matcher类的方法，对原字符串进行匹配后的操作，包括分割、替换、查询匹配的起止位置等。</p>
<p>（具体的Matcher类方法可以查阅JDK文档的<code>java.util.regex.Matcher</code>）</p>
</li>
</ul>
<h4 id="（2）组（Group）的概念"><a href="#（2）组（Group）的概念" class="headerlink" title="（2）组（Group）的概念"></a>（2）组（Group）的概念</h4><p>组，使用<strong>括号划分</strong>的正则表达式，例如<code>A(BC(DE(GH)F))</code>，可以根据组的编号来引用某一个组，组号为0表示整个表达式，从左往右遇到的第一个括号包含的部分是组号为1的正则表达式，以此类推。</p>
<p>利用组的概念以及相应的方法，可以在匹配成功之后（可以通过<code>Matcher.find()</code>方法返回的<code>true/false</code>，判断是否匹配成功），定位到相应的位置，确定字符串到底是与哪一个组匹配上了。</p>
<p><code>Matcher.group()</code>，即返回当前匹配到的字符串，如果将该方法放在一个循环中，则会依次输出匹配到的字符串。</p>
<p>关于<strong>判断是否匹配成功</strong>，有很多种方法：</p>
<ul>
<li><code>boolean matches();</code>，只有在整个输入都匹配正则表达式的时候，才返回<code>true</code></li>
<li><code>boolean lookingAt();</code>，只有在输入的一开始就匹配正则表达式的时候，才返回<code>true</code></li>
<li><code>boolean find();</code>，输入在任意位置与正则表达式匹配，都返回<code>true</code></li>
</ul>
<h4 id="（3）CharSequence——正则表达式在Java中的数据类型"><a href="#（3）CharSequence——正则表达式在Java中的数据类型" class="headerlink" title="（3）CharSequence——正则表达式在Java中的数据类型"></a>（3）CharSequence——正则表达式在Java中的数据类型</h4><p>接口CharSequence从CharBuffer、String、StringBuffer、StringBuilder类中抽象出<strong>字符序列</strong>的一般化定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">interface CharSequence &#123;</div><div class="line">  charAt(int i);</div><div class="line">  length();</div><div class="line">  subSequence(int start, int end);</div><div class="line">  toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>上述的类都实现了该接口</strong>，多数正则表达式的操作都接受CharSequence类型的参数。</p>
<h4 id="（4）Pattern类的标记"><a href="#（4）Pattern类的标记" class="headerlink" title="（4）Pattern类的标记"></a>（4）Pattern类的标记</h4><p>Pattern类的标记用于稍微改变匹配过程中的匹配规则和方式。</p>
<p>Pattern类的标记在<code>Pattern.compile(String regex, int mark)</code>的时候，可以引入。</p>
<p>比较有用的有三种：</p>
<ul>
<li><code>Pattern.CASE_INSENSITIVE</code>，不考虑字母的大小写</li>
<li><code>Pattern.COMMENTS</code>，忽略空格符</li>
<li><code>Pattern.MULTILINE</code>，默认模式下，将会匹配完整的字符串，不管有多少行，该模式下，则可以根据^和$的标记，按行为单位进行匹配</li>
</ul>
<h4 id="（5）分割字符串方法split"><a href="#（5）分割字符串方法split" class="headerlink" title="（5）分割字符串方法split()"></a>（5）分割字符串方法split()</h4><p>split()方法可以将输入的字符串按照匹配的情况，分割成<strong>字符串对象数组</strong>。</p>
<p><code>String[] split(CharSequence input)</code></p>
<p><code>String[] split(CharSequence input, int limit)</code>，可以限制将输入分割成子串的数量</p>
<h4 id="（6）渐进式替换字符串方法appendRepalcement"><a href="#（6）渐进式替换字符串方法appendRepalcement" class="headerlink" title="（6）渐进式替换字符串方法appendRepalcement()"></a>（6）渐进式替换字符串方法appendRepalcement()</h4><p>在字符串自带的方法之上，若想实现<strong>渐进式</strong>的字符串替换方式（在替换原字符串匹配部分的过程中，还可以调整用于替换的字符串），则需要使用<code>Matcher.appendReplacement(StringBuffer strf, String replacement)</code>方法。strf是用于保存最终的结果，replacement部分可以在替换的过程中通过自定义而变化，最后使用<code>Matcher.appendTail(StringBuffer strf)</code>方法可以将最终的结果全部存储到strf中，用于后续的输出。</p>
<h4 id="（7）重复使用Matcher对象的方法reset"><a href="#（7）重复使用Matcher对象的方法reset" class="headerlink" title="（7）重复使用Matcher对象的方法reset()"></a>（7）重复使用Matcher对象的方法reset()</h4><p>通过一系列的方法，得到了一个Matcher对象，在匹配了一个字符串之后，如果还想将其应用于<strong>其他的字符串</strong>，该怎么办？重新创建？不，可以使用<code>Matcher.reset(String newStr)</code>方法，从而可以重复地使用之前创建的Matcher对象。</p>
<p>若使用不带参数的<code>Matcher.reset()</code>方法，则表示将Matcher对象<strong>重新设置到当前序列的起始位置</strong>。</p>
<h3 id="6-正则表达式与Java-I-O"><a href="#6-正则表达式与Java-I-O" class="headerlink" title="6 正则表达式与Java I/O"></a><strong>6 正则表达式与Java I/O</strong></h3><ul>
<li><p>可以利用<code>net.mindview.util.TextFile</code>对象将文件打开，并将结果传递给一个字符串对象：<code>String file = TextFile.read(&quot;filename&quot;)</code></p>
</li>
<li><p>StringReader将String转换为可读的流对象，然后使用流对象构造BufferReader对象，为什么呢？因为我们需要使用BufferReader的<code>readLine()</code>方法读取输入的文本。</p>
<p>如果其中涉及需要将字符串转换成相应的基本数据类型，可以使用相应<strong>基本类型的包装类</strong>的方法进行转换：<code>Integer.parseInt(String str)/Double.parseDouble(String str)/...</code></p>
</li>
<li><p><strong>Scanner类</strong>用于扫描输入的字符串。Scanner类的构造器可以接受任何类型的输入对象，包括File对象 InputStream对象 String对象 Readable对象。在Scanner中，所有的输入、分词以及翻译的操作都可以隐藏在不同类型的<code>next()</code>方法中：<code>next()</code>方法将会简单地返回下一个String对象，<code>nextInt()</code>则会返回下一个整数，<code>nextDouble()</code>则会返回下一个Double类型的数等等。</p>
<p>带参数的<code>hasNext(String regex)</code>方法和带参数的<code>next(String regex)</code>方法联合使用，可以用于寻找下一个匹配的字符串，然后使用<code>Scanner.match()</code>方法，可以返回一个匹配结果MatchResult对象，通过<code>MatchResult.group(int i)</code>方法获得匹配各组的字符串。</p>
</li>
<li><p>StringTokenizer</p>
<p>在Scanner出现之前，用于分词的类，不过现在基本不会再使用了。</p>
</li>
</ul>
<h3 id="附："><a href="#附：" class="headerlink" title="附："></a><strong>附：</strong></h3><h4 id="Java的正则表达式"><a href="#Java的正则表达式" class="headerlink" title="Java的正则表达式"></a><strong>Java的正则表达式</strong></h4><p>有关Java中正则表达式的完整构造子列表，可以参考JDK文档<code>java.util.regex</code>包中的<strong>Pattern</strong>类。</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>