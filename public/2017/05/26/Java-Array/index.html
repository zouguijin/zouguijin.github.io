<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Java---Array | StarSea</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- gallery that comes before the header--><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/JavaBasis/">JavaBasis</a></div><div class="post-time">2017-05-26</div></div></div><div class="container post-header"><h1>Java---Array</h1></div><div class="container post-content"><h2 id="Java-Array——数组"><a href="#Java-Array——数组" class="headerlink" title="Java Array——数组"></a>Java Array——数组</h2><h3 id="1-数组的特点"><a href="#1-数组的特点" class="headerlink" title="1 数组的特点"></a>1 数组的特点</h3><p>作为Java中持有对象的众多方式之一，数组可以说是“年岁已高”，但仍旧是长盛不衰，不论是在基础程序里，还是在算法设计里，都是一个出现频率很高且重点的知识内容。</p>
<p>直观上，对数组的基本看法也就是：“一种持有对象的方法，通过整型索引值访问数组元素，创建并初始化之后，数组大小就固定了，对于元素值的查询和修改的操作比较简单，但对于元素的删除和插入操作较链表来说要复杂”。</p>
<p>具体来说，数组和其他容器的区别有以下三个方面：</p>
<h4 id="（1）效率"><a href="#（1）效率" class="headerlink" title="（1）效率"></a>（1）效率</h4><p>数组是一种效率最高的存储和随机访问对象引用序列的方式，因为数组就是一个简单的<strong>线性序列</strong>。但是，获得效率的代价就是，数组在创建并初始化之后，其大小就已经固定，在其生命周期内不能改变。</p>
<h4 id="（2）类型"><a href="#（2）类型" class="headerlink" title="（2）类型"></a>（2）类型</h4><p>在<strong>泛型出现之前</strong>，数组之所以优于其他容器类，就是因为其他容器类在处理对象的时候，都将对象视为无类型，即将对象当做Object类的对象进行处理。而<strong>数组在创建的时候则必须确定其内部元素的类型</strong>，即数组自创建之后，只能持有相应类型的对象，不能持有该类型之外的其他对象，带来的好处就是可以通过编译期的检查，<strong>尽早地发现和防止插入和获取不正确的类型对象</strong>，而不是等到程序运行起来之后遇到问题而崩溃。</p>
<p>当然，在泛型出现之后，其他的容器类也可以有类型地持有对象了，这是后话——<a href="#ArrayandGenerics">泛型</a></p>
<h4 id="（3）保存基本类型"><a href="#（3）保存基本类型" class="headerlink" title="（3）保存基本类型"></a>（3）保存基本类型</h4><p>在泛型出现之前，只有数组能够持有基本类型。</p>
<p>当然，在泛型出现之后，以及有了基本类型的自动包装类，如Integer/Double等，其他容器类也可以持有基本类型了。</p>
<p>总体来说，在泛型和自动包装类出现之前，数组集“效率、类型安全、广泛应用范围”为一身，地位之高，无人能比，但是在泛型和自动包装类出现之后，数组看似只有在“<strong>效率和性能</strong>”这一方面保有些许优势，除非证明确实是性能的问题，否则<strong>一般还是推荐使用灵活性更好的泛型容器类</strong>。</p>
<h3 id="2-数组是第一级对象"><a href="#2-数组是第一级对象" class="headerlink" title="2 数组是第一级对象"></a>2 数组是第一级对象</h3><p>所谓第一级对象，即<strong>First-class Object</strong>，一般具有以下的特征：</p>
<ul>
<li>可以被存入变量或其他结构；</li>
<li>可以被作为参数传递给其他方法；</li>
<li>可以被作为方法的返回值；</li>
<li>可以在执行期被创建，而无需在设计期全部写出；</li>
<li>有固定的身份/类型，即指实体有内部表示，而不是单纯地根据名字识别。</li>
</ul>
<p>数组的标识符只是一个<strong>引用</strong>，指向在堆中创建的一个<strong>真实对象</strong>，这个（数组）对象用于保存指向其他对象的引用。</p>
<p>length是数组对象的一部分，是一个只读成员，也是唯一一个数组中可以访问的字段或者方法。</p>
<p><code>[]</code>是访问数组对象唯一的方式。</p>
<p>由于数组的标识符只是一个引用，所以在Java中可以<strong>返回一个数组</strong>，即<strong>相当于返回一个引用</strong>，如果该引用一直需要被使用，那么所指向的数组就会保持存在的状态，如果该引用不再使用，那么GC会将该数组所占资源回收。</p>
<p>（但是在<strong>C/C++</strong>中就不是这样简单了，由于不能返回一个数组，而是只能返回指向数组的指针，所以使得控制数组的生命周期变得困难，且没有GC机制，容易造成内存的泄露）</p>
<h3 id="3-数组的初始化"><a href="#3-数组的初始化" class="headerlink" title="3 数组的初始化"></a>3 数组的初始化</h3><p>不论是对象数组还是基本类型数组，使用上几乎相同，唯一的区别只是：<strong>对象数组保存的是引用</strong>，<strong>基本类型数组保存的是基本类型的值</strong>。</p>
<p>（1）仅声明，未初始化：<code>int[] a;</code></p>
<p>（2）<code>new</code>初始化方式：<code>int[] b = new int[3];</code></p>
<p>​    使用<code>new</code>创建数组的时候，可以直接确定数组的大小。对于对象数组，初始化完成之后，数组内的元素（或者说引用）全为<code>null</code>；对于基本类型数组，数值型数组元素初始化为0，char型数组元素初始化为<code>O</code>，boolean型数组元素初始化为<code>false</code>。</p>
<p>（3）聚集初始化方式：<code>int[] c = {1,2,3};</code>或<code>Object[] d = { new Object(), new Object(), new Object()};</code> </p>
<p>（4）<strong>动态</strong>的聚集初始化方式：（先声明 <code>Object[] e;</code>）<code>e = new e[]{ new Object(), new Object()};</code></p>
<p>​    动态聚集初始化的好处在于，如果一个方法需要一个数组的时候，可以不事先定义和创建好数组，在需要的时候根据当时的情况动态创建即可：<code>needArrays(new f[]{new Object(), new Object()});</code></p>
<h3 id="4-多维数组"><a href="#4-多维数组" class="headerlink" title="4 多维数组"></a>4 多维数组</h3><p>多维数组可以看成是一个多维矩阵，每一维的元素其实就是一个引用，指向另一个多维数组。</p>
<p>多维数组的初始化，其实与一维数组是一样的，例如：</p>
<ul>
<li><code>int[][] a;</code></li>
<li><code>int[][][] b = new int[3][4][2]</code>，如果不直接在声明的时候确定维数，那么后续初始化的时候，缺几维就需要有几个<code>new</code></li>
<li><code>Object[][] c = { { new Object(), new Object(), new Object() }, { new Object(), new Object() } };</code>，用花括号区分不同维度</li>
</ul>
<p><code>Arrays.deepToString(array)</code>方法，可以将多维数组转换为多个String，可以用于输出多维数组。该方法对于对象数组和基本类型数组都适用。</p>
<h3 id="5-数组的常用操作"><a href="#5-数组的常用操作" class="headerlink" title="5 数组的常用操作"></a>5 数组的常用操作</h3><p>关于数组的常用操作，可以参见<code>java.util.Arrays</code>，其中有六个基本方法较为常用：</p>
<p>（1）数组的比较——<code>array1.equals(array2)</code></p>
<p><code>equals()</code>方法对所有基本类型和Object都做了<strong>重载</strong>，对于基本类型，需要使用其包装类的<code>equals()</code>方法。</p>
<p><strong>数组与数组相等的条件</strong>是元素个数必须相等，并且对应位置的元素也相等。</p>
<p>（2）数组的填充——<code>Arrays.fill(Object[] a, Object x)</code></p>
<p><code>Arrays.fill()</code>是数组的静态方法，用于填充已经初始化好了的数组，默认是用一个相应类型的元素填充整个数组，也可以用元素填充一个区域：<code>Arrays.fill(Object[] a, int begin, int end, Object x)</code>。</p>
<p>（3）数组元素的排序——<code>Arrays.sort(Object[] a)</code></p>
<p>排序，必须根据<strong>对象的实际类型执行比较操作</strong>，从而得出相应的排序结果。</p>
<blockquote>
<p>将保持不变的事物与会发生改变的事物相分离</p>
</blockquote>
<p>排序的算法大体也就那么几种，变化不大，不同的数组元素排序，变化的只是数组元素的类型和不同类型中的比较方式，所以应该将排序算法与数组元素类型两者相分离，排序算法作为不变的部分封装起来，向外提供<strong>参数接口</strong>，而<strong>数组元素类型和相应的比较方式则封装到一个新的单独的类中</strong>，最后只需要用<strong>不同的对象代表不同的比较方式</strong>，传入已经写好排序算法的数组排序方法<code>Arrays.sort()</code>中即可。</p>
<p><a href="">Java的两种比较方式：java.lang.Comparable接口&amp;java.util.Cpmparator接口</a></p>
<ul>
<li><p>实现Comparable接口之后，需要实现其中唯一的方法<code>compareTo()</code>，然后在该方法内定义比较的方法，即决定两个对象之间如何作比较、如何返回比较的结果。</p>
</li>
<li><p>实现Comparator接口之后，需要实现其中的<code>compare()</code>方法，同样在方法中定义了对象之间比较的方法。</p>
<p>除了自己实现Comparator接口之外，<strong>Collections类</strong>包含一个<code>reverseOrder()</code>方法，该方法可以产生一个Comparator：<code>Collections.reverseOrder()</code>，可以作为已经定义好的比较类的对象，作为参数传入排序方法中。</p>
<p><strong>基本类型无法使用Cpmparator进行排序。</strong></p>
</li>
</ul>
<p>（4）数组的字符串表示——<code>Arrays.toString(Object[] a)</code></p>
<p>将数组转换为字符串对象。</p>
<p>（5）数组的散列码——<code>array1.hashCode()</code></p>
<p>该方法用于产生数组的散列码。</p>
<p>产生散列码有什么用呢？主要的作用是，尽量使得<strong>不同的对象拥有不同的哈希值</strong>，使得对象能够成为HashTable的Key值或者成为HashSet的成员。</p>
<p>因为JDK中所有<strong>基于哈希的集合</strong>都是将值存储在<strong>数组</strong>之中，在<strong>查找元素/存储元素</strong>的时候，会先使用哈希值计算出数组的初始查找位置/存储位置，如果是单纯地查找元素，那么会调用<code>equals()</code>方法将给定的值和数组中存储对象的值进行比较；如果是存储元素，如果该位置上没有元素，则直接存储即可，如果已经有元素，则会调用<code>equals()</code>方法与新元素进行比较，相同则不存，不相同则为<strong>哈希冲突</strong>，散列表将会根据相应的处理办法，将新元素存储在适当的位置。如果所有元素的哈希值都不一样，那么将会减少哈希的碰撞概率。</p>
<p><strong>为什么会使用基于哈希的集合存储元素或者对象？</strong></p>
<p>集合有保证元素不重复的需要，怎么做到不重复呢？从头到尾调用<code>equals()</code>方法比较一遍么？效率太低！所以Java采用了哈希表的原理，根据<strong>哈希算法将数据直接指定到一个地址上</strong>，之后只需要调用<code>hashCode()</code>方法即可直接返回该对象的存储位置，方便快捷，不需要一点一点的调用<code>equals()</code>方法比较。</p>
<p>如此说来，一个对象在实现<code>hashCode()</code>方法的同时，还需要实现<code>equals()</code>方法，而且这两种方法的实现必须是<strong>一致</strong>的：</p>
<ul>
<li><code>a.equals(b)</code>返回<code>true</code>等价于<code>a.hashCode() == b.hashCode()</code></li>
<li>如果一个对象没有被修改过，那么该对象的<code>hashCode()</code>方法调用多少次，返回的结果都应该是相同的。</li>
</ul>
<p>（6）有序数组的元素查找——<code>Arrays.binarySearch(Object[] a, Object x)</code></p>
<p>若数组已经<strong>有序</strong>，就可以使用<code>binarySearch()</code>方法对数组元素进行快速查找，否则不能使用。</p>
<p>若在数组中找到了相应的元素，则返回该元素的数组索引（<code>0~array1.length-1</code>），否则返回负值。</p>
<p>（7）<strong>数组的容器化</strong>——<code>Arrays.asList(Object[] a)</code></p>
<p>该方法接受任意的序列和数组作为参数，返回一个List容器。</p>
<p>（8）数组的复制（浅复制）——<code>System.arraycopy()</code></p>
<p><code>System.arraycopy(Object[] A, int a, Object[] B, int b, int length)</code></p>
<p>该方法是Java标准类库提供的静态方法，用于将A数组从索引a开始，长度为length的一部分元素，复制移动到数组B从索引b开始、长度为length的部分，<strong>会将原有部分覆盖</strong>。</p>
<p>该方法复制数组，较<code>for</code>循环的方式要快。该方法对于基本类型数组和对象数组都可以使用，但是对于对象数组使用时，复制的仅仅是对象的引用，而不是对象本身的拷贝，所以是<strong>浅复制</strong>。此外，该方法不会执行自动包装和自动拆包的操作，所以进行操作的两个数组的类型必须一致。</p>
<h3 id="6-数组与泛型"><a href="#6-数组与泛型" class="headerlink" title="6 数组与泛型"></a>6 数组与泛型</h3><p><span id="ArrayandGenerics"></span></p>
<h4 id="（1）泛型的擦除"><a href="#（1）泛型的擦除" class="headerlink" title="（1）泛型的擦除"></a>（1）泛型的擦除</h4><p>数组和泛型不能很好地结合，Java也不支持“泛型数组”这个东西，原因在于：<strong>数组在创建的时候必须知道内部元素的类型</strong>，而且在数组的生存周期中，数组会一直记得这个类型的信息，每一次访问数组元素都会进行类型检查。而Java泛型是通过<strong>擦除（Erasure）</strong>操作实现的，在运行的时候类型参数将会被擦除，只有在<strong>最后获取泛型内部元素</strong>的时候，才会加上一个类型转换，如下所示，运行编译器只能看到注释之后的情况，看不到泛型参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; str = new ArrayList&lt;String&gt;(); // List str = new ArrayList();</div><div class="line">str.add(&quot;hi&quot;); // str.add(&quot;hi&quot;);</div><div class="line">String s = str.get(0); // String s = (String)str.get(0);</div></pre></td></tr></table></figure>
<p>所以，如下的泛型数组是错误的，编译器只能够看到ArrayList，而看不到类型参数String，由于无法确定类型，数组不允许初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt;[] str = new ArrayList&lt;String&gt;[3]; // Error</div></pre></td></tr></table></figure>
<h4 id="（2）数组的协变"><a href="#（2）数组的协变" class="headerlink" title="（2）数组的协变"></a>（2）数组的协变</h4><p>在泛型出现之前，很多代码迫切需要<strong>“泛型”</strong>的概念解决问题，即“泛化”地接受任何类型的元素作为方法的参数，实现方法的复用，而不必每一个类型的每一个方法都要重新定义一次。</p>
<p>所以，各种对象数组都设计成为了Object类数组的派生类，比如String[]、Integer[]等等，这样一来Object[]就能够接受所有的数组类型，即多态，在执行期间判断所引用对象的实际类型，然后调用相应的方法。</p>
<p>由于数组的特性：<strong>数组在创建的时候必须知道内部元素的类型，且在运行的时候会进行类型检查</strong>，所以数组设计成为“协变”没什么大问题，但是容器Collection就不能设计为“协变”了，因为Collection在运行的时候会对类型进行擦除，而不会进行类型检查，只有在获取内部元素的时候才会附加上类型的信息，如果Collection被设计成“协变”，那么不同类型之间的容器类就可以按照“<strong>向上转型</strong>”的规则传递对象，这样一来在获取内部元素的时候，取出来的就可能是别的类型，从而发生错误。</p>
<p>但，好像人们一直在追求容器功能的最大化，所以最终通过引入<strong>通配符（Wildcard）</strong>，容器类的协变功能也实现了，通配符上界和下界的时候，让容器内元素的类型受到了严格的控制，基本不会出现之前的问题，虽然还挺复杂的…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;? extends Number&gt; a = new ArrayList&lt;Integer&gt;();</div></pre></td></tr></table></figure>
<p>总的来说，数组的“协变”是上一个阶段Java发展所需的产物，是泛型出现之前的替代，由于涉及到底层Object[]，现在如果想改也不行了，除非重新创造一门新语言。</p>
<h3 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h3><ul>
<li>有关泛型的更多内容，请参阅：<a href="">Java泛型——Generics</a></li>
<li>有关泛型通配符的内容，请参阅：<a href="">Java泛型——Generics</a></li>
</ul>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>