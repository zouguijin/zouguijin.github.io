<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>leetcode53 Maximum Subarray | StarSea</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- gallery that comes before the header--><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/DynamicProgramming/">DynamicProgramming</a><a class="post-tag-link" href="/tags/array/">array</a><a class="post-tag-link" href="/tags/leetcode/">leetcode</a></div><div class="post-time">2017-09-04</div></div></div><div class="container post-header"><h1>leetcode53 Maximum Subarray</h1></div><div class="container post-content"><h2 id="leetcode-53-Maximum-Subarray"><a href="#leetcode-53-Maximum-Subarray" class="headerlink" title="leetcode#53 Maximum Subarray"></a>leetcode#53 Maximum Subarray</h2><blockquote>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example, given the array <code>[-2,1,-3,4,-1,2,1,-5,4]</code>,<br>the contiguous subarray <code>[4,-1,2,1]</code> has the largest sum = <code>6</code>.</p>
</blockquote>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>给定一个数组，要求找到该数组的一个连续子集，使得该子集元素之和最大。</p>
<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>最简单最容易想到的方式就是，依次遍历，依次累加，依次比较，将这个过程中最大的和存储下来。——毫无疑问，这样的方式虽然可行，但是将会是一个O(n2)时间复杂度的算法。</p>
<h4 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h4><p>时间复杂度O(n2)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    public int maxSubArray(int[] nums) &#123;</div><div class="line">        int maxSum = nums[0];</div><div class="line">        for(int i = 0; i &lt; nums.length; i++) &#123;</div><div class="line">            int maxTmp = nums[i];</div><div class="line">            if(maxTmp &gt; maxSum) maxSum = maxTmp;</div><div class="line">            for(int j = i + 1; j &lt; nums.length; j++) &#123;</div><div class="line">                maxTmp = maxTmp + nums[j];</div><div class="line">                if(maxTmp &gt; maxSum) maxSum = maxTmp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return maxSum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="大神解法"><a href="#大神解法" class="headerlink" title="大神解法"></a>大神解法</h4><p>解法一：No DP</p>
<p><code>maxSoFar</code> 存储全局最大的值，<code>maxEndingHere</code> 存储着累加到当前位置的最大值，因为移动累加的过程中，不一定是从头开始依次累加的，有可能中间由于某个值大于前面所有累加的值，这时候就需要将<code>maxEndingHere</code> 替换成当前的单个值（丢弃前面的累加结果），并从当前位置开始往后累加。</p>
<p>这里面的想法为：<strong>如果 i位置的数 &lt; i位置前的加和 + i位置的数，说明i位置前的加和是负数</strong>，将会“拖累”后续的和，所以必须将其丢弃，而重新从i位置开始计算加和。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static int maxSubArray(int[] A) &#123;</div><div class="line">    int maxSoFar=A[0], maxEndingHere=A[0];</div><div class="line">    for (int i=1;i&lt;A.length;++i)&#123;</div><div class="line">    	maxEndingHere= Math.max(maxEndingHere+A[i],A[i]);</div><div class="line">    	maxSoFar=Math.max(maxSoFar, maxEndingHere);	</div><div class="line">    &#125;</div><div class="line">    return maxSoFar;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解法二：<strong>DP(Dynamic Programming)动态规划</strong></p>
<p>用DP思想来看本题，本题就是一个优化问题——找出一个最优值（最大值）。</p>
<p>DP算法的本质，就是将原问题划分成多个容易解决的子问题，然后将各个子问题各个击破，并将结果汇总得到原问题的答案。</p>
<p>所以，DP算法的第一步，就是要找出子问题的表达形式（状态），子问题表达的好，构建出算法代码也就简单。——大神最后给出的子问题表达形式为：<code>maxSubArray(int A[], int i)</code> 而不是<code>maxSubArray(int A[], int i, int j)</code> ，因为后者有i/j两个变量，过于灵活多变，不利于构建一个简单的解法。于是最后的整体表达式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">maxSubArray(A, i) = maxSubArray(A, i - 1) &gt; 0 ? maxSubArray(A, i - 1) : 0 + A[i];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public int maxSubArray(int[] A) &#123;</div><div class="line">        int n = A.length;</div><div class="line">        int[] dp = new int[n];//dp[i] means the maximum subarray ending with A[i];</div><div class="line">        dp[0] = A[0];</div><div class="line">        int max = dp[0];</div><div class="line">        </div><div class="line">        for(int i = 1; i &lt; n; i++)&#123;</div><div class="line">            dp[i] = A[i] + (dp[i - 1] &gt; 0 ? dp[i - 1] : 0);</div><div class="line">            max = Math.max(max, dp[i]);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        return max;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，<code>dp[i]</code> 存储的是<code>A[0:i]</code>的所有子集中加和的最大值，对应着<code>maxSubArray(A, i)</code> 。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本题归类为一个Easy题，还是可以接受的，至少暴力解法能很容易地想到，但是如果没有DP经验，那么很难想到其他的解法。上述的两个大神解法，其实是很类似的，由于本题较为简单，所以DP解法中也没有使用<strong>递归</strong>，只是简单地将DP的思路用一个新的数组表达了一下，具有普适性；NO DP解法则更为简洁一点。</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>