<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>leetcode160 IntersectionofTwoLinkedLists | StarSea</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- gallery that comes before the header--><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/leetcode/">leetcode</a><a class="post-tag-link" href="/tags/linkedlist/">linkedlist</a></div><div class="post-time">2017-04-05</div></div></div><div class="container post-header"><h1>leetcode160 IntersectionofTwoLinkedLists</h1></div><div class="container post-content"><h2 id="leetcode-160-Intersection-of-Two-Linked-Lists"><a href="#leetcode-160-Intersection-of-Two-Linked-Lists" class="headerlink" title="leetcode#160 Intersection of Two Linked Lists"></a>leetcode#160 Intersection of Two Linked Lists</h2><blockquote>
<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p>For example, the following two linked lists:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;A:          a1 → a2</div><div class="line">&gt;                   ↘</div><div class="line">&gt;                     c1 → c2 → c3</div><div class="line">&gt;                   ↗            </div><div class="line">&gt;B:     b1 → b2 → b3</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>begin to intersect at node c1.</p>
<p><strong>Notes:</strong></p>
<ul>
<li>If the two linked lists have no intersection at all, return <code>null</code>.</li>
<li>The linked lists must retain their original structure after the function returns.</li>
<li>You may assume there are no cycles anywhere in the entire linked structure.</li>
<li>Your code should preferably run in O(n) time and use only O(1) memory.</li>
</ul>
</blockquote>
<h5 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h5><p>找出两个单链表相交的节点（第一个相交的节点）。</p>
<p>注意：</p>
<ul>
<li>如果两个单链表没有相交的节点，返回<code>null</code></li>
<li>在返回之后，两个单链表必须保持原有的结构状态</li>
<li>本题可以假设没有环路</li>
<li>时间复杂度要求<code>O(n)</code>，空间复杂度要求<code>O(1)</code> </li>
</ul>
<h5 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h5><ul>
<li>可能两条链表没有交点，所以必须遍历到链表的最后</li>
<li>返回后保持链表的原有结构，那么递归方式就不太好使用</li>
<li>没有环路，意味着可以一次遍历到链表的末尾</li>
<li>时间复杂度<code>O(n)</code>限制了循环最多是所有链表节点，不能有两层及以上的遍历链表出现；空间复杂度<code>O(1)</code>限制了不能构造另外的数据结构，用于暂存链表节点，只能在原有的链表结构上操作</li>
</ul>
<p>要求越多，题目的解决方式就会更清晰。</p>
<p>根据上述情况的描述，可以从两条链表节点数的不同入手。在相交节点之后，两条链表的节点是相同的，所以节点数的不同只会出现在相交节点之前的部分。</p>
<p>如果两个链表都从距离相交节点相同路程的节点出发，以相同的遍历速度往前走，则一定会在相交节点相遇，此时返回当前节点即可。</p>
<p>至于如何确定两个链表遍历的起始位置，可以先分别遍历一次，得到两个链表各自的节点数目，比较，较多的一方先向前移动差值的路程，最后再开始一起向后遍历。</p>
<h5 id="我的解法："><a href="#我的解法：" class="headerlink" title="我的解法："></a>我的解法：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * public class ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode next;</div><div class="line"> *     ListNode(int x) &#123;</div><div class="line"> *         val = x;</div><div class="line"> *         next = null;</div><div class="line"> *     &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">public class Solution &#123;</div><div class="line">    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</div><div class="line">        ListNode tmpA = headA;</div><div class="line">        ListNode tmpB = headB;</div><div class="line">        int countA = 0;</div><div class="line">        int countB = 0;</div><div class="line">        </div><div class="line">        if(headA == null || headB == null) &#123; return null; &#125;</div><div class="line">        </div><div class="line">        while(tmpA != null) &#123;</div><div class="line">            countA++;</div><div class="line">            tmpA = tmpA.next;</div><div class="line">        &#125;</div><div class="line">        while(tmpB != null) &#123;</div><div class="line">            countB++;</div><div class="line">            tmpB = tmpB.next;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        tmpA = headA;</div><div class="line">        tmpB = headB;</div><div class="line">        if(countA &gt; countB) &#123;</div><div class="line">            for(int i = 0;i&lt;(countA - countB);i++) &#123; tmpA = tmpA.next; &#125;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            for(int i = 0;i&lt;(countB - countA);i++) &#123; tmpB = tmpB.next; &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        while(tmpA != tmpB) &#123;</div><div class="line">            if(tmpA == null || tmpB == null) &#123; return null; &#125;</div><div class="line">            else &#123;</div><div class="line">                tmpA = tmpA.next;</div><div class="line">                tmpB = tmpB.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return tmpA;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="大神的解法："><a href="#大神的解法：" class="headerlink" title="大神的解法："></a>大神的解法：</h5><p>很巧妙，考虑到了路程的关系。</p>
<p>假设<code>headA</code>到相交节点的距离是A，<code>headB</code>到相交节点的距离是B，从相交节点到末尾的距离是C，则可以不用事先判断两条链表的节点数之差，只需要走一圈肯定会相遇与相交节点，因为<code>A+B+C = B+A+C</code>，即分别从头开始分别遍历两条链表，遇到末尾时跳转到另外一条链表的首部继续遍历，如果存在相交节点，走完一圈肯定会相遇，否则肯定没有相交节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</div><div class="line">    if(headA == null || headB == null) return null;</div><div class="line">    </div><div class="line">    ListNode a = headA;</div><div class="line">    ListNode b = headB;</div><div class="line"> </div><div class="line">    while( a != b)&#123;</div><div class="line">    	//for the end of first iteration, we just reset the pointer to the head of another linkedlist</div><div class="line">        a = a == null? headB : a.next;</div><div class="line">        b = b == null? headA : b.next;    </div><div class="line">    &#125;</div><div class="line">    return a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>好的算法都是精致的数学关系。</p>
<p>有时候你只考虑到了一个层面的数学关系，把眼界放宽，放远一点，也许就能看到下一层面的、更精致的数学关系。</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>